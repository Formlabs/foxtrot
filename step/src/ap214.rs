// Autogenerated file, do not hand-edit!
use crate::{
    id::{Id, HasId},
    parse::{IResult, Logical, Derived, Parse, ParseFromChunks, nom_alt_err,
            parse_enum_tag, param_from_chunks, parse_complex_mapping},
    step_file::FromEntity,
};
use nom::{
    branch::{alt},
    bytes::complete::tag,
    character::complete::{alpha0, alphanumeric1, char},
    combinator::{map, recognize},
    multi::{many0},
    sequence::{delimited, pair},
};
use arrayvec::ArrayVec;
#[derive(Debug)]
pub struct AbsFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AbsFunction<'a> = Id<AbsFunction_<'a>>;
impl<'a> FromEntity<'a> for AbsFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AbsFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AbsFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ABS_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AbsFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AcosFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AcosFunction<'a> = Id<AcosFunction_<'a>>;
impl<'a> FromEntity<'a> for AcosFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AcosFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AcosFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACOS_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AcosFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Action_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Action<'a> = Id<Action_<'a>>;
impl<'a> FromEntity<'a> for Action_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Action(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Action_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Action_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionAssignment_<'a> { // entity
    pub assigned_action: Action<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionAssignment<'a> = Id<ActionAssignment_<'a>>;
impl<'a> FromEntity<'a> for ActionAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_action) = param_from_chunks::<Action<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_action,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_action.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionDirective_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub analysis: Text<'a>,
    pub comment: Text<'a>,
    pub requests: Vec<VersionedActionRequest<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionDirective<'a> = Id<ActionDirective_<'a>>;
impl<'a> FromEntity<'a> for ActionDirective_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionDirective(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionDirective_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_DIRECTIVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, analysis) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, comment) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, requests) = param_from_chunks::<Vec<VersionedActionRequest<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            analysis,
            comment,
            requests,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionDirective_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.analysis.append_ids(_v);
        self.comment.append_ids(_v);
        self.requests.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ActionItem<'a> = Id<ActionItem_<'a>>;

#[derive(Debug)]
pub struct ActionMethod_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub consequence: Text<'a>,
    pub purpose: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionMethod<'a> = Id<ActionMethod_<'a>>;
impl<'a> FromEntity<'a> for ActionMethod_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionMethod(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionMethod_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_METHOD(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, consequence) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            consequence,
            purpose,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionMethod_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.consequence.append_ids(_v);
        self.purpose.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionMethodRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_method: ActionMethod<'a>,
    pub related_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionMethodRelationship<'a> = Id<ActionMethodRelationship_<'a>>;
impl<'a> FromEntity<'a> for ActionMethodRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionMethodRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionMethodRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_METHOD_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_method) = param_from_chunks::<ActionMethod<'a>>(false, s, &mut i, strs)?;
        let (s, related_method) = param_from_chunks::<ActionMethod<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_method,
            related_method,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionMethodRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_method.append_ids(_v);
        self.related_method.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub definition: CharacterizedActionDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionProperty<'a> = Id<ActionProperty_<'a>>;
impl<'a> FromEntity<'a> for ActionProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionProperty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_PROPERTY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<CharacterizedActionDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionProperty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionPropertyRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub property: ActionProperty<'a>,
    pub representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionPropertyRepresentation<'a> = Id<ActionPropertyRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ActionPropertyRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionPropertyRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionPropertyRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_PROPERTY_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, property) = param_from_chunks::<ActionProperty<'a>>(false, s, &mut i, strs)?;
        let (s, representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            property,
            representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionPropertyRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.property.append_ids(_v);
        self.representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_action: Action<'a>,
    pub related_action: Action<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRelationship<'a> = Id<ActionRelationship_<'a>>;
impl<'a> FromEntity<'a> for ActionRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_action) = param_from_chunks::<Action<'a>>(false, s, &mut i, strs)?;
        let (s, related_action) = param_from_chunks::<Action<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_action,
            related_action,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_action.append_ids(_v);
        self.related_action.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionRequestAssignment_<'a> { // entity
    pub assigned_action_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestAssignment<'a> = Id<ActionRequestAssignment_<'a>>;
impl<'a> FromEntity<'a> for ActionRequestAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRequestAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionRequestAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_REQUEST_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_action_request) = param_from_chunks::<VersionedActionRequest<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_action_request,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionRequestAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_action_request.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionRequestItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ActionRequestItem<'a> = Id<ActionRequestItem_<'a>>;

#[derive(Debug)]
pub struct ActionRequestSolution_<'a> { // entity
    pub method: ActionMethod<'a>,
    pub request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestSolution<'a> = Id<ActionRequestSolution_<'a>>;
impl<'a> FromEntity<'a> for ActionRequestSolution_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRequestSolution(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionRequestSolution_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_REQUEST_SOLUTION(")(strs[0])?;
        let (s, method) = param_from_chunks::<ActionMethod<'a>>(false, s, &mut i, strs)?;
        let (s, request) = param_from_chunks::<VersionedActionRequest<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            method,
            request,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionRequestSolution_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.method.append_ids(_v);
        self.request.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionRequestStatus_<'a> { // entity
    pub status: Label<'a>,
    pub assigned_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionRequestStatus<'a> = Id<ActionRequestStatus_<'a>>;
impl<'a> FromEntity<'a> for ActionRequestStatus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionRequestStatus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionRequestStatus_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_REQUEST_STATUS(")(strs[0])?;
        let (s, status) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, assigned_request) = param_from_chunks::<VersionedActionRequest<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            status,
            assigned_request,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionRequestStatus_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.status.append_ids(_v);
        self.assigned_request.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionResource_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub usage: Vec<SupportedItem<'a>>,
    pub kind: ActionResourceType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResource<'a> = Id<ActionResource_<'a>>;
impl<'a> FromEntity<'a> for ActionResource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionResource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionResource_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_RESOURCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, usage) = param_from_chunks::<Vec<SupportedItem<'a>>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<ActionResourceType<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            usage,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionResource_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.usage.append_ids(_v);
        self.kind.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionResourceRequirement_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub kind: ResourceRequirementType<'a>,
    pub operations: Vec<CharacterizedActionDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResourceRequirement<'a> = Id<ActionResourceRequirement_<'a>>;
impl<'a> FromEntity<'a> for ActionResourceRequirement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionResourceRequirement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionResourceRequirement_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_RESOURCE_REQUIREMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<ResourceRequirementType<'a>>(false, s, &mut i, strs)?;
        let (s, operations) = param_from_chunks::<Vec<CharacterizedActionDefinition<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            kind,
            operations,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionResourceRequirement_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.kind.append_ids(_v);
        self.operations.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionResourceType_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionResourceType<'a> = Id<ActionResourceType_<'a>>;
impl<'a> FromEntity<'a> for ActionResourceType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionResourceType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionResourceType_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_RESOURCE_TYPE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionResourceType_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ActionStatus_<'a> { // entity
    pub status: Label<'a>,
    pub assigned_action: ExecutedAction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ActionStatus<'a> = Id<ActionStatus_<'a>>;
impl<'a> FromEntity<'a> for ActionStatus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ActionStatus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ActionStatus_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ACTION_STATUS(")(strs[0])?;
        let (s, status) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, assigned_action) = param_from_chunks::<ExecutedAction<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            status,
            assigned_action,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ActionStatus_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.status.append_ids(_v);
        self.assigned_action.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Address_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Address<'a> = Id<Address_<'a>>;
impl<'a> FromEntity<'a> for Address_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Address(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Address_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ADDRESS(")(strs[0])?;
        let (s, internal_location) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, street_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, street) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, postal_box) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, town) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, region) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, postal_code) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, country) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, facsimile_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, telephone_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, electronic_mail_address) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, telex_number) = param_from_chunks::<Option<Label<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            internal_location,
            street_number,
            street,
            postal_box,
            town,
            region,
            postal_code,
            country,
            facsimile_number,
            telephone_number,
            electronic_mail_address,
            telex_number,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Address_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.internal_location.append_ids(_v);
        self.street_number.append_ids(_v);
        self.street.append_ids(_v);
        self.postal_box.append_ids(_v);
        self.town.append_ids(_v);
        self.region.append_ids(_v);
        self.postal_code.append_ids(_v);
        self.country.append_ids(_v);
        self.facsimile_number.append_ids(_v);
        self.telephone_number.append_ids(_v);
        self.electronic_mail_address.append_ids(_v);
        self.telex_number.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AdvancedBrepShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AdvancedBrepShapeRepresentation<'a> = Id<AdvancedBrepShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for AdvancedBrepShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AdvancedBrepShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AdvancedBrepShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ADVANCED_BREP_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AdvancedBrepShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AdvancedFace_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub face_geometry: Surface<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AdvancedFace<'a> = Id<AdvancedFace_<'a>>;
impl<'a> FromEntity<'a> for AdvancedFace_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AdvancedFace(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AdvancedFace_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ADVANCED_FACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, bounds) = param_from_chunks::<Vec<FaceBound<'a>>>(false, s, &mut i, strs)?;
        let (s, face_geometry) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, same_sense) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            bounds,
            face_geometry,
            same_sense,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AdvancedFace_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.bounds.append_ids(_v);
        self.face_geometry.append_ids(_v);
        self.same_sense.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum AheadOrBehind<'a> { // enum
    Ahead,
    Exact,
    Behind,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AheadOrBehind<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AheadOrBehind::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "AHEAD" => Ahead,
            "EXACT" => Exact,
            "BEHIND" => Behind,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for AheadOrBehind<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct AlternateProductRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub definition: Option<Text<'a>>,
    pub alternate: Product<'a>,
    pub base: Product<'a>,
    pub basis: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AlternateProductRelationship<'a> = Id<AlternateProductRelationship_<'a>>;
impl<'a> FromEntity<'a> for AlternateProductRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AlternateProductRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AlternateProductRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ALTERNATE_PRODUCT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, alternate) = param_from_chunks::<Product<'a>>(false, s, &mut i, strs)?;
        let (s, base) = param_from_chunks::<Product<'a>>(false, s, &mut i, strs)?;
        let (s, basis) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            definition,
            alternate,
            base,
            basis,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AlternateProductRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.definition.append_ids(_v);
        self.alternate.append_ids(_v);
        self.base.append_ids(_v);
        self.basis.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AmountOfSubstanceMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AmountOfSubstanceMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for AmountOfSubstanceMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct AmountOfSubstanceMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AmountOfSubstanceMeasureWithUnit<'a> = Id<AmountOfSubstanceMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for AmountOfSubstanceMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AmountOfSubstanceMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AmountOfSubstanceMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AmountOfSubstanceMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AmountOfSubstanceUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AmountOfSubstanceUnit<'a> = Id<AmountOfSubstanceUnit_<'a>>;
impl<'a> FromEntity<'a> for AmountOfSubstanceUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AmountOfSubstanceUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AmountOfSubstanceUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AMOUNT_OF_SUBSTANCE_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AmountOfSubstanceUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AndExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AndExpression<'a> = Id<AndExpression_<'a>>;
impl<'a> FromEntity<'a> for AndExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AndExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AndExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AND_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AndExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum AngleRelator<'a> { // enum
    Equal,
    Large,
    Small,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for AngleRelator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use AngleRelator::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "EQUAL" => Equal,
            "LARGE" => Large,
            "SMALL" => Small,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for AngleRelator<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct AngularDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularDimension<'a> = Id<AngularDimension_<'a>>;
impl<'a> FromEntity<'a> for AngularDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AngularDimension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANGULAR_DIMENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AngularDimension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AngularLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    pub angle_selection: AngleRelator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularLocation<'a> = Id<AngularLocation_<'a>>;
impl<'a> FromEntity<'a> for AngularLocation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularLocation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AngularLocation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANGULAR_LOCATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, angle_selection) = param_from_chunks::<AngleRelator<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            angle_selection,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AngularLocation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
        self.angle_selection.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AngularSize_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub angle_selection: AngleRelator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularSize<'a> = Id<AngularSize_<'a>>;
impl<'a> FromEntity<'a> for AngularSize_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularSize(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AngularSize_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANGULAR_SIZE(")(strs[0])?;
        let (s, applies_to) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, angle_selection) = param_from_chunks::<AngleRelator<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to,
            name,
            angle_selection,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AngularSize_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to.append_ids(_v);
        self.name.append_ids(_v);
        self.angle_selection.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AngularityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AngularityTolerance<'a> = Id<AngularityTolerance_<'a>>;
impl<'a> FromEntity<'a> for AngularityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AngularityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AngularityTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANGULARITY_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AngularityTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationCurveOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationCurveOccurrence<'a> = Id<AnnotationCurveOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationCurveOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationCurveOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationCurveOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_CURVE_OCCURRENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationCurveOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationFillArea_<'a> { // entity
    pub name: Label<'a>,
    pub boundaries: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationFillArea<'a> = Id<AnnotationFillArea_<'a>>;
impl<'a> FromEntity<'a> for AnnotationFillArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationFillArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationFillArea_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_FILL_AREA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, boundaries) = param_from_chunks::<Vec<Curve<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            boundaries,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationFillArea_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.boundaries.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationFillAreaOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub fill_style_target: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationFillAreaOccurrence<'a> = Id<AnnotationFillAreaOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationFillAreaOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationFillAreaOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationFillAreaOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_FILL_AREA_OCCURRENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, fill_style_target) = param_from_chunks::<Point<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            fill_style_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationFillAreaOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.fill_style_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrence<'a> = Id<AnnotationOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_OCCURRENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationOccurrenceAssociativity_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_annotation_occurrence: AnnotationOccurrence<'a>,
    pub related_annotation_occurrence: AnnotationOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrenceAssociativity<'a> = Id<AnnotationOccurrenceAssociativity_<'a>>;
impl<'a> FromEntity<'a> for AnnotationOccurrenceAssociativity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationOccurrenceAssociativity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationOccurrenceAssociativity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_OCCURRENCE_ASSOCIATIVITY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_annotation_occurrence) = param_from_chunks::<AnnotationOccurrence<'a>>(false, s, &mut i, strs)?;
        let (s, related_annotation_occurrence) = param_from_chunks::<AnnotationOccurrence<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_annotation_occurrence,
            related_annotation_occurrence,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationOccurrenceAssociativity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_annotation_occurrence.append_ids(_v);
        self.related_annotation_occurrence.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationOccurrenceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_annotation_occurrence: AnnotationOccurrence<'a>,
    pub related_annotation_occurrence: AnnotationOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationOccurrenceRelationship<'a> = Id<AnnotationOccurrenceRelationship_<'a>>;
impl<'a> FromEntity<'a> for AnnotationOccurrenceRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationOccurrenceRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationOccurrenceRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_OCCURRENCE_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_annotation_occurrence) = param_from_chunks::<AnnotationOccurrence<'a>>(false, s, &mut i, strs)?;
        let (s, related_annotation_occurrence) = param_from_chunks::<AnnotationOccurrence<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_annotation_occurrence,
            related_annotation_occurrence,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationOccurrenceRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_annotation_occurrence.append_ids(_v);
        self.related_annotation_occurrence.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct AnnotationPlane_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub elements: Option<Vec<AnnotationPlaneElement<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationPlane<'a> = Id<AnnotationPlane_<'a>>;
impl<'a> FromEntity<'a> for AnnotationPlane_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationPlane(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationPlane_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_PLANE(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, elements) = param_from_chunks::<Option<Vec<AnnotationPlaneElement<'a>>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            styles,
            item,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationPlane_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationPlaneElement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationPlaneElement<'a> = Id<AnnotationPlaneElement_<'a>>;

#[derive(Debug)]
pub struct AnnotationSubfigureOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSubfigureOccurrence<'a> = Id<AnnotationSubfigureOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationSubfigureOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationSubfigureOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationSubfigureOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_SUBFIGURE_OCCURRENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationSubfigureOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSymbol<'a> = Id<AnnotationSymbol_<'a>>;
impl<'a> FromEntity<'a> for AnnotationSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationSymbolOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationSymbolOccurrence<'a> = Id<AnnotationSymbolOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationSymbolOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationSymbolOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationSymbolOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_SYMBOL_OCCURRENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationSymbolOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationSymbolOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationSymbolOccurrenceItem<'a> = Id<AnnotationSymbolOccurrenceItem_<'a>>;

#[derive(Debug)]
pub struct AnnotationText_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationText<'a> = Id<AnnotationText_<'a>>;
impl<'a> FromEntity<'a> for AnnotationText_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationText(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationText_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_TEXT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationText_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationTextCharacter_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    pub alignment: TextAlignment<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationTextCharacter<'a> = Id<AnnotationTextCharacter_<'a>>;
impl<'a> FromEntity<'a> for AnnotationTextCharacter_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationTextCharacter(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationTextCharacter_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_TEXT_CHARACTER(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            alignment,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationTextCharacter_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
        self.alignment.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationTextOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AnnotationTextOccurrence<'a> = Id<AnnotationTextOccurrence_<'a>>;
impl<'a> FromEntity<'a> for AnnotationTextOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AnnotationTextOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AnnotationTextOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ANNOTATION_TEXT_OCCURRENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AnnotationTextOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AnnotationTextOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AnnotationTextOccurrenceItem<'a> = Id<AnnotationTextOccurrenceItem_<'a>>;

#[derive(Debug)]
pub struct Apex_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Apex<'a> = Id<Apex_<'a>>;
impl<'a> FromEntity<'a> for Apex_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Apex(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Apex_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APEX(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Apex_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApplicationContext_<'a> { // entity
    pub application: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContext<'a> = Id<ApplicationContext_<'a>>;
impl<'a> FromEntity<'a> for ApplicationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApplicationContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLICATION_CONTEXT(")(strs[0])?;
        let (s, application) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            application,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApplicationContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.application.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApplicationContextElement_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContextElement<'a> = Id<ApplicationContextElement_<'a>>;
impl<'a> FromEntity<'a> for ApplicationContextElement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationContextElement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApplicationContextElement_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLICATION_CONTEXT_ELEMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ApplicationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApplicationContextElement_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApplicationContextRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_context: ApplicationContext<'a>,
    pub related_context: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationContextRelationship<'a> = Id<ApplicationContextRelationship_<'a>>;
impl<'a> FromEntity<'a> for ApplicationContextRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationContextRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApplicationContextRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLICATION_CONTEXT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_context) = param_from_chunks::<ApplicationContext<'a>>(false, s, &mut i, strs)?;
        let (s, related_context) = param_from_chunks::<ApplicationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_context,
            related_context,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApplicationContextRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_context.append_ids(_v);
        self.related_context.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApplicationProtocolDefinition_<'a> { // entity
    pub status: Label<'a>,
    pub application_interpreted_model_schema_name: Label<'a>,
    pub application_protocol_year: YearNumber<'a>,
    pub application: ApplicationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApplicationProtocolDefinition<'a> = Id<ApplicationProtocolDefinition_<'a>>;
impl<'a> FromEntity<'a> for ApplicationProtocolDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApplicationProtocolDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApplicationProtocolDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLICATION_PROTOCOL_DEFINITION(")(strs[0])?;
        let (s, status) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, application_interpreted_model_schema_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, application_protocol_year) = param_from_chunks::<YearNumber<'a>>(false, s, &mut i, strs)?;
        let (s, application) = param_from_chunks::<ApplicationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            status,
            application_interpreted_model_schema_name,
            application_protocol_year,
            application,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApplicationProtocolDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.status.append_ids(_v);
        self.application_interpreted_model_schema_name.append_ids(_v);
        self.application_protocol_year.append_ids(_v);
        self.application.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedActionAssignment_<'a> { // entity
    pub assigned_action: Action<'a>,
    pub items: Vec<ActionItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedActionAssignment<'a> = Id<AppliedActionAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedActionAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedActionAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedActionAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_ACTION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_action) = param_from_chunks::<Action<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ActionItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_action,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedActionAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_action.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedActionRequestAssignment_<'a> { // entity
    pub assigned_action_request: VersionedActionRequest<'a>,
    pub items: Vec<ActionRequestItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedActionRequestAssignment<'a> = Id<AppliedActionRequestAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedActionRequestAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedActionRequestAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedActionRequestAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_ACTION_REQUEST_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_action_request) = param_from_chunks::<VersionedActionRequest<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ActionRequestItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_action_request,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedActionRequestAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_action_request.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedApprovalAssignment_<'a> { // entity
    pub assigned_approval: Approval<'a>,
    pub items: Vec<ApprovalItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedApprovalAssignment<'a> = Id<AppliedApprovalAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedApprovalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedApprovalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedApprovalAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_APPROVAL_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_approval) = param_from_chunks::<Approval<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ApprovalItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_approval,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedApprovalAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_approval.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedArea_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedArea<'a> = Id<AppliedArea_<'a>>;
impl<'a> FromEntity<'a> for AppliedArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedArea_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_AREA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedArea_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedCertificationAssignment_<'a> { // entity
    pub assigned_certification: Certification<'a>,
    pub items: Vec<CertificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedCertificationAssignment<'a> = Id<AppliedCertificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedCertificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedCertificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedCertificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_CERTIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_certification) = param_from_chunks::<Certification<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<CertificationItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_certification,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedCertificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_certification.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<ClassificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedClassificationAssignment<'a> = Id<AppliedClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedClassificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_CLASSIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_class) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<ClassificationRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ClassificationItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_class,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedClassificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_class.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedContractAssignment_<'a> { // entity
    pub assigned_contract: Contract<'a>,
    pub items: Vec<ContractItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedContractAssignment<'a> = Id<AppliedContractAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedContractAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedContractAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedContractAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_CONTRACT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_contract) = param_from_chunks::<Contract<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ContractItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_contract,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedContractAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_contract.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedDateAndTimeAssignment_<'a> { // entity
    pub assigned_date_and_time: DateAndTime<'a>,
    pub role: DateTimeRole<'a>,
    pub items: Vec<DateAndTimeItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDateAndTimeAssignment<'a> = Id<AppliedDateAndTimeAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedDateAndTimeAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDateAndTimeAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedDateAndTimeAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_DATE_AND_TIME_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_date_and_time) = param_from_chunks::<DateAndTime<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<DateTimeRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<DateAndTimeItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_date_and_time,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedDateAndTimeAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_date_and_time.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedDateAssignment_<'a> { // entity
    pub assigned_date: Date<'a>,
    pub role: DateRole<'a>,
    pub items: Vec<DateItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDateAssignment<'a> = Id<AppliedDateAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedDateAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDateAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedDateAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_DATE_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_date) = param_from_chunks::<Date<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<DateRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<DateItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_date,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedDateAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_date.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedDocumentReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    pub items: Vec<DocumentReferenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDocumentReference<'a> = Id<AppliedDocumentReference_<'a>>;
impl<'a> FromEntity<'a> for AppliedDocumentReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDocumentReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedDocumentReference_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_DOCUMENT_REFERENCE(")(strs[0])?;
        let (s, assigned_document) = param_from_chunks::<Document<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<DocumentReferenceItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_document,
            source,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedDocumentReference_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_document.append_ids(_v);
        self.source.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedDocumentUsageConstraintAssignment_<'a> { // entity
    pub assigned_document_usage: DocumentUsageConstraint<'a>,
    pub role: DocumentUsageRole<'a>,
    pub items: Vec<DocumentReferenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedDocumentUsageConstraintAssignment<'a> = Id<AppliedDocumentUsageConstraintAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedDocumentUsageConstraintAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedDocumentUsageConstraintAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedDocumentUsageConstraintAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_document_usage) = param_from_chunks::<DocumentUsageConstraint<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<DocumentUsageRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<DocumentReferenceItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_document_usage,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedDocumentUsageConstraintAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_document_usage.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedEffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<EffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedEffectivityAssignment<'a> = Id<AppliedEffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedEffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedEffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedEffectivityAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_EFFECTIVITY_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_effectivity) = param_from_chunks::<Effectivity<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<EffectivityItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_effectivity,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedEffectivityAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_effectivity.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedEventOccurrenceAssignment_<'a> { // entity
    pub assigned_event_occurrence: EventOccurrence<'a>,
    pub role: EventOccurrenceRole<'a>,
    pub items: Vec<EventOccurrenceItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedEventOccurrenceAssignment<'a> = Id<AppliedEventOccurrenceAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedEventOccurrenceAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedEventOccurrenceAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedEventOccurrenceAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_EVENT_OCCURRENCE_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_event_occurrence) = param_from_chunks::<EventOccurrence<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<EventOccurrenceRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<EventOccurrenceItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_event_occurrence,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedEventOccurrenceAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_event_occurrence.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedExternalIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub source: ExternalSource<'a>,
    pub items: Vec<ExternalIdentificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedExternalIdentificationAssignment<'a> = Id<AppliedExternalIdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedExternalIdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedExternalIdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedExternalIdentificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<IdentificationRole<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ExternalIdentificationItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_id,
            role,
            source,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedExternalIdentificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_id.append_ids(_v);
        self.role.append_ids(_v);
        self.source.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedGroupAssignment_<'a> { // entity
    pub assigned_group: Group<'a>,
    pub items: Vec<GroupItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedGroupAssignment<'a> = Id<AppliedGroupAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedGroupAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedGroupAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedGroupAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_GROUP_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_group) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<GroupItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_group,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedGroupAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_group.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub items: Vec<IdentificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedIdentificationAssignment<'a> = Id<AppliedIdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedIdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedIdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedIdentificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_IDENTIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<IdentificationRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<IdentificationItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_id,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedIdentificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_id.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedIneffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<EffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedIneffectivityAssignment<'a> = Id<AppliedIneffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedIneffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedIneffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedIneffectivityAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_INEFFECTIVITY_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_effectivity) = param_from_chunks::<Effectivity<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<EffectivityItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_effectivity,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedIneffectivityAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_effectivity.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedNameAssignment_<'a> { // entity
    pub assigned_name: Label<'a>,
    pub items: Vec<NameItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedNameAssignment<'a> = Id<AppliedNameAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedNameAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedNameAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedNameAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_NAME_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<NameItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_name,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedNameAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_name.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedOrganizationAssignment_<'a> { // entity
    pub assigned_organization: Organization<'a>,
    pub role: OrganizationRole<'a>,
    pub items: Vec<OrganizationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedOrganizationAssignment<'a> = Id<AppliedOrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedOrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedOrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedOrganizationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_ORGANIZATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_organization) = param_from_chunks::<Organization<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<OrganizationRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<OrganizationItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_organization,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedOrganizationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_organization.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedOrganizationalProjectAssignment_<'a> { // entity
    pub assigned_organizational_project: OrganizationalProject<'a>,
    pub role: OrganizationalProjectRole<'a>,
    pub items: Vec<OrganizationalProjectItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedOrganizationalProjectAssignment<'a> = Id<AppliedOrganizationalProjectAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedOrganizationalProjectAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedOrganizationalProjectAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedOrganizationalProjectAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_organizational_project) = param_from_chunks::<OrganizationalProject<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<OrganizationalProjectRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<OrganizationalProjectItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_organizational_project,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedOrganizationalProjectAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_organizational_project.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedPersonAndOrganizationAssignment_<'a> { // entity
    pub assigned_person_and_organization: PersonAndOrganization<'a>,
    pub role: PersonAndOrganizationRole<'a>,
    pub items: Vec<PersonAndOrganizationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedPersonAndOrganizationAssignment<'a> = Id<AppliedPersonAndOrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedPersonAndOrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedPersonAndOrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedPersonAndOrganizationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_person_and_organization) = param_from_chunks::<PersonAndOrganization<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<PersonAndOrganizationRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<PersonAndOrganizationItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_person_and_organization,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedPersonAndOrganizationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_person_and_organization.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedPresentedItem_<'a> { // entity
    pub items: Vec<PresentedItemSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedPresentedItem<'a> = Id<AppliedPresentedItem_<'a>>;
impl<'a> FromEntity<'a> for AppliedPresentedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedPresentedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedPresentedItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_PRESENTED_ITEM(")(strs[0])?;
        let (s, items) = param_from_chunks::<Vec<PresentedItemSelect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedPresentedItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedSecurityClassificationAssignment_<'a> { // entity
    pub assigned_security_classification: SecurityClassification<'a>,
    pub items: Vec<SecurityClassificationItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedSecurityClassificationAssignment<'a> = Id<AppliedSecurityClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedSecurityClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedSecurityClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedSecurityClassificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_security_classification) = param_from_chunks::<SecurityClassification<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<SecurityClassificationItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_security_classification,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedSecurityClassificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_security_classification.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AppliedTimeIntervalAssignment_<'a> { // entity
    pub assigned_time_interval: TimeInterval<'a>,
    pub role: TimeIntervalRole<'a>,
    pub items: Vec<TimeIntervalItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AppliedTimeIntervalAssignment<'a> = Id<AppliedTimeIntervalAssignment_<'a>>;
impl<'a> FromEntity<'a> for AppliedTimeIntervalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AppliedTimeIntervalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AppliedTimeIntervalAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPLIED_TIME_INTERVAL_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_time_interval) = param_from_chunks::<TimeInterval<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<TimeIntervalRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<TimeIntervalItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_time_interval,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AppliedTimeIntervalAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_time_interval.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Approval_<'a> { // entity
    pub status: ApprovalStatus<'a>,
    pub level: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Approval<'a> = Id<Approval_<'a>>;
impl<'a> FromEntity<'a> for Approval_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Approval(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Approval_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROVAL(")(strs[0])?;
        let (s, status) = param_from_chunks::<ApprovalStatus<'a>>(false, s, &mut i, strs)?;
        let (s, level) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            status,
            level,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Approval_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.status.append_ids(_v);
        self.level.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApprovalAssignment_<'a> { // entity
    pub assigned_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalAssignment<'a> = Id<ApprovalAssignment_<'a>>;
impl<'a> FromEntity<'a> for ApprovalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApprovalAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROVAL_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_approval) = param_from_chunks::<Approval<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_approval,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApprovalAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_approval.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApprovalDateTime_<'a> { // entity
    pub date_time: DateTimeSelect<'a>,
    pub dated_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalDateTime<'a> = Id<ApprovalDateTime_<'a>>;
impl<'a> FromEntity<'a> for ApprovalDateTime_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalDateTime(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApprovalDateTime_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROVAL_DATE_TIME(")(strs[0])?;
        let (s, date_time) = param_from_chunks::<DateTimeSelect<'a>>(false, s, &mut i, strs)?;
        let (s, dated_approval) = param_from_chunks::<Approval<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            date_time,
            dated_approval,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApprovalDateTime_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.date_time.append_ids(_v);
        self.dated_approval.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApprovalItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ApprovalItem<'a> = Id<ApprovalItem_<'a>>;

#[derive(Debug)]
pub struct ApprovalPersonOrganization_<'a> { // entity
    pub person_organization: PersonOrganizationSelect<'a>,
    pub authorized_approval: Approval<'a>,
    pub role: ApprovalRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalPersonOrganization<'a> = Id<ApprovalPersonOrganization_<'a>>;
impl<'a> FromEntity<'a> for ApprovalPersonOrganization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalPersonOrganization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApprovalPersonOrganization_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROVAL_PERSON_ORGANIZATION(")(strs[0])?;
        let (s, person_organization) = param_from_chunks::<PersonOrganizationSelect<'a>>(false, s, &mut i, strs)?;
        let (s, authorized_approval) = param_from_chunks::<Approval<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<ApprovalRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            person_organization,
            authorized_approval,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApprovalPersonOrganization_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.person_organization.append_ids(_v);
        self.authorized_approval.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApprovalRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_approval: Approval<'a>,
    pub related_approval: Approval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalRelationship<'a> = Id<ApprovalRelationship_<'a>>;
impl<'a> FromEntity<'a> for ApprovalRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApprovalRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROVAL_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_approval) = param_from_chunks::<Approval<'a>>(false, s, &mut i, strs)?;
        let (s, related_approval) = param_from_chunks::<Approval<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_approval,
            related_approval,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApprovalRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_approval.append_ids(_v);
        self.related_approval.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApprovalRole_<'a> { // entity
    pub role: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalRole<'a> = Id<ApprovalRole_<'a>>;
impl<'a> FromEntity<'a> for ApprovalRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApprovalRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROVAL_ROLE(")(strs[0])?;
        let (s, role) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApprovalRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApprovalStatus_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApprovalStatus<'a> = Id<ApprovalStatus_<'a>>;
impl<'a> FromEntity<'a> for ApprovalStatus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApprovalStatus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApprovalStatus_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROVAL_STATUS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApprovalStatus_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum ApproximationMethod<'a> { // enum
    ChordalDeviation,
    ChordalLength,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ApproximationMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ApproximationMethod::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "CHORDAL_DEVIATION" => ChordalDeviation,
            "CHORDAL_LENGTH" => ChordalLength,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for ApproximationMethod<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct ApproximationTolerance_<'a> { // entity
    pub tolerance: ToleranceSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationTolerance<'a> = Id<ApproximationTolerance_<'a>>;
impl<'a> FromEntity<'a> for ApproximationTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApproximationTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApproximationTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROXIMATION_TOLERANCE(")(strs[0])?;
        let (s, tolerance) = param_from_chunks::<ToleranceSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            tolerance,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApproximationTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.tolerance.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApproximationToleranceDeviation_<'a> { // entity
    pub tessellation_type: ApproximationMethod<'a>,
    pub tolerances: ArrayVec::<ToleranceDeviationSelect<'a>, 2>,
    pub definition_space: ProductOrPresentationSpace<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationToleranceDeviation<'a> = Id<ApproximationToleranceDeviation_<'a>>;
impl<'a> FromEntity<'a> for ApproximationToleranceDeviation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApproximationToleranceDeviation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApproximationToleranceDeviation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROXIMATION_TOLERANCE_DEVIATION(")(strs[0])?;
        let (s, tessellation_type) = param_from_chunks::<ApproximationMethod<'a>>(false, s, &mut i, strs)?;
        let (s, tolerances) = param_from_chunks::<ArrayVec::<ToleranceDeviationSelect<'a>, 2>>(false, s, &mut i, strs)?;
        let (s, definition_space) = param_from_chunks::<ProductOrPresentationSpace<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            tessellation_type,
            tolerances,
            definition_space,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApproximationToleranceDeviation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.tessellation_type.append_ids(_v);
        self.tolerances.append_ids(_v);
        self.definition_space.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ApproximationToleranceParameter_<'a> { // entity
    pub tolerances: ArrayVec::<ToleranceParameterSelect<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ApproximationToleranceParameter<'a> = Id<ApproximationToleranceParameter_<'a>>;
impl<'a> FromEntity<'a> for ApproximationToleranceParameter_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ApproximationToleranceParameter(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ApproximationToleranceParameter_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("APPROXIMATION_TOLERANCE_PARAMETER(")(strs[0])?;
        let (s, tolerances) = param_from_chunks::<ArrayVec::<ToleranceParameterSelect<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            tolerances,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ApproximationToleranceParameter_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.tolerances.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AreaInSet_<'a> { // entity
    pub area: PresentationArea<'a>,
    pub in_set: PresentationSet<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaInSet<'a> = Id<AreaInSet_<'a>>;
impl<'a> FromEntity<'a> for AreaInSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AreaInSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AreaInSet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AREA_IN_SET(")(strs[0])?;
        let (s, area) = param_from_chunks::<PresentationArea<'a>>(false, s, &mut i, strs)?;
        let (s, in_set) = param_from_chunks::<PresentationSet<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            area,
            in_set,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AreaInSet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.area.append_ids(_v);
        self.in_set.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AreaMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for AreaMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for AreaMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct AreaMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaMeasureWithUnit<'a> = Id<AreaMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for AreaMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AreaMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AreaMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AREA_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AreaMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AreaOrView_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AreaOrView<'a> = Id<AreaOrView_<'a>>;

#[derive(Debug)]
pub struct AreaUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AreaUnit<'a> = Id<AreaUnit_<'a>>;
impl<'a> FromEntity<'a> for AreaUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AreaUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AreaUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AREA_UNIT(")(strs[0])?;
        let (s, elements) = param_from_chunks::<Vec<DerivedUnitElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AreaUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AsinFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AsinFunction<'a> = Id<AsinFunction_<'a>>;
impl<'a> FromEntity<'a> for AsinFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AsinFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AsinFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ASIN_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AsinFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AssemblyComponentUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AssemblyComponentUsage<'a> = Id<AssemblyComponentUsage_<'a>>;
impl<'a> FromEntity<'a> for AssemblyComponentUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AssemblyComponentUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AssemblyComponentUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ASSEMBLY_COMPONENT_USAGE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, reference_designator) = param_from_chunks::<Option<Identifier<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AssemblyComponentUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
        self.reference_designator.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AssemblyComponentUsageSubstitute_<'a> { // entity
    pub name: Label<'a>,
    pub definition: Option<Text<'a>>,
    pub base: AssemblyComponentUsage<'a>,
    pub substitute: AssemblyComponentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AssemblyComponentUsageSubstitute<'a> = Id<AssemblyComponentUsageSubstitute_<'a>>;
impl<'a> FromEntity<'a> for AssemblyComponentUsageSubstitute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AssemblyComponentUsageSubstitute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AssemblyComponentUsageSubstitute_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, base) = param_from_chunks::<AssemblyComponentUsage<'a>>(false, s, &mut i, strs)?;
        let (s, substitute) = param_from_chunks::<AssemblyComponentUsage<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            definition,
            base,
            substitute,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AssemblyComponentUsageSubstitute_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.definition.append_ids(_v);
        self.base.append_ids(_v);
        self.substitute.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AtanFunction_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AtanFunction<'a> = Id<AtanFunction_<'a>>;
impl<'a> FromEntity<'a> for AtanFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AtanFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AtanFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ATAN_FUNCTION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AtanFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AttributeClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub attribute_name: Label<'a>,
    pub role: ClassificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeClassificationAssignment<'a> = Id<AttributeClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for AttributeClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AttributeClassificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ATTRIBUTE_CLASSIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_class) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, attribute_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<ClassificationRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_class,
            attribute_name,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AttributeClassificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_class.append_ids(_v);
        self.attribute_name.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AttributeLanguageAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub attribute_name: Label<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<AttributeLanguageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeLanguageAssignment<'a> = Id<AttributeLanguageAssignment_<'a>>;
impl<'a> FromEntity<'a> for AttributeLanguageAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeLanguageAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AttributeLanguageAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ATTRIBUTE_LANGUAGE_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_class) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, attribute_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<ClassificationRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<AttributeLanguageItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_class,
            attribute_name,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AttributeLanguageAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_class.append_ids(_v);
        self.attribute_name.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AttributeLanguageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type AttributeLanguageItem<'a> = Id<AttributeLanguageItem_<'a>>;

#[derive(Debug)]
pub enum AttributeType<'a> { // select
    Label(Label<'a>),
    Text(Text<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for AttributeType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LABEL("), <Label<'a>>::parse, char(')')), AttributeType::Label),
            map(delimited(tag("TEXT("), <Text<'a>>::parse, char(')')), AttributeType::Text),
        ))(s)
    }
}
impl<'a> HasId for AttributeType<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            AttributeType::Label(c) => c.append_ids(_v),
            AttributeType::Text(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct AttributeValueAssignment_<'a> { // entity
    pub attribute_name: Label<'a>,
    pub attribute_value: AttributeType<'a>,
    pub role: AttributeValueRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeValueAssignment<'a> = Id<AttributeValueAssignment_<'a>>;
impl<'a> FromEntity<'a> for AttributeValueAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeValueAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AttributeValueAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ATTRIBUTE_VALUE_ASSIGNMENT(")(strs[0])?;
        let (s, attribute_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, attribute_value) = param_from_chunks::<AttributeType<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<AttributeValueRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            attribute_name,
            attribute_value,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AttributeValueAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.attribute_name.append_ids(_v);
        self.attribute_value.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct AttributeValueRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type AttributeValueRole<'a> = Id<AttributeValueRole_<'a>>;
impl<'a> FromEntity<'a> for AttributeValueRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::AttributeValueRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for AttributeValueRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ATTRIBUTE_VALUE_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for AttributeValueRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Axis1Placement_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub axis: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis1Placement<'a> = Id<Axis1Placement_<'a>>;
impl<'a> FromEntity<'a> for Axis1Placement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Axis1Placement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Axis1Placement_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AXIS1_PLACEMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, location) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, axis) = param_from_chunks::<Option<Direction<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            location,
            axis,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Axis1Placement_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.location.append_ids(_v);
        self.axis.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Axis2Placement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Axis2Placement<'a> = Id<Axis2Placement_<'a>>;

#[derive(Debug)]
pub struct Axis2Placement2d_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub ref_direction: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis2Placement2d<'a> = Id<Axis2Placement2d_<'a>>;
impl<'a> FromEntity<'a> for Axis2Placement2d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Axis2Placement2d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Axis2Placement2d_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AXIS2_PLACEMENT_2D(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, location) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, ref_direction) = param_from_chunks::<Option<Direction<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            location,
            ref_direction,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Axis2Placement2d_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.location.append_ids(_v);
        self.ref_direction.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Axis2Placement3d_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    pub axis: Option<Direction<'a>>,
    pub ref_direction: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Axis2Placement3d<'a> = Id<Axis2Placement3d_<'a>>;
impl<'a> FromEntity<'a> for Axis2Placement3d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Axis2Placement3d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Axis2Placement3d_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("AXIS2_PLACEMENT_3D(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, location) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, axis) = param_from_chunks::<Option<Direction<'a>>>(false, s, &mut i, strs)?;
        let (s, ref_direction) = param_from_chunks::<Option<Direction<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            location,
            axis,
            ref_direction,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Axis2Placement3d_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.location.append_ids(_v);
        self.axis.append_ids(_v);
        self.ref_direction.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BSplineCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineCurve<'a> = Id<BSplineCurve_<'a>>;
impl<'a> FromEntity<'a> for BSplineCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BSplineCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("B_SPLINE_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<CartesianPoint<'a>>>(false, s, &mut i, strs)?;
        let (s, curve_form) = param_from_chunks::<BSplineCurveForm<'a>>(false, s, &mut i, strs)?;
        let (s, closed_curve) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BSplineCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.curve_form.append_ids(_v);
        self.closed_curve.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum BSplineCurveForm<'a> { // enum
    PolylineForm,
    CircularArc,
    EllipticArc,
    ParabolicArc,
    HyperbolicArc,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineCurveForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineCurveForm::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "POLYLINE_FORM" => PolylineForm,
            "CIRCULAR_ARC" => CircularArc,
            "ELLIPTIC_ARC" => EllipticArc,
            "PARABOLIC_ARC" => ParabolicArc,
            "HYPERBOLIC_ARC" => HyperbolicArc,
            "UNSPECIFIED" => Unspecified,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for BSplineCurveForm<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct BSplineCurveWithKnots_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    pub knot_multiplicities: Vec<i64>,
    pub knots: Vec<ParameterValue<'a>>,
    pub knot_spec: KnotType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineCurveWithKnots<'a> = Id<BSplineCurveWithKnots_<'a>>;
impl<'a> FromEntity<'a> for BSplineCurveWithKnots_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineCurveWithKnots(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BSplineCurveWithKnots_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("B_SPLINE_CURVE_WITH_KNOTS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<CartesianPoint<'a>>>(false, s, &mut i, strs)?;
        let (s, curve_form) = param_from_chunks::<BSplineCurveForm<'a>>(false, s, &mut i, strs)?;
        let (s, closed_curve) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, knot_multiplicities) = param_from_chunks::<Vec<i64>>(false, s, &mut i, strs)?;
        let (s, knots) = param_from_chunks::<Vec<ParameterValue<'a>>>(false, s, &mut i, strs)?;
        let (s, knot_spec) = param_from_chunks::<KnotType<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            knot_multiplicities,
            knots,
            knot_spec,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BSplineCurveWithKnots_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.curve_form.append_ids(_v);
        self.closed_curve.append_ids(_v);
        self.self_intersect.append_ids(_v);
        self.knot_multiplicities.append_ids(_v);
        self.knots.append_ids(_v);
        self.knot_spec.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BSplineSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineSurface<'a> = Id<BSplineSurface_<'a>>;
impl<'a> FromEntity<'a> for BSplineSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BSplineSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("B_SPLINE_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, u_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, v_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<Vec<CartesianPoint<'a>>>>(false, s, &mut i, strs)?;
        let (s, surface_form) = param_from_chunks::<BSplineSurfaceForm<'a>>(false, s, &mut i, strs)?;
        let (s, u_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, v_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BSplineSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.u_degree.append_ids(_v);
        self.v_degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.surface_form.append_ids(_v);
        self.u_closed.append_ids(_v);
        self.v_closed.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum BSplineSurfaceForm<'a> { // enum
    PlaneSurf,
    CylindricalSurf,
    ConicalSurf,
    SphericalSurf,
    ToroidalSurf,
    SurfOfRevolution,
    RuledSurf,
    GeneralisedCone,
    QuadricSurf,
    SurfOfLinearExtrusion,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BSplineSurfaceForm<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BSplineSurfaceForm::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "PLANE_SURF" => PlaneSurf,
            "CYLINDRICAL_SURF" => CylindricalSurf,
            "CONICAL_SURF" => ConicalSurf,
            "SPHERICAL_SURF" => SphericalSurf,
            "TOROIDAL_SURF" => ToroidalSurf,
            "SURF_OF_REVOLUTION" => SurfOfRevolution,
            "RULED_SURF" => RuledSurf,
            "GENERALISED_CONE" => GeneralisedCone,
            "QUADRIC_SURF" => QuadricSurf,
            "SURF_OF_LINEAR_EXTRUSION" => SurfOfLinearExtrusion,
            "UNSPECIFIED" => Unspecified,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for BSplineSurfaceForm<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct BSplineSurfaceWithKnots_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    pub u_multiplicities: Vec<i64>,
    pub v_multiplicities: Vec<i64>,
    pub u_knots: Vec<ParameterValue<'a>>,
    pub v_knots: Vec<ParameterValue<'a>>,
    pub knot_spec: KnotType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BSplineSurfaceWithKnots<'a> = Id<BSplineSurfaceWithKnots_<'a>>;
impl<'a> FromEntity<'a> for BSplineSurfaceWithKnots_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BSplineSurfaceWithKnots(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BSplineSurfaceWithKnots_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("B_SPLINE_SURFACE_WITH_KNOTS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, u_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, v_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<Vec<CartesianPoint<'a>>>>(false, s, &mut i, strs)?;
        let (s, surface_form) = param_from_chunks::<BSplineSurfaceForm<'a>>(false, s, &mut i, strs)?;
        let (s, u_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, v_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, u_multiplicities) = param_from_chunks::<Vec<i64>>(false, s, &mut i, strs)?;
        let (s, v_multiplicities) = param_from_chunks::<Vec<i64>>(false, s, &mut i, strs)?;
        let (s, u_knots) = param_from_chunks::<Vec<ParameterValue<'a>>>(false, s, &mut i, strs)?;
        let (s, v_knots) = param_from_chunks::<Vec<ParameterValue<'a>>>(false, s, &mut i, strs)?;
        let (s, knot_spec) = param_from_chunks::<KnotType<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            u_multiplicities,
            v_multiplicities,
            u_knots,
            v_knots,
            knot_spec,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BSplineSurfaceWithKnots_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.u_degree.append_ids(_v);
        self.v_degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.surface_form.append_ids(_v);
        self.u_closed.append_ids(_v);
        self.v_closed.append_ids(_v);
        self.self_intersect.append_ids(_v);
        self.u_multiplicities.append_ids(_v);
        self.v_multiplicities.append_ids(_v);
        self.u_knots.append_ids(_v);
        self.v_knots.append_ids(_v);
        self.knot_spec.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BackgroundColour_<'a> { // entity
    pub presentation: AreaOrView<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BackgroundColour<'a> = Id<BackgroundColour_<'a>>;
impl<'a> FromEntity<'a> for BackgroundColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BackgroundColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BackgroundColour_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BACKGROUND_COLOUR(")(strs[0])?;
        let (s, presentation) = param_from_chunks::<AreaOrView<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            presentation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BackgroundColour_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.presentation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BarringHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BarringHole<'a> = Id<BarringHole_<'a>>;
impl<'a> FromEntity<'a> for BarringHole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BarringHole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BarringHole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BARRING_HOLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BarringHole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Bead_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Bead<'a> = Id<Bead_<'a>>;
impl<'a> FromEntity<'a> for Bead_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Bead(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Bead_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BEAD(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Bead_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BeadEnd_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BeadEnd<'a> = Id<BeadEnd_<'a>>;
impl<'a> FromEntity<'a> for BeadEnd_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BeadEnd(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BeadEnd_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BEAD_END(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BeadEnd_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BezierCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BezierCurve<'a> = Id<BezierCurve_<'a>>;
impl<'a> FromEntity<'a> for BezierCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BezierCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BezierCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BEZIER_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<CartesianPoint<'a>>>(false, s, &mut i, strs)?;
        let (s, curve_form) = param_from_chunks::<BSplineCurveForm<'a>>(false, s, &mut i, strs)?;
        let (s, closed_curve) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BezierCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.curve_form.append_ids(_v);
        self.closed_curve.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BezierSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BezierSurface<'a> = Id<BezierSurface_<'a>>;
impl<'a> FromEntity<'a> for BezierSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BezierSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BezierSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BEZIER_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, u_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, v_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<Vec<CartesianPoint<'a>>>>(false, s, &mut i, strs)?;
        let (s, surface_form) = param_from_chunks::<BSplineSurfaceForm<'a>>(false, s, &mut i, strs)?;
        let (s, u_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, v_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BezierSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.u_degree.append_ids(_v);
        self.v_degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.surface_form.append_ids(_v);
        self.u_closed.append_ids(_v);
        self.v_closed.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BinaryBooleanExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryBooleanExpression<'a> = Id<BinaryBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for BinaryBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BinaryBooleanExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BINARY_BOOLEAN_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BinaryBooleanExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BinaryFunctionCall_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryFunctionCall<'a> = Id<BinaryFunctionCall_<'a>>;
impl<'a> FromEntity<'a> for BinaryFunctionCall_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryFunctionCall(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BinaryFunctionCall_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BINARY_FUNCTION_CALL(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BinaryFunctionCall_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BinaryGenericExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryGenericExpression<'a> = Id<BinaryGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for BinaryGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BinaryGenericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BINARY_GENERIC_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BinaryGenericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BinaryNumericExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BinaryNumericExpression<'a> = Id<BinaryNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for BinaryNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BinaryNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BinaryNumericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BINARY_NUMERIC_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BinaryNumericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Block_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub x: PositiveLengthMeasure<'a>,
    pub y: PositiveLengthMeasure<'a>,
    pub z: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Block<'a> = Id<Block_<'a>>;
impl<'a> FromEntity<'a> for Block_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Block(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Block_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BLOCK(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, x) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, y) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, z) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            x,
            y,
            z,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Block_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.x.append_ids(_v);
        self.y.append_ids(_v);
        self.z.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BooleanDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanDefinedFunction<'a> = Id<BooleanDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for BooleanDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BooleanDefinedFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_DEFINED_FUNCTION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BooleanDefinedFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct BooleanExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanExpression<'a> = Id<BooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for BooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BooleanExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BooleanExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct BooleanLiteral_<'a> { // entity
    pub the_value: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanLiteral<'a> = Id<BooleanLiteral_<'a>>;
impl<'a> FromEntity<'a> for BooleanLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BooleanLiteral_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOOLEAN_LITERAL(")(strs[0])?;
        let (s, the_value) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BooleanLiteral_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.the_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BooleanOperand_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type BooleanOperand<'a> = Id<BooleanOperand_<'a>>;

#[derive(Debug)]
pub enum BooleanOperator<'a> { // enum
    Union,
    Intersection,
    Difference,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for BooleanOperator<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use BooleanOperator::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "UNION" => Union,
            "INTERSECTION" => Intersection,
            "DIFFERENCE" => Difference,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for BooleanOperator<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct BooleanResult_<'a> { // entity
    pub name: Label<'a>,
    pub operator: BooleanOperator<'a>,
    pub first_operand: BooleanOperand<'a>,
    pub second_operand: BooleanOperand<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanResult<'a> = Id<BooleanResult_<'a>>;
impl<'a> FromEntity<'a> for BooleanResult_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanResult(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BooleanResult_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOOLEAN_RESULT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, operator) = param_from_chunks::<BooleanOperator<'a>>(false, s, &mut i, strs)?;
        let (s, first_operand) = param_from_chunks::<BooleanOperand<'a>>(false, s, &mut i, strs)?;
        let (s, second_operand) = param_from_chunks::<BooleanOperand<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            operator,
            first_operand,
            second_operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BooleanResult_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.operator.append_ids(_v);
        self.first_operand.append_ids(_v);
        self.second_operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BooleanVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BooleanVariable<'a> = Id<BooleanVariable_<'a>>;
impl<'a> FromEntity<'a> for BooleanVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BooleanVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BooleanVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("BOOLEAN_VARIABLE(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BooleanVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct Boss_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Boss<'a> = Id<Boss_<'a>>;
impl<'a> FromEntity<'a> for Boss_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Boss(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Boss_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOSS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Boss_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BossTop_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BossTop<'a> = Id<BossTop_<'a>>;
impl<'a> FromEntity<'a> for BossTop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BossTop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BossTop_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOSS_TOP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BossTop_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BoundaryCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundaryCurve<'a> = Id<BoundaryCurve_<'a>>;
impl<'a> FromEntity<'a> for BoundaryCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundaryCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BoundaryCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOUNDARY_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, segments) = param_from_chunks::<Vec<CompositeCurveSegment<'a>>>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BoundaryCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.segments.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BoundedCurve_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedCurve<'a> = Id<BoundedCurve_<'a>>;
impl<'a> FromEntity<'a> for BoundedCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BoundedCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOUNDED_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BoundedCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct BoundedPcurve_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedPcurve<'a> = Id<BoundedPcurve_<'a>>;
impl<'a> FromEntity<'a> for BoundedPcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedPcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BoundedPcurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOUNDED_PCURVE(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, reference_to_curve) = param_from_chunks::<DefinitionalRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            basis_surface,
            reference_to_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BoundedPcurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.reference_to_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BoundedSurface_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedSurface<'a> = Id<BoundedSurface_<'a>>;
impl<'a> FromEntity<'a> for BoundedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BoundedSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOUNDED_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BoundedSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct BoundedSurfaceCurve_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: ArrayVec::<PcurveOrSurface<'a>, 2>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoundedSurfaceCurve<'a> = Id<BoundedSurfaceCurve_<'a>>;
impl<'a> FromEntity<'a> for BoundedSurfaceCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoundedSurfaceCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BoundedSurfaceCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOUNDED_SURFACE_CURVE(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, curve_3d) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, associated_geometry) = param_from_chunks::<ArrayVec::<PcurveOrSurface<'a>, 2>>(false, s, &mut i, strs)?;
        let (s, master_representation) = param_from_chunks::<PreferredSurfaceCurveRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BoundedSurfaceCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.curve_3d.append_ids(_v);
        self.associated_geometry.append_ids(_v);
        self.master_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum BoxCharacteristicSelect<'a> { // select
    BoxHeight(BoxHeight<'a>),
    BoxWidth(BoxWidth<'a>),
    BoxSlantAngle(BoxSlantAngle<'a>),
    BoxRotateAngle(BoxRotateAngle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for BoxCharacteristicSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("BOX_HEIGHT("), <BoxHeight<'a>>::parse, char(')')), BoxCharacteristicSelect::BoxHeight),
            map(delimited(tag("BOX_WIDTH("), <BoxWidth<'a>>::parse, char(')')), BoxCharacteristicSelect::BoxWidth),
            map(delimited(tag("BOX_SLANT_ANGLE("), <BoxSlantAngle<'a>>::parse, char(')')), BoxCharacteristicSelect::BoxSlantAngle),
            map(delimited(tag("BOX_ROTATE_ANGLE("), <BoxRotateAngle<'a>>::parse, char(')')), BoxCharacteristicSelect::BoxRotateAngle),
        ))(s)
    }
}
impl<'a> HasId for BoxCharacteristicSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            BoxCharacteristicSelect::BoxHeight(c) => c.append_ids(_v),
            BoxCharacteristicSelect::BoxWidth(c) => c.append_ids(_v),
            BoxCharacteristicSelect::BoxSlantAngle(c) => c.append_ids(_v),
            BoxCharacteristicSelect::BoxRotateAngle(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct BoxDomain_<'a> { // entity
    pub corner: CartesianPoint<'a>,
    pub xlength: PositiveLengthMeasure<'a>,
    pub ylength: PositiveLengthMeasure<'a>,
    pub zlength: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoxDomain<'a> = Id<BoxDomain_<'a>>;
impl<'a> FromEntity<'a> for BoxDomain_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoxDomain(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BoxDomain_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOX_DOMAIN(")(strs[0])?;
        let (s, corner) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, xlength) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, ylength) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, zlength) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            corner,
            xlength,
            ylength,
            zlength,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BoxDomain_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.corner.append_ids(_v);
        self.xlength.append_ids(_v);
        self.ylength.append_ids(_v);
        self.zlength.append_ids(_v);
    }
}

#[derive(Debug)]
pub struct BoxHeight<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxHeight<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for BoxHeight<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}


#[derive(Debug)]
pub struct BoxRotateAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxRotateAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for BoxRotateAngle<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}


#[derive(Debug)]
pub struct BoxSlantAngle<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxSlantAngle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for BoxSlantAngle<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}


#[derive(Debug)]
pub struct BoxWidth<'a>(pub PositiveRatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for BoxWidth<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveRatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for BoxWidth<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}

#[derive(Debug)]
pub struct BoxedHalfSpace_<'a> { // entity
    pub name: Label<'a>,
    pub base_surface: Surface<'a>,
    pub agreement_flag: bool,
    pub enclosure: BoxDomain<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BoxedHalfSpace<'a> = Id<BoxedHalfSpace_<'a>>;
impl<'a> FromEntity<'a> for BoxedHalfSpace_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BoxedHalfSpace(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BoxedHalfSpace_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BOXED_HALF_SPACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, base_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, agreement_flag) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, enclosure) = param_from_chunks::<BoxDomain<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            base_surface,
            agreement_flag,
            enclosure,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BoxedHalfSpace_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.base_surface.append_ids(_v);
        self.agreement_flag.append_ids(_v);
        self.enclosure.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct BrepWithVoids_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    pub voids: Vec<OrientedClosedShell<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type BrepWithVoids<'a> = Id<BrepWithVoids_<'a>>;
impl<'a> FromEntity<'a> for BrepWithVoids_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::BrepWithVoids(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for BrepWithVoids_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("BREP_WITH_VOIDS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, outer) = param_from_chunks::<ClosedShell<'a>>(false, s, &mut i, strs)?;
        let (s, voids) = param_from_chunks::<Vec<OrientedClosedShell<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            outer,
            voids,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for BrepWithVoids_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.outer.append_ids(_v);
        self.voids.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CalendarDate_<'a> { // entity
    pub year_component: YearNumber<'a>,
    pub day_component: DayInMonthNumber<'a>,
    pub month_component: MonthInYearNumber<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CalendarDate<'a> = Id<CalendarDate_<'a>>;
impl<'a> FromEntity<'a> for CalendarDate_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CalendarDate(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CalendarDate_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CALENDAR_DATE(")(strs[0])?;
        let (s, year_component) = param_from_chunks::<YearNumber<'a>>(false, s, &mut i, strs)?;
        let (s, day_component) = param_from_chunks::<DayInMonthNumber<'a>>(false, s, &mut i, strs)?;
        let (s, month_component) = param_from_chunks::<MonthInYearNumber<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            year_component,
            day_component,
            month_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CalendarDate_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.year_component.append_ids(_v);
        self.day_component.append_ids(_v);
        self.month_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraImage_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage<'a> = Id<CameraImage_<'a>>;
impl<'a> FromEntity<'a> for CameraImage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraImage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraImage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_IMAGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraImage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraImage2dWithScale_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage2dWithScale<'a> = Id<CameraImage2dWithScale_<'a>>;
impl<'a> FromEntity<'a> for CameraImage2dWithScale_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraImage2dWithScale(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraImage2dWithScale_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_IMAGE_2D_WITH_SCALE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraImage2dWithScale_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraImage3dWithScale_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraImage3dWithScale<'a> = Id<CameraImage3dWithScale_<'a>>;
impl<'a> FromEntity<'a> for CameraImage3dWithScale_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraImage3dWithScale(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraImage3dWithScale_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_IMAGE_3D_WITH_SCALE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraImage3dWithScale_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraModel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModel<'a> = Id<CameraModel_<'a>>;
impl<'a> FromEntity<'a> for CameraModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraModel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_MODEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraModel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraModelD2_<'a> { // entity
    pub name: Label<'a>,
    pub view_window: PlanarBox<'a>,
    pub view_window_clipping: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD2<'a> = Id<CameraModelD2_<'a>>;
impl<'a> FromEntity<'a> for CameraModelD2_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModelD2(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraModelD2_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_MODEL_D2(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, view_window) = param_from_chunks::<PlanarBox<'a>>(false, s, &mut i, strs)?;
        let (s, view_window_clipping) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            view_window,
            view_window_clipping,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraModelD2_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.view_window.append_ids(_v);
        self.view_window_clipping.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraModelD3_<'a> { // entity
    pub name: Label<'a>,
    pub view_reference_system: Axis2Placement3d<'a>,
    pub perspective_of_volume: ViewVolume<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD3<'a> = Id<CameraModelD3_<'a>>;
impl<'a> FromEntity<'a> for CameraModelD3_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModelD3(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraModelD3_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_MODEL_D3(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, view_reference_system) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, perspective_of_volume) = param_from_chunks::<ViewVolume<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            view_reference_system,
            perspective_of_volume,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraModelD3_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.view_reference_system.append_ids(_v);
        self.perspective_of_volume.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraModelD3WithHlhsr_<'a> { // entity
    pub name: Label<'a>,
    pub view_reference_system: Axis2Placement3d<'a>,
    pub perspective_of_volume: ViewVolume<'a>,
    pub hidden_line_surface_removal: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraModelD3WithHlhsr<'a> = Id<CameraModelD3WithHlhsr_<'a>>;
impl<'a> FromEntity<'a> for CameraModelD3WithHlhsr_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraModelD3WithHlhsr(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraModelD3WithHlhsr_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_MODEL_D3_WITH_HLHSR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, view_reference_system) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, perspective_of_volume) = param_from_chunks::<ViewVolume<'a>>(false, s, &mut i, strs)?;
        let (s, hidden_line_surface_removal) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            view_reference_system,
            perspective_of_volume,
            hidden_line_surface_removal,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraModelD3WithHlhsr_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.view_reference_system.append_ids(_v);
        self.perspective_of_volume.append_ids(_v);
        self.hidden_line_surface_removal.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CameraUsage_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CameraUsage<'a> = Id<CameraUsage_<'a>>;
impl<'a> FromEntity<'a> for CameraUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CameraUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CameraUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CAMERA_USAGE(")(strs[0])?;
        let (s, mapping_origin) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, mapped_representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            mapping_origin,
            mapped_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CameraUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.mapping_origin.append_ids(_v);
        self.mapped_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CartesianPoint_<'a> { // entity
    pub name: Label<'a>,
    pub coordinates: ArrayVec::<LengthMeasure<'a>, 3>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianPoint<'a> = Id<CartesianPoint_<'a>>;
impl<'a> FromEntity<'a> for CartesianPoint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianPoint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CartesianPoint_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CARTESIAN_POINT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, coordinates) = param_from_chunks::<ArrayVec::<LengthMeasure<'a>, 3>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            coordinates,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CartesianPoint_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.coordinates.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CartesianTransformationOperator_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator<'a> = Id<CartesianTransformationOperator_<'a>>;
impl<'a> FromEntity<'a> for CartesianTransformationOperator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianTransformationOperator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CartesianTransformationOperator_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CARTESIAN_TRANSFORMATION_OPERATOR(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, axis1) = param_from_chunks::<Option<Direction<'a>>>(false, s, &mut i, strs)?;
        let (s, axis2) = param_from_chunks::<Option<Direction<'a>>>(false, s, &mut i, strs)?;
        let (s, local_origin) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, scale) = param_from_chunks::<Option<f64>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            axis1,
            axis2,
            local_origin,
            scale,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CartesianTransformationOperator_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.functionally_defined_transformation__name.append_ids(_v);
        self.description.append_ids(_v);
        self.axis1.append_ids(_v);
        self.axis2.append_ids(_v);
        self.local_origin.append_ids(_v);
        self.scale.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CartesianTransformationOperator2d_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator2d<'a> = Id<CartesianTransformationOperator2d_<'a>>;
impl<'a> FromEntity<'a> for CartesianTransformationOperator2d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianTransformationOperator2d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CartesianTransformationOperator2d_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CARTESIAN_TRANSFORMATION_OPERATOR_2D(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, axis1) = param_from_chunks::<Option<Direction<'a>>>(false, s, &mut i, strs)?;
        let (s, axis2) = param_from_chunks::<Option<Direction<'a>>>(false, s, &mut i, strs)?;
        let (s, local_origin) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, scale) = param_from_chunks::<Option<f64>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            axis1,
            axis2,
            local_origin,
            scale,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CartesianTransformationOperator2d_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.functionally_defined_transformation__name.append_ids(_v);
        self.description.append_ids(_v);
        self.axis1.append_ids(_v);
        self.axis2.append_ids(_v);
        self.local_origin.append_ids(_v);
        self.scale.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CartesianTransformationOperator3d_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub axis1: Option<Direction<'a>>,
    pub axis2: Option<Direction<'a>>,
    pub local_origin: CartesianPoint<'a>,
    pub scale: Option<f64>,
    pub axis3: Option<Direction<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CartesianTransformationOperator3d<'a> = Id<CartesianTransformationOperator3d_<'a>>;
impl<'a> FromEntity<'a> for CartesianTransformationOperator3d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CartesianTransformationOperator3d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CartesianTransformationOperator3d_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CARTESIAN_TRANSFORMATION_OPERATOR_3D(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, axis1) = param_from_chunks::<Option<Direction<'a>>>(false, s, &mut i, strs)?;
        let (s, axis2) = param_from_chunks::<Option<Direction<'a>>>(false, s, &mut i, strs)?;
        let (s, local_origin) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, scale) = param_from_chunks::<Option<f64>>(false, s, &mut i, strs)?;
        let (s, axis3) = param_from_chunks::<Option<Direction<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            axis1,
            axis2,
            local_origin,
            scale,
            axis3,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CartesianTransformationOperator3d_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.functionally_defined_transformation__name.append_ids(_v);
        self.description.append_ids(_v);
        self.axis1.append_ids(_v);
        self.axis2.append_ids(_v);
        self.local_origin.append_ids(_v);
        self.scale.append_ids(_v);
        self.axis3.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CategoryUsageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CategoryUsageItem<'a> = Id<CategoryUsageItem_<'a>>;

#[derive(Debug)]
pub struct CelsiusTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CelsiusTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for CelsiusTemperatureMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct CelsiusTemperatureMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CelsiusTemperatureMeasureWithUnit<'a> = Id<CelsiusTemperatureMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for CelsiusTemperatureMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CelsiusTemperatureMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CelsiusTemperatureMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CelsiusTemperatureMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum CentralOrParallel<'a> { // enum
    Central,
    Parallel,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for CentralOrParallel<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use CentralOrParallel::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "CENTRAL" => Central,
            "PARALLEL" => Parallel,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for CentralOrParallel<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct CentreOfSymmetry_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CentreOfSymmetry<'a> = Id<CentreOfSymmetry_<'a>>;
impl<'a> FromEntity<'a> for CentreOfSymmetry_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CentreOfSymmetry(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CentreOfSymmetry_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CENTRE_OF_SYMMETRY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CentreOfSymmetry_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Certification_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub kind: CertificationType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Certification<'a> = Id<Certification_<'a>>;
impl<'a> FromEntity<'a> for Certification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Certification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Certification_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CERTIFICATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<CertificationType<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            purpose,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Certification_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.purpose.append_ids(_v);
        self.kind.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CertificationAssignment_<'a> { // entity
    pub assigned_certification: Certification<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CertificationAssignment<'a> = Id<CertificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for CertificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CertificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CertificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CERTIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_certification) = param_from_chunks::<Certification<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_certification,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CertificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_certification.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CertificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CertificationItem<'a> = Id<CertificationItem_<'a>>;

#[derive(Debug)]
pub struct CertificationType_<'a> { // entity
    pub description: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CertificationType<'a> = Id<CertificationType_<'a>>;
impl<'a> FromEntity<'a> for CertificationType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CertificationType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CertificationType_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CERTIFICATION_TYPE(")(strs[0])?;
        let (s, description) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CertificationType_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Chamfer_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Chamfer<'a> = Id<Chamfer_<'a>>;
impl<'a> FromEntity<'a> for Chamfer_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Chamfer(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Chamfer_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CHAMFER(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Chamfer_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ChamferOffset_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ChamferOffset<'a> = Id<ChamferOffset_<'a>>;
impl<'a> FromEntity<'a> for ChamferOffset_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ChamferOffset(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ChamferOffset_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CHAMFER_OFFSET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ChamferOffset_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CharacterGlyphSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub character_box: PlanarExtent<'a>,
    pub baseline_ratio: RatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterGlyphSymbol<'a> = Id<CharacterGlyphSymbol_<'a>>;
impl<'a> FromEntity<'a> for CharacterGlyphSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CharacterGlyphSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CharacterGlyphSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CHARACTER_GLYPH_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(false, s, &mut i, strs)?;
        let (s, character_box) = param_from_chunks::<PlanarExtent<'a>>(false, s, &mut i, strs)?;
        let (s, baseline_ratio) = param_from_chunks::<RatioMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            character_box,
            baseline_ratio,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CharacterGlyphSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
        self.character_box.append_ids(_v);
        self.baseline_ratio.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum CharacterSpacingSelect<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CharacterSpacingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), CharacterSpacingSelect::LengthMeasure),
            map(delimited(tag("RATIO_MEASURE("), <RatioMeasure<'a>>::parse, char(')')), CharacterSpacingSelect::RatioMeasure),
            map(<MeasureWithUnit<'a>>::parse, CharacterSpacingSelect::MeasureWithUnit),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), CharacterSpacingSelect::DescriptiveMeasure),
        ))(s)
    }
}
impl<'a> HasId for CharacterSpacingSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            CharacterSpacingSelect::LengthMeasure(c) => c.append_ids(_v),
            CharacterSpacingSelect::RatioMeasure(c) => c.append_ids(_v),
            CharacterSpacingSelect::MeasureWithUnit(c) => c.append_ids(_v),
            CharacterSpacingSelect::DescriptiveMeasure(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct CharacterStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterStyleSelect<'a> = Id<CharacterStyleSelect_<'a>>;

#[derive(Debug)]
pub struct CharacterizedActionDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedActionDefinition<'a> = Id<CharacterizedActionDefinition_<'a>>;

#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CharacterizedClass_<'a> { // entity
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    pub group__name: Label<'a>,
    pub group__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterizedClass<'a> = Id<CharacterizedClass_<'a>>;
impl<'a> FromEntity<'a> for CharacterizedClass_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CharacterizedClass(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CharacterizedClass_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CHARACTERIZED_CLASS(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, group__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, group__description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            characterized_object__name,
            characterized_object__description,
            group__name,
            group__description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CharacterizedClass_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.characterized_object__name.append_ids(_v);
        self.characterized_object__description.append_ids(_v);
        self.group__name.append_ids(_v);
        self.group__description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CharacterizedDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedDefinition<'a> = Id<CharacterizedDefinition_<'a>>;

#[derive(Debug)]
pub struct CharacterizedMaterialProperty_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedMaterialProperty<'a> = Id<CharacterizedMaterialProperty_<'a>>;

#[derive(Debug)]
pub struct CharacterizedObject_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CharacterizedObject<'a> = Id<CharacterizedObject_<'a>>;
impl<'a> FromEntity<'a> for CharacterizedObject_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CharacterizedObject(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CharacterizedObject_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CHARACTERIZED_OBJECT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CharacterizedObject_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CharacterizedProductDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedProductDefinition<'a> = Id<CharacterizedProductDefinition_<'a>>;

#[derive(Debug)]
pub struct CharacterizedResourceDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CharacterizedResourceDefinition<'a> = Id<CharacterizedResourceDefinition_<'a>>;

#[derive(Debug)]
pub struct Circle_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Circle<'a> = Id<Circle_<'a>>;
impl<'a> FromEntity<'a> for Circle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Circle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Circle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CIRCLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Circle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.radius.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CircularClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularClosedProfile<'a> = Id<CircularClosedProfile_<'a>>;
impl<'a> FromEntity<'a> for CircularClosedProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CircularClosedProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CircularClosedProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CIRCULAR_CLOSED_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CircularClosedProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CircularPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularPattern<'a> = Id<CircularPattern_<'a>>;
impl<'a> FromEntity<'a> for CircularPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CircularPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CircularPattern_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CIRCULAR_PATTERN(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CircularPattern_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CircularRunoutTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CircularRunoutTolerance<'a> = Id<CircularRunoutTolerance_<'a>>;
impl<'a> FromEntity<'a> for CircularRunoutTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CircularRunoutTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CircularRunoutTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CIRCULAR_RUNOUT_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CircularRunoutTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Class_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Class<'a> = Id<Class_<'a>>;
impl<'a> FromEntity<'a> for Class_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Class(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Class_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CLASS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Class_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ClassSystem_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassSystem<'a> = Id<ClassSystem_<'a>>;
impl<'a> FromEntity<'a> for ClassSystem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassSystem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ClassSystem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CLASS_SYSTEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ClassSystem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ClassUsageEffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    pub items: Vec<ClassUsageEffectivityContextItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassUsageEffectivityContextAssignment<'a> = Id<ClassUsageEffectivityContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for ClassUsageEffectivityContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassUsageEffectivityContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ClassUsageEffectivityContextAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_effectivity_assignment) = param_from_chunks::<EffectivityAssignment<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<EffectivityContextRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ClassUsageEffectivityContextItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_effectivity_assignment,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ClassUsageEffectivityContextAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_effectivity_assignment.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ClassUsageEffectivityContextItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ClassUsageEffectivityContextItem<'a> = Id<ClassUsageEffectivityContextItem_<'a>>;

#[derive(Debug)]
pub struct ClassificationAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassificationAssignment<'a> = Id<ClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for ClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ClassificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CLASSIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_class) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<ClassificationRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_class,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ClassificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_class.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ClassificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ClassificationItem<'a> = Id<ClassificationItem_<'a>>;

#[derive(Debug)]
pub struct ClassificationRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClassificationRole<'a> = Id<ClassificationRole_<'a>>;
impl<'a> FromEntity<'a> for ClassificationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClassificationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ClassificationRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CLASSIFICATION_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ClassificationRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ClosedPathProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClosedPathProfile<'a> = Id<ClosedPathProfile_<'a>>;
impl<'a> FromEntity<'a> for ClosedPathProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClosedPathProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ClosedPathProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CLOSED_PATH_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ClosedPathProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ClosedShell_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ClosedShell<'a> = Id<ClosedShell_<'a>>;
impl<'a> FromEntity<'a> for ClosedShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ClosedShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ClosedShell_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CLOSED_SHELL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, cfs_faces) = param_from_chunks::<Vec<Face<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            cfs_faces,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ClosedShell_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.cfs_faces.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CoaxialityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CoaxialityTolerance<'a> = Id<CoaxialityTolerance_<'a>>;
impl<'a> FromEntity<'a> for CoaxialityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CoaxialityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CoaxialityTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COAXIALITY_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CoaxialityTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Colour_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Colour<'a> = Id<Colour_<'a>>;
impl<'a> FromEntity<'a> for Colour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Colour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Colour_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("COLOUR(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Colour_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct ColourRgb_<'a> { // entity
    pub name: Label<'a>,
    pub red: f64,
    pub green: f64,
    pub blue: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ColourRgb<'a> = Id<ColourRgb_<'a>>;
impl<'a> FromEntity<'a> for ColourRgb_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ColourRgb(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ColourRgb_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COLOUR_RGB(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, red) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, green) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, blue) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            red,
            green,
            blue,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ColourRgb_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.red.append_ids(_v);
        self.green.append_ids(_v);
        self.blue.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ColourSpecification_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ColourSpecification<'a> = Id<ColourSpecification_<'a>>;
impl<'a> FromEntity<'a> for ColourSpecification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ColourSpecification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ColourSpecification_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COLOUR_SPECIFICATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ColourSpecification_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct CommonDatum_<'a> { // entity
    pub shape_aspect__name: Label<'a>,
    pub shape_aspect__description: Option<Text<'a>>,
    pub shape_aspect__of_shape: ProductDefinitionShape<'a>,
    pub shape_aspect__product_definitional: Logical,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CommonDatum<'a> = Id<CommonDatum_<'a>>;
impl<'a> FromEntity<'a> for CommonDatum_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CommonDatum(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CommonDatum_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMMON_DATUM(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__product_definitional) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, identification) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            shape_aspect__name,
            shape_aspect__description,
            shape_aspect__of_shape,
            shape_aspect__product_definitional,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CommonDatum_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.shape_aspect__name.append_ids(_v);
        self.shape_aspect__description.append_ids(_v);
        self.shape_aspect__of_shape.append_ids(_v);
        self.shape_aspect__product_definitional.append_ids(_v);
        self.identification.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ComparisonEqual_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonEqual<'a> = Id<ComparisonEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ComparisonEqual_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPARISON_EQUAL(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ComparisonEqual_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ComparisonExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonExpression<'a> = Id<ComparisonExpression_<'a>>;
impl<'a> FromEntity<'a> for ComparisonExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ComparisonExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPARISON_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ComparisonExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ComparisonGreater_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonGreater<'a> = Id<ComparisonGreater_<'a>>;
impl<'a> FromEntity<'a> for ComparisonGreater_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonGreater(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ComparisonGreater_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPARISON_GREATER(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ComparisonGreater_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ComparisonGreaterEqual_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonGreaterEqual<'a> = Id<ComparisonGreaterEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonGreaterEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonGreaterEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ComparisonGreaterEqual_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPARISON_GREATER_EQUAL(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ComparisonGreaterEqual_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ComparisonLess_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonLess<'a> = Id<ComparisonLess_<'a>>;
impl<'a> FromEntity<'a> for ComparisonLess_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonLess(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ComparisonLess_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPARISON_LESS(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ComparisonLess_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ComparisonLessEqual_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonLessEqual<'a> = Id<ComparisonLessEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonLessEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonLessEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ComparisonLessEqual_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPARISON_LESS_EQUAL(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ComparisonLessEqual_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ComparisonNotEqual_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ComparisonNotEqual<'a> = Id<ComparisonNotEqual_<'a>>;
impl<'a> FromEntity<'a> for ComparisonNotEqual_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ComparisonNotEqual(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ComparisonNotEqual_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPARISON_NOT_EQUAL(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ComparisonNotEqual_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurve<'a> = Id<CompositeCurve_<'a>>;
impl<'a> FromEntity<'a> for CompositeCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, segments) = param_from_chunks::<Vec<CompositeCurveSegment<'a>>>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.segments.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeCurveOnSurface_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurveOnSurface<'a> = Id<CompositeCurveOnSurface_<'a>>;
impl<'a> FromEntity<'a> for CompositeCurveOnSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeCurveOnSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeCurveOnSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_CURVE_ON_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, segments) = param_from_chunks::<Vec<CompositeCurveSegment<'a>>>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeCurveOnSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.segments.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeCurveSegment_<'a> { // entity
    pub transition: TransitionCode<'a>,
    pub same_sense: bool,
    pub parent_curve: Curve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeCurveSegment<'a> = Id<CompositeCurveSegment_<'a>>;
impl<'a> FromEntity<'a> for CompositeCurveSegment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeCurveSegment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeCurveSegment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_CURVE_SEGMENT(")(strs[0])?;
        let (s, transition) = param_from_chunks::<TransitionCode<'a>>(false, s, &mut i, strs)?;
        let (s, same_sense) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, parent_curve) = param_from_chunks::<Curve<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            transition,
            same_sense,
            parent_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeCurveSegment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.transition.append_ids(_v);
        self.same_sense.append_ids(_v);
        self.parent_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeHole<'a> = Id<CompositeHole_<'a>>;
impl<'a> FromEntity<'a> for CompositeHole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeHole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeHole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_HOLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeHole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeShapeAspect<'a> = Id<CompositeShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for CompositeShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeShapeAspect_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_SHAPE_ASPECT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeShapeAspect_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeText_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeText<'a> = Id<CompositeText_<'a>>;
impl<'a> FromEntity<'a> for CompositeText_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeText(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeText_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_TEXT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, collected_text) = param_from_chunks::<Vec<TextOrCharacter<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            collected_text,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeText_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.collected_text.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeTextWithAssociatedCurves_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub associated_curves: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithAssociatedCurves<'a> = Id<CompositeTextWithAssociatedCurves_<'a>>;
impl<'a> FromEntity<'a> for CompositeTextWithAssociatedCurves_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeTextWithAssociatedCurves(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeTextWithAssociatedCurves_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, collected_text) = param_from_chunks::<Vec<TextOrCharacter<'a>>>(false, s, &mut i, strs)?;
        let (s, associated_curves) = param_from_chunks::<Vec<Curve<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            collected_text,
            associated_curves,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeTextWithAssociatedCurves_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.collected_text.append_ids(_v);
        self.associated_curves.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeTextWithBlankingBox_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub blanking: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithBlankingBox<'a> = Id<CompositeTextWithBlankingBox_<'a>>;
impl<'a> FromEntity<'a> for CompositeTextWithBlankingBox_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeTextWithBlankingBox(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeTextWithBlankingBox_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_TEXT_WITH_BLANKING_BOX(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, collected_text) = param_from_chunks::<Vec<TextOrCharacter<'a>>>(false, s, &mut i, strs)?;
        let (s, blanking) = param_from_chunks::<PlanarBox<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            collected_text,
            blanking,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeTextWithBlankingBox_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.collected_text.append_ids(_v);
        self.blanking.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompositeTextWithExtent_<'a> { // entity
    pub name: Label<'a>,
    pub collected_text: Vec<TextOrCharacter<'a>>,
    pub extent: PlanarExtent<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompositeTextWithExtent<'a> = Id<CompositeTextWithExtent_<'a>>;
impl<'a> FromEntity<'a> for CompositeTextWithExtent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompositeTextWithExtent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompositeTextWithExtent_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOSITE_TEXT_WITH_EXTENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, collected_text) = param_from_chunks::<Vec<TextOrCharacter<'a>>>(false, s, &mut i, strs)?;
        let (s, extent) = param_from_chunks::<PlanarExtent<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            collected_text,
            extent,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompositeTextWithExtent_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.collected_text.append_ids(_v);
        self.extent.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompoundFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundFeature<'a> = Id<CompoundFeature_<'a>>;
impl<'a> FromEntity<'a> for CompoundFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompoundFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompoundFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOUND_FEATURE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompoundFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum CompoundItemDefinition<'a> { // select
    ListRepresentationItem(Vec<RepresentationItem<'a>>),
    SetRepresentationItem(Vec<RepresentationItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for CompoundItemDefinition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LIST_REPRESENTATION_ITEM("), <Vec<RepresentationItem<'a>>>::parse, char(')')), CompoundItemDefinition::ListRepresentationItem),
            map(delimited(tag("SET_REPRESENTATION_ITEM("), <Vec<RepresentationItem<'a>>>::parse, char(')')), CompoundItemDefinition::SetRepresentationItem),
        ))(s)
    }
}
impl<'a> HasId for CompoundItemDefinition<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            CompoundItemDefinition::ListRepresentationItem(c) => c.append_ids(_v),
            CompoundItemDefinition::SetRepresentationItem(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct CompoundRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundRepresentationItem<'a> = Id<CompoundRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for CompoundRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompoundRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompoundRepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOUND_REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, item_element) = param_from_chunks::<CompoundItemDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            item_element,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompoundRepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.item_element.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CompoundShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CompoundShapeRepresentation<'a> = Id<CompoundShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for CompoundShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CompoundShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CompoundShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COMPOUND_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CompoundShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConcatExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConcatExpression<'a> = Id<ConcatExpression_<'a>>;
impl<'a> FromEntity<'a> for ConcatExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConcatExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConcatExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONCAT_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConcatExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConcentricityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConcentricityTolerance<'a> = Id<ConcentricityTolerance_<'a>>;
impl<'a> FromEntity<'a> for ConcentricityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConcentricityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConcentricityTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONCENTRICITY_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConcentricityTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConceptFeatureOperator_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureOperator<'a> = Id<ConceptFeatureOperator_<'a>>;
impl<'a> FromEntity<'a> for ConceptFeatureOperator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConceptFeatureOperator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConceptFeatureOperator_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONCEPT_FEATURE_OPERATOR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConceptFeatureOperator_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConceptFeatureRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept_feature: ProductConceptFeature<'a>,
    pub related_product_concept_feature: ProductConceptFeature<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureRelationship<'a> = Id<ConceptFeatureRelationship_<'a>>;
impl<'a> FromEntity<'a> for ConceptFeatureRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConceptFeatureRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConceptFeatureRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONCEPT_FEATURE_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_concept_feature) = param_from_chunks::<ProductConceptFeature<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_concept_feature) = param_from_chunks::<ProductConceptFeature<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_product_concept_feature,
            related_product_concept_feature,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConceptFeatureRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_concept_feature.append_ids(_v);
        self.related_product_concept_feature.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConceptFeatureRelationshipWithCondition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept_feature: ProductConceptFeature<'a>,
    pub related_product_concept_feature: ProductConceptFeature<'a>,
    pub conditional_operator: ConceptFeatureOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConceptFeatureRelationshipWithCondition<'a> = Id<ConceptFeatureRelationshipWithCondition_<'a>>;
impl<'a> FromEntity<'a> for ConceptFeatureRelationshipWithCondition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConceptFeatureRelationshipWithCondition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConceptFeatureRelationshipWithCondition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_concept_feature) = param_from_chunks::<ProductConceptFeature<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_concept_feature) = param_from_chunks::<ProductConceptFeature<'a>>(false, s, &mut i, strs)?;
        let (s, conditional_operator) = param_from_chunks::<ConceptFeatureOperator<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_product_concept_feature,
            related_product_concept_feature,
            conditional_operator,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConceptFeatureRelationshipWithCondition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_concept_feature.append_ids(_v);
        self.related_product_concept_feature.append_ids(_v);
        self.conditional_operator.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConditionalConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub condition: ConceptFeatureRelationshipWithCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConditionalConceptFeature<'a> = Id<ConditionalConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for ConditionalConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConditionalConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConditionalConceptFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONDITIONAL_CONCEPT_FEATURE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, condition) = param_from_chunks::<ConceptFeatureRelationshipWithCondition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            condition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConditionalConceptFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.condition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfigurableItem_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurableItem<'a> = Id<ConfigurableItem_<'a>>;
impl<'a> FromEntity<'a> for ConfigurableItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurableItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfigurableItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURABLE_ITEM(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, item_concept) = param_from_chunks::<ProductConcept<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, item_concept_feature) = param_from_chunks::<Vec<ProductConceptFeatureAssociation<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            item_concept,
            purpose,
            item_concept_feature,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfigurableItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.item_concept.append_ids(_v);
        self.purpose.append_ids(_v);
        self.item_concept_feature.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfigurationDefinition_<'a> { // entity
    pub pair_values: Vec<PairValue<'a>>,
    pub t_parameter: MotionParameterMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationDefinition<'a> = Id<ConfigurationDefinition_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfigurationDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURATION_DEFINITION(")(strs[0])?;
        let (s, pair_values) = param_from_chunks::<Vec<PairValue<'a>>>(false, s, &mut i, strs)?;
        let (s, t_parameter) = param_from_chunks::<MotionParameterMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            pair_values,
            t_parameter,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfigurationDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.pair_values.append_ids(_v);
        self.t_parameter.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfigurationDesign_<'a> { // entity
    pub configuration: ConfigurationItem<'a>,
    pub design: ConfigurationDesignItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationDesign<'a> = Id<ConfigurationDesign_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationDesign_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationDesign(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfigurationDesign_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURATION_DESIGN(")(strs[0])?;
        let (s, configuration) = param_from_chunks::<ConfigurationItem<'a>>(false, s, &mut i, strs)?;
        let (s, design) = param_from_chunks::<ConfigurationDesignItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            configuration,
            design,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfigurationDesign_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.configuration.append_ids(_v);
        self.design.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfigurationDesignItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfigurationDesignItem<'a> = Id<ConfigurationDesignItem_<'a>>;

#[derive(Debug)]
pub struct ConfigurationEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub usage: ProductDefinitionRelationship<'a>,
    pub configuration: ConfigurationDesign<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationEffectivity<'a> = Id<ConfigurationEffectivity_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfigurationEffectivity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURATION_EFFECTIVITY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, usage) = param_from_chunks::<ProductDefinitionRelationship<'a>>(false, s, &mut i, strs)?;
        let (s, configuration) = param_from_chunks::<ConfigurationDesign<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            usage,
            configuration,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfigurationEffectivity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.usage.append_ids(_v);
        self.configuration.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfigurationInterpolation_<'a> { // entity
    pub previous_configuration_definition: ConfigurationDefinition<'a>,
    pub next_configuration_definition: ConfigurationDefinition<'a>,
    pub interpolation: InterpolationType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationInterpolation<'a> = Id<ConfigurationInterpolation_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationInterpolation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationInterpolation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfigurationInterpolation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURATION_INTERPOLATION(")(strs[0])?;
        let (s, previous_configuration_definition) = param_from_chunks::<ConfigurationDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, next_configuration_definition) = param_from_chunks::<ConfigurationDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, interpolation) = param_from_chunks::<InterpolationType<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            previous_configuration_definition,
            next_configuration_definition,
            interpolation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfigurationInterpolation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.previous_configuration_definition.append_ids(_v);
        self.next_configuration_definition.append_ids(_v);
        self.interpolation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfigurationItem_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfigurationItem<'a> = Id<ConfigurationItem_<'a>>;
impl<'a> FromEntity<'a> for ConfigurationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfigurationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfigurationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURATION_ITEM(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, item_concept) = param_from_chunks::<ProductConcept<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Option<Label<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            item_concept,
            purpose,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfigurationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.item_concept.append_ids(_v);
        self.purpose.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfiguredEffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    pub items: Vec<ConfiguredEffectivityItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfiguredEffectivityAssignment<'a> = Id<ConfiguredEffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for ConfiguredEffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfiguredEffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfiguredEffectivityAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURED_EFFECTIVITY_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_effectivity) = param_from_chunks::<Effectivity<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ConfiguredEffectivityItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_effectivity,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfiguredEffectivityAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_effectivity.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfiguredEffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    pub items: Vec<ConfiguredEffectivityContextItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConfiguredEffectivityContextAssignment<'a> = Id<ConfiguredEffectivityContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for ConfiguredEffectivityContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConfiguredEffectivityContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConfiguredEffectivityContextAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_effectivity_assignment) = param_from_chunks::<EffectivityAssignment<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<EffectivityContextRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<ConfiguredEffectivityContextItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_effectivity_assignment,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConfiguredEffectivityContextAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_effectivity_assignment.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConfiguredEffectivityContextItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfiguredEffectivityContextItem<'a> = Id<ConfiguredEffectivityContextItem_<'a>>;

#[derive(Debug)]
pub struct ConfiguredEffectivityItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ConfiguredEffectivityItem<'a> = Id<ConfiguredEffectivityItem_<'a>>;

#[derive(Debug)]
pub struct Conic_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Conic<'a> = Id<Conic_<'a>>;
impl<'a> FromEntity<'a> for Conic_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Conic(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Conic_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONIC(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Conic_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConicalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: LengthMeasure<'a>,
    pub semi_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConicalSurface<'a> = Id<ConicalSurface_<'a>>;
impl<'a> FromEntity<'a> for ConicalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConicalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConicalSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONICAL_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, semi_angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            radius,
            semi_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConicalSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.radius.append_ids(_v);
        self.semi_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConnectedEdgeSet_<'a> { // entity
    pub name: Label<'a>,
    pub ces_edges: Vec<Edge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedEdgeSet<'a> = Id<ConnectedEdgeSet_<'a>>;
impl<'a> FromEntity<'a> for ConnectedEdgeSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConnectedEdgeSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConnectedEdgeSet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONNECTED_EDGE_SET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, ces_edges) = param_from_chunks::<Vec<Edge<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            ces_edges,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConnectedEdgeSet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.ces_edges.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConnectedFaceSet_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedFaceSet<'a> = Id<ConnectedFaceSet_<'a>>;
impl<'a> FromEntity<'a> for ConnectedFaceSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConnectedFaceSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConnectedFaceSet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONNECTED_FACE_SET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, cfs_faces) = param_from_chunks::<Vec<Face<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            cfs_faces,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConnectedFaceSet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.cfs_faces.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConnectedFaceSubSet_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    pub parent_face_set: ConnectedFaceSet<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConnectedFaceSubSet<'a> = Id<ConnectedFaceSubSet_<'a>>;
impl<'a> FromEntity<'a> for ConnectedFaceSubSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConnectedFaceSubSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConnectedFaceSubSet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONNECTED_FACE_SUB_SET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, cfs_faces) = param_from_chunks::<Vec<Face<'a>>>(false, s, &mut i, strs)?;
        let (s, parent_face_set) = param_from_chunks::<ConnectedFaceSet<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            cfs_faces,
            parent_face_set,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConnectedFaceSubSet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.cfs_faces.append_ids(_v);
        self.parent_face_set.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConstructiveGeometryRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConstructiveGeometryRepresentation<'a> = Id<ConstructiveGeometryRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ConstructiveGeometryRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConstructiveGeometryRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConstructiveGeometryRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONSTRUCTIVE_GEOMETRY_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConstructiveGeometryRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConstructiveGeometryRepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConstructiveGeometryRepresentationRelationship<'a> = Id<ConstructiveGeometryRepresentationRelationship_<'a>>;
impl<'a> FromEntity<'a> for ConstructiveGeometryRepresentationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConstructiveGeometryRepresentationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConstructiveGeometryRepresentationRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConstructiveGeometryRepresentationRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ContactRatioRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContactRatioRepresentation<'a> = Id<ContactRatioRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ContactRatioRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContactRatioRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ContactRatioRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTACT_RATIO_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ContactRatioRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ContextDependentInvisibility_<'a> { // entity
    pub invisible_items: Vec<InvisibleItem<'a>>,
    pub presentation_context: InvisibilityContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentInvisibility<'a> = Id<ContextDependentInvisibility_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentInvisibility_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentInvisibility(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ContextDependentInvisibility_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTEXT_DEPENDENT_INVISIBILITY(")(strs[0])?;
        let (s, invisible_items) = param_from_chunks::<Vec<InvisibleItem<'a>>>(false, s, &mut i, strs)?;
        let (s, presentation_context) = param_from_chunks::<InvisibilityContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            invisible_items,
            presentation_context,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ContextDependentInvisibility_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.invisible_items.append_ids(_v);
        self.presentation_context.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ContextDependentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ContextDependentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for ContextDependentMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct ContextDependentOverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    pub style_context: Vec<StyleContextSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentOverRidingStyledItem<'a> = Id<ContextDependentOverRidingStyledItem_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentOverRidingStyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentOverRidingStyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ContextDependentOverRidingStyledItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, over_ridden_style) = param_from_chunks::<StyledItem<'a>>(false, s, &mut i, strs)?;
        let (s, style_context) = param_from_chunks::<Vec<StyleContextSelect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            over_ridden_style,
            style_context,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ContextDependentOverRidingStyledItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.over_ridden_style.append_ids(_v);
        self.style_context.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ContextDependentShapeRepresentation_<'a> { // entity
    pub representation_relation: ShapeRepresentationRelationship<'a>,
    pub represented_product_relation: ProductDefinitionShape<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentShapeRepresentation<'a> = Id<ContextDependentShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ContextDependentShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTEXT_DEPENDENT_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, representation_relation) = param_from_chunks::<ShapeRepresentationRelationship<'a>>(false, s, &mut i, strs)?;
        let (s, represented_product_relation) = param_from_chunks::<ProductDefinitionShape<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_relation,
            represented_product_relation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ContextDependentShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_relation.append_ids(_v);
        self.represented_product_relation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ContextDependentUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContextDependentUnit<'a> = Id<ContextDependentUnit_<'a>>;
impl<'a> FromEntity<'a> for ContextDependentUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContextDependentUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ContextDependentUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTEXT_DEPENDENT_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ContextDependentUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Contract_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub kind: ContractType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Contract<'a> = Id<Contract_<'a>>;
impl<'a> FromEntity<'a> for Contract_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Contract(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Contract_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTRACT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<ContractType<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            purpose,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Contract_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.purpose.append_ids(_v);
        self.kind.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ContractAssignment_<'a> { // entity
    pub assigned_contract: Contract<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContractAssignment<'a> = Id<ContractAssignment_<'a>>;
impl<'a> FromEntity<'a> for ContractAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContractAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ContractAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTRACT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_contract) = param_from_chunks::<Contract<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_contract,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ContractAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_contract.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ContractItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ContractItem<'a> = Id<ContractItem_<'a>>;

#[derive(Debug)]
pub struct ContractType_<'a> { // entity
    pub description: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ContractType<'a> = Id<ContractType_<'a>>;
impl<'a> FromEntity<'a> for ContractType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ContractType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ContractType_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONTRACT_TYPE(")(strs[0])?;
        let (s, description) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ContractType_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ConversionBasedUnit_<'a> { // entity
    pub name: Label<'a>,
    pub conversion_factor: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ConversionBasedUnit<'a> = Id<ConversionBasedUnit_<'a>>;
impl<'a> FromEntity<'a> for ConversionBasedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ConversionBasedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ConversionBasedUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CONVERSION_BASED_UNIT(")(strs[0])?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, conversion_factor) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            conversion_factor,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ConversionBasedUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.conversion_factor.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CoordinatedUniversalTimeOffset_<'a> { // entity
    pub hour_offset: i64,
    pub minute_offset: Option<i64>,
    pub sense: AheadOrBehind<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CoordinatedUniversalTimeOffset<'a> = Id<CoordinatedUniversalTimeOffset_<'a>>;
impl<'a> FromEntity<'a> for CoordinatedUniversalTimeOffset_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CoordinatedUniversalTimeOffset(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CoordinatedUniversalTimeOffset_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COORDINATED_UNIVERSAL_TIME_OFFSET(")(strs[0])?;
        let (s, hour_offset) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, minute_offset) = param_from_chunks::<Option<i64>>(false, s, &mut i, strs)?;
        let (s, sense) = param_from_chunks::<AheadOrBehind<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            hour_offset,
            minute_offset,
            sense,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CoordinatedUniversalTimeOffset_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.hour_offset.append_ids(_v);
        self.minute_offset.append_ids(_v);
        self.sense.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CosFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CosFunction<'a> = Id<CosFunction_<'a>>;
impl<'a> FromEntity<'a> for CosFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CosFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CosFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("COS_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CosFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CountMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CountMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for CountMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct CsgPrimitive_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CsgPrimitive<'a> = Id<CsgPrimitive_<'a>>;

#[derive(Debug)]
pub struct CsgSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CsgSelect<'a> = Id<CsgSelect_<'a>>;

#[derive(Debug)]
pub struct CsgShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CsgShapeRepresentation<'a> = Id<CsgShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for CsgShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CsgShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CsgShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CSG_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CsgShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CsgSolid_<'a> { // entity
    pub name: Label<'a>,
    pub tree_root_expression: CsgSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CsgSolid<'a> = Id<CsgSolid_<'a>>;
impl<'a> FromEntity<'a> for CsgSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CsgSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CsgSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CSG_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, tree_root_expression) = param_from_chunks::<CsgSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            tree_root_expression,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CsgSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.tree_root_expression.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Curve_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Curve<'a> = Id<Curve_<'a>>;
impl<'a> FromEntity<'a> for Curve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Curve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Curve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Curve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveBoundedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub boundaries: Vec<BoundaryCurve<'a>>,
    pub implicit_outer: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveBoundedSurface<'a> = Id<CurveBoundedSurface_<'a>>;
impl<'a> FromEntity<'a> for CurveBoundedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveBoundedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveBoundedSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_BOUNDED_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, boundaries) = param_from_chunks::<Vec<BoundaryCurve<'a>>>(false, s, &mut i, strs)?;
        let (s, implicit_outer) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_surface,
            boundaries,
            implicit_outer,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveBoundedSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.boundaries.append_ids(_v);
        self.implicit_outer.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveDimension<'a> = Id<CurveDimension_<'a>>;
impl<'a> FromEntity<'a> for CurveDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveDimension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_DIMENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveDimension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveFontOrScaledCurveFontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveFontOrScaledCurveFontSelect<'a> = Id<CurveFontOrScaledCurveFontSelect_<'a>>;

#[derive(Debug)]
pub struct CurveOnSurface_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveOnSurface<'a> = Id<CurveOnSurface_<'a>>;

#[derive(Debug)]
pub struct CurveOrRender_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveOrRender<'a> = Id<CurveOrRender_<'a>>;

#[derive(Debug)]
pub struct CurveReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_curve: Curve<'a>,
    pub transformation: CartesianTransformationOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveReplica<'a> = Id<CurveReplica_<'a>>;
impl<'a> FromEntity<'a> for CurveReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveReplica_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_REPLICA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, parent_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, transformation) = param_from_chunks::<CartesianTransformationOperator<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            parent_curve,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveReplica_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.parent_curve.append_ids(_v);
        self.transformation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveStyle_<'a> { // entity
    pub name: Label<'a>,
    pub curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    pub curve_width: SizeSelect<'a>,
    pub curve_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyle<'a> = Id<CurveStyle_<'a>>;
impl<'a> FromEntity<'a> for CurveStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, curve_font) = param_from_chunks::<CurveFontOrScaledCurveFontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, curve_width) = param_from_chunks::<SizeSelect<'a>>(false, s, &mut i, strs)?;
        let (s, curve_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            curve_font,
            curve_width,
            curve_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.curve_font.append_ids(_v);
        self.curve_width.append_ids(_v);
        self.curve_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveStyleFont_<'a> { // entity
    pub name: Label<'a>,
    pub pattern_list: Vec<CurveStyleFontPattern<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleFont<'a> = Id<CurveStyleFont_<'a>>;
impl<'a> FromEntity<'a> for CurveStyleFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyleFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveStyleFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_STYLE_FONT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, pattern_list) = param_from_chunks::<Vec<CurveStyleFontPattern<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            pattern_list,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveStyleFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.pattern_list.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveStyleFontPattern_<'a> { // entity
    pub visible_segment_length: PositiveLengthMeasure<'a>,
    pub invisible_segment_length: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleFontPattern<'a> = Id<CurveStyleFontPattern_<'a>>;
impl<'a> FromEntity<'a> for CurveStyleFontPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyleFontPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveStyleFontPattern_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_STYLE_FONT_PATTERN(")(strs[0])?;
        let (s, visible_segment_length) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, invisible_segment_length) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            visible_segment_length,
            invisible_segment_length,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveStyleFontPattern_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.visible_segment_length.append_ids(_v);
        self.invisible_segment_length.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveStyleFontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type CurveStyleFontSelect<'a> = Id<CurveStyleFontSelect_<'a>>;

#[derive(Debug)]
pub struct CurveStyleRendering_<'a> { // entity
    pub rendering_method: ShadingCurveMethod<'a>,
    pub rendering_properties: SurfaceRenderingProperties<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveStyleRendering<'a> = Id<CurveStyleRendering_<'a>>;
impl<'a> FromEntity<'a> for CurveStyleRendering_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveStyleRendering(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveStyleRendering_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_STYLE_RENDERING(")(strs[0])?;
        let (s, rendering_method) = param_from_chunks::<ShadingCurveMethod<'a>>(false, s, &mut i, strs)?;
        let (s, rendering_properties) = param_from_chunks::<SurfaceRenderingProperties<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            rendering_method,
            rendering_properties,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveStyleRendering_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.rendering_method.append_ids(_v);
        self.rendering_properties.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CurveSweptSolidShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CurveSweptSolidShapeRepresentation<'a> = Id<CurveSweptSolidShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for CurveSweptSolidShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CurveSweptSolidShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CurveSweptSolidShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CurveSweptSolidShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}

#[derive(Debug)]
pub struct CurveToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for CurveToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for CurveToleranceDeviation<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}

#[derive(Debug)]
pub struct CurveToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for CurveToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for CurveToleranceParameter<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct CylindricalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPair<'a> = Id<CylindricalPair_<'a>>;
impl<'a> FromEntity<'a> for CylindricalPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CylindricalPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CYLINDRICAL_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CylindricalPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CylindricalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPairRange<'a> = Id<CylindricalPairRange_<'a>>;
impl<'a> FromEntity<'a> for CylindricalPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CylindricalPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CYLINDRICAL_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_translation) = param_from_chunks::<TranslationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_translation) = param_from_chunks::<TranslationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_translation,
            upper_limit_actual_translation,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CylindricalPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_actual_translation.append_ids(_v);
        self.upper_limit_actual_translation.append_ids(_v);
        self.lower_limit_actual_rotation.append_ids(_v);
        self.upper_limit_actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CylindricalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_translation: LengthMeasure<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalPairValue<'a> = Id<CylindricalPairValue_<'a>>;
impl<'a> FromEntity<'a> for CylindricalPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CylindricalPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CYLINDRICAL_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_translation) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, actual_rotation) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_translation,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CylindricalPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_translation.append_ids(_v);
        self.actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CylindricalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricalSurface<'a> = Id<CylindricalSurface_<'a>>;
impl<'a> FromEntity<'a> for CylindricalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CylindricalSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CYLINDRICAL_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CylindricalSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.radius.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct CylindricityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type CylindricityTolerance<'a> = Id<CylindricityTolerance_<'a>>;
impl<'a> FromEntity<'a> for CylindricityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::CylindricityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for CylindricityTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("CYLINDRICITY_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for CylindricityTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DataEnvironment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub elements: Vec<PropertyDefinitionRepresentation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DataEnvironment<'a> = Id<DataEnvironment_<'a>>;
impl<'a> FromEntity<'a> for DataEnvironment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DataEnvironment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DataEnvironment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATA_ENVIRONMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, elements) = param_from_chunks::<Vec<PropertyDefinitionRepresentation<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DataEnvironment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Date_<'a> { // entity
    pub year_component: YearNumber<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Date<'a> = Id<Date_<'a>>;
impl<'a> FromEntity<'a> for Date_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Date(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Date_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATE(")(strs[0])?;
        let (s, year_component) = param_from_chunks::<YearNumber<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            year_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Date_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.year_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DateAndTime_<'a> { // entity
    pub date_component: Date<'a>,
    pub time_component: LocalTime<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAndTime<'a> = Id<DateAndTime_<'a>>;
impl<'a> FromEntity<'a> for DateAndTime_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateAndTime(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DateAndTime_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATE_AND_TIME(")(strs[0])?;
        let (s, date_component) = param_from_chunks::<Date<'a>>(false, s, &mut i, strs)?;
        let (s, time_component) = param_from_chunks::<LocalTime<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            date_component,
            time_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DateAndTime_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.date_component.append_ids(_v);
        self.time_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DateAndTimeAssignment_<'a> { // entity
    pub assigned_date_and_time: DateAndTime<'a>,
    pub role: DateTimeRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAndTimeAssignment<'a> = Id<DateAndTimeAssignment_<'a>>;
impl<'a> FromEntity<'a> for DateAndTimeAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateAndTimeAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DateAndTimeAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATE_AND_TIME_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_date_and_time) = param_from_chunks::<DateAndTime<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<DateTimeRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_date_and_time,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DateAndTimeAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_date_and_time.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DateAndTimeItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateAndTimeItem<'a> = Id<DateAndTimeItem_<'a>>;

#[derive(Debug)]
pub struct DateAssignment_<'a> { // entity
    pub assigned_date: Date<'a>,
    pub role: DateRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateAssignment<'a> = Id<DateAssignment_<'a>>;
impl<'a> FromEntity<'a> for DateAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DateAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATE_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_date) = param_from_chunks::<Date<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<DateRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_date,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DateAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_date.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DateItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateItem<'a> = Id<DateItem_<'a>>;

#[derive(Debug)]
pub struct DateRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateRole<'a> = Id<DateRole_<'a>>;
impl<'a> FromEntity<'a> for DateRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DateRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATE_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DateRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DateTimeOrEventOccurrence_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateTimeOrEventOccurrence<'a> = Id<DateTimeOrEventOccurrence_<'a>>;

#[derive(Debug)]
pub struct DateTimeRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DateTimeRole<'a> = Id<DateTimeRole_<'a>>;
impl<'a> FromEntity<'a> for DateTimeRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DateTimeRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DateTimeRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATE_TIME_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DateTimeRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DateTimeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DateTimeSelect<'a> = Id<DateTimeSelect_<'a>>;

#[derive(Debug)]
pub struct DatedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_end_date: Option<DateTimeOrEventOccurrence<'a>>,
    pub effectivity_start_date: DateTimeOrEventOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatedEffectivity<'a> = Id<DatedEffectivity_<'a>>;
impl<'a> FromEntity<'a> for DatedEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatedEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DatedEffectivity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATED_EFFECTIVITY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, effectivity_end_date) = param_from_chunks::<Option<DateTimeOrEventOccurrence<'a>>>(false, s, &mut i, strs)?;
        let (s, effectivity_start_date) = param_from_chunks::<DateTimeOrEventOccurrence<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            effectivity_end_date,
            effectivity_start_date,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DatedEffectivity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.effectivity_end_date.append_ids(_v);
        self.effectivity_start_date.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Datum_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Datum<'a> = Id<Datum_<'a>>;
impl<'a> FromEntity<'a> for Datum_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Datum(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Datum_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATUM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, identification) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Datum_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
        self.identification.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DatumFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumFeature<'a> = Id<DatumFeature_<'a>>;
impl<'a> FromEntity<'a> for DatumFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DatumFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATUM_FEATURE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DatumFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DatumFeatureCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumFeatureCallout<'a> = Id<DatumFeatureCallout_<'a>>;
impl<'a> FromEntity<'a> for DatumFeatureCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumFeatureCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DatumFeatureCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATUM_FEATURE_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DatumFeatureCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DatumReference_<'a> { // entity
    pub precedence: i64,
    pub referenced_datum: Datum<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumReference<'a> = Id<DatumReference_<'a>>;
impl<'a> FromEntity<'a> for DatumReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DatumReference_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATUM_REFERENCE(")(strs[0])?;
        let (s, precedence) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, referenced_datum) = param_from_chunks::<Datum<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            precedence,
            referenced_datum,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DatumReference_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.precedence.append_ids(_v);
        self.referenced_datum.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DatumTarget_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub target_id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumTarget<'a> = Id<DatumTarget_<'a>>;
impl<'a> FromEntity<'a> for DatumTarget_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumTarget(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DatumTarget_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATUM_TARGET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, target_id) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            target_id,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DatumTarget_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
        self.target_id.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DatumTargetCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DatumTargetCallout<'a> = Id<DatumTargetCallout_<'a>>;
impl<'a> FromEntity<'a> for DatumTargetCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DatumTargetCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DatumTargetCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DATUM_TARGET_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DatumTargetCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DayInMonthNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DayInMonthNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for DayInMonthNumber<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct DefaultToleranceTable_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefaultToleranceTable<'a> = Id<DefaultToleranceTable_<'a>>;
impl<'a> FromEntity<'a> for DefaultToleranceTable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefaultToleranceTable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DefaultToleranceTable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DEFAULT_TOLERANCE_TABLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DefaultToleranceTable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DefaultToleranceTableCell_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefaultToleranceTableCell<'a> = Id<DefaultToleranceTableCell_<'a>>;
impl<'a> FromEntity<'a> for DefaultToleranceTableCell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefaultToleranceTableCell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DefaultToleranceTableCell_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DEFAULT_TOLERANCE_TABLE_CELL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, item_element) = param_from_chunks::<CompoundItemDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            item_element,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DefaultToleranceTableCell_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.item_element.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DefinedCharacterGlyph_<'a> { // entity
    pub name: Label<'a>,
    pub definition: DefinedGlyphSelect<'a>,
    pub placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedCharacterGlyph<'a> = Id<DefinedCharacterGlyph_<'a>>;
impl<'a> FromEntity<'a> for DefinedCharacterGlyph_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinedCharacterGlyph(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DefinedCharacterGlyph_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DEFINED_CHARACTER_GLYPH(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<DefinedGlyphSelect<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            definition,
            placement,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DefinedCharacterGlyph_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.definition.append_ids(_v);
        self.placement.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedFunction<'a> = Id<DefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for DefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DefinedFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("DEFINED_FUNCTION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DefinedFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct DefinedGlyphSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DefinedGlyphSelect<'a> = Id<DefinedGlyphSelect_<'a>>;

#[derive(Debug)]
pub struct DefinedSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub definition: DefinedSymbolSelect<'a>,
    pub target: SymbolTarget<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinedSymbol<'a> = Id<DefinedSymbol_<'a>>;
impl<'a> FromEntity<'a> for DefinedSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinedSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DefinedSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DEFINED_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<DefinedSymbolSelect<'a>>(false, s, &mut i, strs)?;
        let (s, target) = param_from_chunks::<SymbolTarget<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            definition,
            target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DefinedSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.definition.append_ids(_v);
        self.target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DefinedSymbolSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DefinedSymbolSelect<'a> = Id<DefinedSymbolSelect_<'a>>;

#[derive(Debug)]
pub struct DefinitionalRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DefinitionalRepresentation<'a> = Id<DefinitionalRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DefinitionalRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DefinitionalRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DefinitionalRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DEFINITIONAL_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DefinitionalRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DegeneratePcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DegeneratePcurve<'a> = Id<DegeneratePcurve_<'a>>;
impl<'a> FromEntity<'a> for DegeneratePcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DegeneratePcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DegeneratePcurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DEGENERATE_PCURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, reference_to_curve) = param_from_chunks::<DefinitionalRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_surface,
            reference_to_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DegeneratePcurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.reference_to_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DegenerateToroidalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    pub select_outer: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DegenerateToroidalSurface<'a> = Id<DegenerateToroidalSurface_<'a>>;
impl<'a> FromEntity<'a> for DegenerateToroidalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DegenerateToroidalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DegenerateToroidalSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DEGENERATE_TOROIDAL_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, major_radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, minor_radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, select_outer) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            major_radius,
            minor_radius,
            select_outer,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DegenerateToroidalSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.major_radius.append_ids(_v);
        self.minor_radius.append_ids(_v);
        self.select_outer.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DerivedPropertySelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DerivedPropertySelect<'a> = Id<DerivedPropertySelect_<'a>>;

#[derive(Debug)]
pub struct DerivedShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedShapeAspect<'a> = Id<DerivedShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for DerivedShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DerivedShapeAspect_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DERIVED_SHAPE_ASPECT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DerivedShapeAspect_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DerivedUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnit<'a> = Id<DerivedUnit_<'a>>;
impl<'a> FromEntity<'a> for DerivedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DerivedUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DERIVED_UNIT(")(strs[0])?;
        let (s, elements) = param_from_chunks::<Vec<DerivedUnitElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DerivedUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DerivedUnitElement_<'a> { // entity
    pub unit: NamedUnit<'a>,
    pub exponent: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnitElement<'a> = Id<DerivedUnitElement_<'a>>;
impl<'a> FromEntity<'a> for DerivedUnitElement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedUnitElement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DerivedUnitElement_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DERIVED_UNIT_ELEMENT(")(strs[0])?;
        let (s, unit) = param_from_chunks::<NamedUnit<'a>>(false, s, &mut i, strs)?;
        let (s, exponent) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            unit,
            exponent,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DerivedUnitElement_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.unit.append_ids(_v);
        self.exponent.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DerivedUnitVariable_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DerivedUnitVariable<'a> = Id<DerivedUnitVariable_<'a>>;
impl<'a> FromEntity<'a> for DerivedUnitVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DerivedUnitVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DerivedUnitVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DERIVED_UNIT_VARIABLE(")(strs[0])?;
        let (s, elements) = param_from_chunks::<Vec<DerivedUnitElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DerivedUnitVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DescriptionAttribute_<'a> { // entity
    pub attribute_value: Text<'a>,
    pub described_item: DescriptionAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DescriptionAttribute<'a> = Id<DescriptionAttribute_<'a>>;
impl<'a> FromEntity<'a> for DescriptionAttribute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DescriptionAttribute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DescriptionAttribute_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DESCRIPTION_ATTRIBUTE(")(strs[0])?;
        let (s, attribute_value) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, described_item) = param_from_chunks::<DescriptionAttributeSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            attribute_value,
            described_item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DescriptionAttribute_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.attribute_value.append_ids(_v);
        self.described_item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DescriptionAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DescriptionAttributeSelect<'a> = Id<DescriptionAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct DescriptiveMeasure<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DescriptiveMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for DescriptiveMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct DescriptiveRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DescriptiveRepresentationItem<'a> = Id<DescriptiveRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for DescriptiveRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DescriptiveRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DescriptiveRepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DESCRIPTIVE_REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DescriptiveRepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DiameterDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DiameterDimension<'a> = Id<DiameterDimension_<'a>>;
impl<'a> FromEntity<'a> for DiameterDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DiameterDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DiameterDimension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIAMETER_DIMENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DiameterDimension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCallout<'a> = Id<DimensionCallout_<'a>>;
impl<'a> FromEntity<'a> for DimensionCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionCalloutComponentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCalloutComponentRelationship<'a> = Id<DimensionCalloutComponentRelationship_<'a>>;
impl<'a> FromEntity<'a> for DimensionCalloutComponentRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCalloutComponentRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionCalloutComponentRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(false, s, &mut i, strs)?;
        let (s, related_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionCalloutComponentRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_draughting_callout.append_ids(_v);
        self.related_draughting_callout.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionCalloutRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCalloutRelationship<'a> = Id<DimensionCalloutRelationship_<'a>>;
impl<'a> FromEntity<'a> for DimensionCalloutRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCalloutRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionCalloutRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_CALLOUT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(false, s, &mut i, strs)?;
        let (s, related_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionCalloutRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_draughting_callout.append_ids(_v);
        self.related_draughting_callout.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for DimensionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for DimensionCount<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct DimensionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurve<'a> = Id<DimensionCurve_<'a>>;
impl<'a> FromEntity<'a> for DimensionCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionCurveDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurveDirectedCallout<'a> = Id<DimensionCurveDirectedCallout_<'a>>;
impl<'a> FromEntity<'a> for DimensionCurveDirectedCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCurveDirectedCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionCurveDirectedCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_CURVE_DIRECTED_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionCurveDirectedCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionCurveTerminator_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    pub role: DimensionExtentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionCurveTerminator<'a> = Id<DimensionCurveTerminator_<'a>>;
impl<'a> FromEntity<'a> for DimensionCurveTerminator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionCurveTerminator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionCurveTerminator_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_CURVE_TERMINATOR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, annotated_curve) = param_from_chunks::<AnnotationCurveOccurrence<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<DimensionExtentUsage<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            annotated_curve,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionCurveTerminator_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.annotated_curve.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum DimensionExtentUsage<'a> { // enum
    Origin,
    Target,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for DimensionExtentUsage<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use DimensionExtentUsage::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "ORIGIN" => Origin,
            "TARGET" => Target,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for DimensionExtentUsage<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct DimensionPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionPair<'a> = Id<DimensionPair_<'a>>;
impl<'a> FromEntity<'a> for DimensionPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(false, s, &mut i, strs)?;
        let (s, related_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_draughting_callout.append_ids(_v);
        self.related_draughting_callout.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionRelatedToleranceZoneElement_<'a> { // entity
    pub related_dimension: DimensionalLocation<'a>,
    pub related_element: ToleranceZoneDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionRelatedToleranceZoneElement<'a> = Id<DimensionRelatedToleranceZoneElement_<'a>>;
impl<'a> FromEntity<'a> for DimensionRelatedToleranceZoneElement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionRelatedToleranceZoneElement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionRelatedToleranceZoneElement_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT(")(strs[0])?;
        let (s, related_dimension) = param_from_chunks::<DimensionalLocation<'a>>(false, s, &mut i, strs)?;
        let (s, related_element) = param_from_chunks::<ToleranceZoneDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            related_dimension,
            related_element,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionRelatedToleranceZoneElement_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.related_dimension.append_ids(_v);
        self.related_element.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct DimensionTextAssociativity_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionTextAssociativity<'a> = Id<DimensionTextAssociativity_<'a>>;
impl<'a> FromEntity<'a> for DimensionTextAssociativity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionTextAssociativity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionTextAssociativity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSION_TEXT_ASSOCIATIVITY(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, literal) = param_from_chunks::<PresentableText<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<TextPath<'a>>(false, s, &mut i, strs)?;
        let (s, font) = param_from_chunks::<FontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            literal,
            placement,
            alignment,
            path,
            font,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionTextAssociativity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.literal.append_ids(_v);
        self.placement.append_ids(_v);
        self.alignment.append_ids(_v);
        self.path.append_ids(_v);
        self.font.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionalCharacteristic_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DimensionalCharacteristic<'a> = Id<DimensionalCharacteristic_<'a>>;

#[derive(Debug)]
pub struct DimensionalCharacteristicRepresentation_<'a> { // entity
    pub dimension: DimensionalCharacteristic<'a>,
    pub representation: ShapeDimensionRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalCharacteristicRepresentation<'a> = Id<DimensionalCharacteristicRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DimensionalCharacteristicRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalCharacteristicRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionalCharacteristicRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSIONAL_CHARACTERISTIC_REPRESENTATION(")(strs[0])?;
        let (s, dimension) = param_from_chunks::<DimensionalCharacteristic<'a>>(false, s, &mut i, strs)?;
        let (s, representation) = param_from_chunks::<ShapeDimensionRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimension,
            representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionalCharacteristicRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimension.append_ids(_v);
        self.representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionalExponents_<'a> { // entity
    pub length_exponent: f64,
    pub mass_exponent: f64,
    pub time_exponent: f64,
    pub electric_current_exponent: f64,
    pub thermodynamic_temperature_exponent: f64,
    pub amount_of_substance_exponent: f64,
    pub luminous_intensity_exponent: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalExponents<'a> = Id<DimensionalExponents_<'a>>;
impl<'a> FromEntity<'a> for DimensionalExponents_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalExponents(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionalExponents_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSIONAL_EXPONENTS(")(strs[0])?;
        let (s, length_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, mass_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, time_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, electric_current_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, thermodynamic_temperature_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, amount_of_substance_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, luminous_intensity_exponent) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            length_exponent,
            mass_exponent,
            time_exponent,
            electric_current_exponent,
            thermodynamic_temperature_exponent,
            amount_of_substance_exponent,
            luminous_intensity_exponent,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionalExponents_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.length_exponent.append_ids(_v);
        self.mass_exponent.append_ids(_v);
        self.time_exponent.append_ids(_v);
        self.electric_current_exponent.append_ids(_v);
        self.thermodynamic_temperature_exponent.append_ids(_v);
        self.amount_of_substance_exponent.append_ids(_v);
        self.luminous_intensity_exponent.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionalLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalLocation<'a> = Id<DimensionalLocation_<'a>>;
impl<'a> FromEntity<'a> for DimensionalLocation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalLocation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionalLocation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSIONAL_LOCATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionalLocation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionalLocationWithPath_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    pub path: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalLocationWithPath<'a> = Id<DimensionalLocationWithPath_<'a>>;
impl<'a> FromEntity<'a> for DimensionalLocationWithPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalLocationWithPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionalLocationWithPath_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSIONAL_LOCATION_WITH_PATH(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            path,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionalLocationWithPath_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
        self.path.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionalSize_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalSize<'a> = Id<DimensionalSize_<'a>>;
impl<'a> FromEntity<'a> for DimensionalSize_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalSize(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionalSize_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSIONAL_SIZE(")(strs[0])?;
        let (s, applies_to) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionalSize_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DimensionalSizeWithPath_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub path: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DimensionalSizeWithPath<'a> = Id<DimensionalSizeWithPath_<'a>>;
impl<'a> FromEntity<'a> for DimensionalSizeWithPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DimensionalSizeWithPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DimensionalSizeWithPath_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIMENSIONAL_SIZE_WITH_PATH(")(strs[0])?;
        let (s, applies_to) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to,
            name,
            path,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DimensionalSizeWithPath_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to.append_ids(_v);
        self.name.append_ids(_v);
        self.path.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DirectedAction_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub directive: ActionDirective<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedAction<'a> = Id<DirectedAction_<'a>>;
impl<'a> FromEntity<'a> for DirectedAction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectedAction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DirectedAction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIRECTED_ACTION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(false, s, &mut i, strs)?;
        let (s, directive) = param_from_chunks::<ActionDirective<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            directive,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DirectedAction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
        self.directive.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DirectedAngle_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedAngle<'a> = Id<DirectedAngle_<'a>>;
impl<'a> FromEntity<'a> for DirectedAngle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectedAngle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DirectedAngle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIRECTED_ANGLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DirectedAngle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DirectedDimensionalLocation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectedDimensionalLocation<'a> = Id<DirectedDimensionalLocation_<'a>>;
impl<'a> FromEntity<'a> for DirectedDimensionalLocation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectedDimensionalLocation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DirectedDimensionalLocation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIRECTED_DIMENSIONAL_LOCATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DirectedDimensionalLocation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Direction_<'a> { // entity
    pub name: Label<'a>,
    pub direction_ratios: ArrayVec::<f64, 3>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Direction<'a> = Id<Direction_<'a>>;
impl<'a> FromEntity<'a> for Direction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Direction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Direction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIRECTION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, direction_ratios) = param_from_chunks::<ArrayVec::<f64, 3>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            direction_ratios,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Direction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.direction_ratios.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum DirectionCountSelect<'a> { // select
    UDirectionCount(UDirectionCount<'a>),
    VDirectionCount(VDirectionCount<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for DirectionCountSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("U_DIRECTION_COUNT("), <UDirectionCount<'a>>::parse, char(')')), DirectionCountSelect::UDirectionCount),
            map(delimited(tag("V_DIRECTION_COUNT("), <VDirectionCount<'a>>::parse, char(')')), DirectionCountSelect::VDirectionCount),
        ))(s)
    }
}
impl<'a> HasId for DirectionCountSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            DirectionCountSelect::UDirectionCount(c) => c.append_ids(_v),
            DirectionCountSelect::VDirectionCount(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct DirectionShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DirectionShapeRepresentation<'a> = Id<DirectionShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DirectionShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DirectionShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DirectionShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIRECTION_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DirectionShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DivExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DivExpression<'a> = Id<DivExpression_<'a>>;
impl<'a> FromEntity<'a> for DivExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DivExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DivExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DIV_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DivExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Document_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub kind: DocumentType<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Document<'a> = Id<Document_<'a>>;
impl<'a> FromEntity<'a> for Document_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Document(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Document_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<DocumentType<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            kind,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Document_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.kind.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct DocumentFile_<'a> { // entity
    pub id: Identifier<'a>,
    pub document__name: Label<'a>,
    pub document__description: Option<Text<'a>>,
    pub kind: DocumentType<'a>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentFile<'a> = Id<DocumentFile_<'a>>;
impl<'a> FromEntity<'a> for DocumentFile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentFile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentFile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_FILE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, document__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, document__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<DocumentType<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            document__name,
            document__description,
            kind,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentFile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.document__name.append_ids(_v);
        self.document__description.append_ids(_v);
        self.kind.append_ids(_v);
        self.characterized_object__name.append_ids(_v);
        self.characterized_object__description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentProductAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_product: ProductOrFormationOrDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentProductAssociation<'a> = Id<DocumentProductAssociation_<'a>>;
impl<'a> FromEntity<'a> for DocumentProductAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentProductAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentProductAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_PRODUCT_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_document) = param_from_chunks::<Document<'a>>(false, s, &mut i, strs)?;
        let (s, related_product) = param_from_chunks::<ProductOrFormationOrDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_document,
            related_product,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentProductAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_document.append_ids(_v);
        self.related_product.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentProductEquivalence_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_product: ProductOrFormationOrDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentProductEquivalence<'a> = Id<DocumentProductEquivalence_<'a>>;
impl<'a> FromEntity<'a> for DocumentProductEquivalence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentProductEquivalence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentProductEquivalence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_PRODUCT_EQUIVALENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_document) = param_from_chunks::<Document<'a>>(false, s, &mut i, strs)?;
        let (s, related_product) = param_from_chunks::<ProductOrFormationOrDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_document,
            related_product,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentProductEquivalence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_document.append_ids(_v);
        self.related_product.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentReference<'a> = Id<DocumentReference_<'a>>;
impl<'a> FromEntity<'a> for DocumentReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentReference_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_REFERENCE(")(strs[0])?;
        let (s, assigned_document) = param_from_chunks::<Document<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_document,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentReference_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_document.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentReferenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DocumentReferenceItem<'a> = Id<DocumentReferenceItem_<'a>>;

#[derive(Debug)]
pub struct DocumentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_document: Document<'a>,
    pub related_document: Document<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentRelationship<'a> = Id<DocumentRelationship_<'a>>;
impl<'a> FromEntity<'a> for DocumentRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_document) = param_from_chunks::<Document<'a>>(false, s, &mut i, strs)?;
        let (s, related_document) = param_from_chunks::<Document<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_document,
            related_document,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_document.append_ids(_v);
        self.related_document.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentRepresentationType_<'a> { // entity
    pub name: Label<'a>,
    pub represented_document: Document<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentRepresentationType<'a> = Id<DocumentRepresentationType_<'a>>;
impl<'a> FromEntity<'a> for DocumentRepresentationType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentRepresentationType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentRepresentationType_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_REPRESENTATION_TYPE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, represented_document) = param_from_chunks::<Document<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            represented_document,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentRepresentationType_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.represented_document.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentType_<'a> { // entity
    pub product_data_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentType<'a> = Id<DocumentType_<'a>>;
impl<'a> FromEntity<'a> for DocumentType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentType_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_TYPE(")(strs[0])?;
        let (s, product_data_type) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            product_data_type,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentType_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.product_data_type.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentUsageConstraint_<'a> { // entity
    pub source: Document<'a>,
    pub subject_element: Label<'a>,
    pub subject_element_value: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageConstraint<'a> = Id<DocumentUsageConstraint_<'a>>;
impl<'a> FromEntity<'a> for DocumentUsageConstraint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentUsageConstraint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentUsageConstraint_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_USAGE_CONSTRAINT(")(strs[0])?;
        let (s, source) = param_from_chunks::<Document<'a>>(false, s, &mut i, strs)?;
        let (s, subject_element) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, subject_element_value) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            source,
            subject_element,
            subject_element_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentUsageConstraint_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.source.append_ids(_v);
        self.subject_element.append_ids(_v);
        self.subject_element_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentUsageConstraintAssignment_<'a> { // entity
    pub assigned_document_usage: DocumentUsageConstraint<'a>,
    pub role: DocumentUsageRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageConstraintAssignment<'a> = Id<DocumentUsageConstraintAssignment_<'a>>;
impl<'a> FromEntity<'a> for DocumentUsageConstraintAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentUsageConstraintAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentUsageConstraintAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_document_usage) = param_from_chunks::<DocumentUsageConstraint<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<DocumentUsageRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_document_usage,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentUsageConstraintAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_document_usage.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DocumentUsageRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DocumentUsageRole<'a> = Id<DocumentUsageRole_<'a>>;
impl<'a> FromEntity<'a> for DocumentUsageRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DocumentUsageRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DocumentUsageRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DOCUMENT_USAGE_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DocumentUsageRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingAnnotationOccurrence_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingAnnotationOccurrence<'a> = Id<DraughtingAnnotationOccurrence_<'a>>;
impl<'a> FromEntity<'a> for DraughtingAnnotationOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingAnnotationOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingAnnotationOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_ANNOTATION_OCCURRENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingAnnotationOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingCallout<'a> = Id<DraughtingCallout_<'a>>;
impl<'a> FromEntity<'a> for DraughtingCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingCalloutElement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingCalloutElement<'a> = Id<DraughtingCalloutElement_<'a>>;

#[derive(Debug)]
pub struct DraughtingCalloutRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_draughting_callout: DraughtingCallout<'a>,
    pub related_draughting_callout: DraughtingCallout<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingCalloutRelationship<'a> = Id<DraughtingCalloutRelationship_<'a>>;
impl<'a> FromEntity<'a> for DraughtingCalloutRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingCalloutRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingCalloutRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_CALLOUT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(false, s, &mut i, strs)?;
        let (s, related_draughting_callout) = param_from_chunks::<DraughtingCallout<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_draughting_callout,
            related_draughting_callout,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingCalloutRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_draughting_callout.append_ids(_v);
        self.related_draughting_callout.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingElements_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingElements<'a> = Id<DraughtingElements_<'a>>;
impl<'a> FromEntity<'a> for DraughtingElements_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingElements(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingElements_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_ELEMENTS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingElements_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingModel_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingModel<'a> = Id<DraughtingModel_<'a>>;
impl<'a> FromEntity<'a> for DraughtingModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingModel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_MODEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingModel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingModelItemAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingModelItemAssociation<'a> = Id<DraughtingModelItemAssociation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingModelItemAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingModelItemAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingModelItemAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_MODEL_ITEM_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<RepresentedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, used_representation) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, identified_item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            used_representation,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingModelItemAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
        self.used_representation.append_ids(_v);
        self.identified_item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingModelItemAssociationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingModelItemAssociationSelect<'a> = Id<DraughtingModelItemAssociationSelect_<'a>>;

#[derive(Debug)]
pub struct DraughtingPreDefinedColour_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedColour<'a> = Id<DraughtingPreDefinedColour_<'a>>;
impl<'a> FromEntity<'a> for DraughtingPreDefinedColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingPreDefinedColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingPreDefinedColour_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_PRE_DEFINED_COLOUR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingPreDefinedColour_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingPreDefinedCurveFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedCurveFont<'a> = Id<DraughtingPreDefinedCurveFont_<'a>>;
impl<'a> FromEntity<'a> for DraughtingPreDefinedCurveFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingPreDefinedCurveFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingPreDefinedCurveFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_PRE_DEFINED_CURVE_FONT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingPreDefinedCurveFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingPreDefinedTextFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingPreDefinedTextFont<'a> = Id<DraughtingPreDefinedTextFont_<'a>>;
impl<'a> FromEntity<'a> for DraughtingPreDefinedTextFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingPreDefinedTextFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingPreDefinedTextFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_PRE_DEFINED_TEXT_FONT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingPreDefinedTextFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingSpecificationReference_<'a> { // entity
    pub assigned_document: Document<'a>,
    pub source: Label<'a>,
    pub specified_items: Vec<SpecifiedItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSpecificationReference<'a> = Id<DraughtingSpecificationReference_<'a>>;
impl<'a> FromEntity<'a> for DraughtingSpecificationReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingSpecificationReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingSpecificationReference_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_SPECIFICATION_REFERENCE(")(strs[0])?;
        let (s, assigned_document) = param_from_chunks::<Document<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, specified_items) = param_from_chunks::<Vec<SpecifiedItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_document,
            source,
            specified_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingSpecificationReference_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_document.append_ids(_v);
        self.source.append_ids(_v);
        self.specified_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingSubfigureRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSubfigureRepresentation<'a> = Id<DraughtingSubfigureRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingSubfigureRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingSubfigureRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingSubfigureRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_SUBFIGURE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingSubfigureRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingSymbolRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingSymbolRepresentation<'a> = Id<DraughtingSymbolRepresentation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingSymbolRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingSymbolRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingSymbolRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_SYMBOL_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingSymbolRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingTextLiteralWithDelineation_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub delineation: TextDelineation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingTextLiteralWithDelineation<'a> = Id<DraughtingTextLiteralWithDelineation_<'a>>;
impl<'a> FromEntity<'a> for DraughtingTextLiteralWithDelineation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingTextLiteralWithDelineation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingTextLiteralWithDelineation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, literal) = param_from_chunks::<PresentableText<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<TextPath<'a>>(false, s, &mut i, strs)?;
        let (s, font) = param_from_chunks::<FontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, delineation) = param_from_chunks::<TextDelineation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            delineation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingTextLiteralWithDelineation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.literal.append_ids(_v);
        self.placement.append_ids(_v);
        self.alignment.append_ids(_v);
        self.path.append_ids(_v);
        self.font.append_ids(_v);
        self.delineation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingTitle_<'a> { // entity
    pub items: Vec<DraughtingTitledItem<'a>>,
    pub language: Label<'a>,
    pub contents: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DraughtingTitle<'a> = Id<DraughtingTitle_<'a>>;
impl<'a> FromEntity<'a> for DraughtingTitle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DraughtingTitle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DraughtingTitle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAUGHTING_TITLE(")(strs[0])?;
        let (s, items) = param_from_chunks::<Vec<DraughtingTitledItem<'a>>>(false, s, &mut i, strs)?;
        let (s, language) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            items,
            language,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DraughtingTitle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.items.append_ids(_v);
        self.language.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DraughtingTitledItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type DraughtingTitledItem<'a> = Id<DraughtingTitledItem_<'a>>;

#[derive(Debug)]
pub struct DrawingDefinition_<'a> { // entity
    pub drawing_number: Identifier<'a>,
    pub drawing_type: Option<Label<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingDefinition<'a> = Id<DrawingDefinition_<'a>>;
impl<'a> FromEntity<'a> for DrawingDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DrawingDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAWING_DEFINITION(")(strs[0])?;
        let (s, drawing_number) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, drawing_type) = param_from_chunks::<Option<Label<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            drawing_number,
            drawing_type,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DrawingDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.drawing_number.append_ids(_v);
        self.drawing_type.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DrawingRevision_<'a> { // entity
    pub revision_identifier: Identifier<'a>,
    pub drawing_identifier: DrawingDefinition<'a>,
    pub intended_scale: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingRevision<'a> = Id<DrawingRevision_<'a>>;
impl<'a> FromEntity<'a> for DrawingRevision_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingRevision(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DrawingRevision_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAWING_REVISION(")(strs[0])?;
        let (s, revision_identifier) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, drawing_identifier) = param_from_chunks::<DrawingDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, intended_scale) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            revision_identifier,
            drawing_identifier,
            intended_scale,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DrawingRevision_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.revision_identifier.append_ids(_v);
        self.drawing_identifier.append_ids(_v);
        self.intended_scale.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DrawingRevisionSequence_<'a> { // entity
    pub predecessor: DrawingRevision<'a>,
    pub successor: DrawingRevision<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingRevisionSequence<'a> = Id<DrawingRevisionSequence_<'a>>;
impl<'a> FromEntity<'a> for DrawingRevisionSequence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingRevisionSequence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DrawingRevisionSequence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAWING_REVISION_SEQUENCE(")(strs[0])?;
        let (s, predecessor) = param_from_chunks::<DrawingRevision<'a>>(false, s, &mut i, strs)?;
        let (s, successor) = param_from_chunks::<DrawingRevision<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            predecessor,
            successor,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DrawingRevisionSequence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.predecessor.append_ids(_v);
        self.successor.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DrawingSheetLayout_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetLayout<'a> = Id<DrawingSheetLayout_<'a>>;
impl<'a> FromEntity<'a> for DrawingSheetLayout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingSheetLayout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DrawingSheetLayout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAWING_SHEET_LAYOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DrawingSheetLayout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DrawingSheetRevision_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub revision_identifier: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetRevision<'a> = Id<DrawingSheetRevision_<'a>>;
impl<'a> FromEntity<'a> for DrawingSheetRevision_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingSheetRevision(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DrawingSheetRevision_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAWING_SHEET_REVISION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(false, s, &mut i, strs)?;
        let (s, revision_identifier) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            revision_identifier,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DrawingSheetRevision_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
        self.revision_identifier.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct DrawingSheetRevisionUsage_<'a> { // entity
    pub area: PresentationArea<'a>,
    pub in_set: PresentationSet<'a>,
    pub sheet_number: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type DrawingSheetRevisionUsage<'a> = Id<DrawingSheetRevisionUsage_<'a>>;
impl<'a> FromEntity<'a> for DrawingSheetRevisionUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::DrawingSheetRevisionUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for DrawingSheetRevisionUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("DRAWING_SHEET_REVISION_USAGE(")(strs[0])?;
        let (s, area) = param_from_chunks::<PresentationArea<'a>>(false, s, &mut i, strs)?;
        let (s, in_set) = param_from_chunks::<PresentationSet<'a>>(false, s, &mut i, strs)?;
        let (s, sheet_number) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            area,
            in_set,
            sheet_number,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for DrawingSheetRevisionUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.area.append_ids(_v);
        self.in_set.append_ids(_v);
        self.sheet_number.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Edge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Edge<'a> = Id<Edge_<'a>>;
impl<'a> FromEntity<'a> for Edge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Edge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Edge_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EDGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, edge_start) = param_from_chunks::<Vertex<'a>>(false, s, &mut i, strs)?;
        let (s, edge_end) = param_from_chunks::<Vertex<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            edge_start,
            edge_end,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Edge_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.edge_start.append_ids(_v);
        self.edge_end.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EdgeBasedWireframeModel_<'a> { // entity
    pub name: Label<'a>,
    pub ebwm_boundary: Vec<ConnectedEdgeSet<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeBasedWireframeModel<'a> = Id<EdgeBasedWireframeModel_<'a>>;
impl<'a> FromEntity<'a> for EdgeBasedWireframeModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeBasedWireframeModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EdgeBasedWireframeModel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EDGE_BASED_WIREFRAME_MODEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, ebwm_boundary) = param_from_chunks::<Vec<ConnectedEdgeSet<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            ebwm_boundary,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EdgeBasedWireframeModel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.ebwm_boundary.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EdgeBasedWireframeShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeBasedWireframeShapeRepresentation<'a> = Id<EdgeBasedWireframeShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for EdgeBasedWireframeShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeBasedWireframeShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EdgeBasedWireframeShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EdgeBasedWireframeShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct EdgeCurve_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub edge_geometry: Curve<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeCurve<'a> = Id<EdgeCurve_<'a>>;
impl<'a> FromEntity<'a> for EdgeCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EdgeCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EDGE_CURVE(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, edge_start) = param_from_chunks::<Vertex<'a>>(false, s, &mut i, strs)?;
        let (s, edge_end) = param_from_chunks::<Vertex<'a>>(false, s, &mut i, strs)?;
        let (s, edge_geometry) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, same_sense) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            edge_start,
            edge_end,
            edge_geometry,
            same_sense,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EdgeCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.edge_start.append_ids(_v);
        self.edge_end.append_ids(_v);
        self.edge_geometry.append_ids(_v);
        self.same_sense.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct EdgeLoop_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub edge_list: Vec<OrientedEdge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeLoop<'a> = Id<EdgeLoop_<'a>>;
impl<'a> FromEntity<'a> for EdgeLoop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeLoop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EdgeLoop_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EDGE_LOOP(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, edge_list) = param_from_chunks::<Vec<OrientedEdge<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            edge_list,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EdgeLoop_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.edge_list.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EdgeRound_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EdgeRound<'a> = Id<EdgeRound_<'a>>;
impl<'a> FromEntity<'a> for EdgeRound_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EdgeRound(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EdgeRound_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EDGE_ROUND(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EdgeRound_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Effectivity_<'a> { // entity
    pub id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Effectivity<'a> = Id<Effectivity_<'a>>;
impl<'a> FromEntity<'a> for Effectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Effectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Effectivity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EFFECTIVITY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Effectivity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EffectivityAssignment_<'a> { // entity
    pub assigned_effectivity: Effectivity<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityAssignment<'a> = Id<EffectivityAssignment_<'a>>;
impl<'a> FromEntity<'a> for EffectivityAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EffectivityAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EFFECTIVITY_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_effectivity) = param_from_chunks::<Effectivity<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_effectivity,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EffectivityAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_effectivity.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EffectivityContextAssignment_<'a> { // entity
    pub assigned_effectivity_assignment: EffectivityAssignment<'a>,
    pub role: EffectivityContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityContextAssignment<'a> = Id<EffectivityContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for EffectivityContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EffectivityContextAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EFFECTIVITY_CONTEXT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_effectivity_assignment) = param_from_chunks::<EffectivityAssignment<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<EffectivityContextRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_effectivity_assignment,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EffectivityContextAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_effectivity_assignment.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EffectivityContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityContextRole<'a> = Id<EffectivityContextRole_<'a>>;
impl<'a> FromEntity<'a> for EffectivityContextRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityContextRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EffectivityContextRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EFFECTIVITY_CONTEXT_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EffectivityContextRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EffectivityItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type EffectivityItem<'a> = Id<EffectivityItem_<'a>>;

#[derive(Debug)]
pub struct EffectivityRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub related_effectivity: Effectivity<'a>,
    pub relating_effectivity: Effectivity<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EffectivityRelationship<'a> = Id<EffectivityRelationship_<'a>>;
impl<'a> FromEntity<'a> for EffectivityRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EffectivityRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EffectivityRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EFFECTIVITY_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, related_effectivity) = param_from_chunks::<Effectivity<'a>>(false, s, &mut i, strs)?;
        let (s, relating_effectivity) = param_from_chunks::<Effectivity<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            related_effectivity,
            relating_effectivity,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EffectivityRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.related_effectivity.append_ids(_v);
        self.relating_effectivity.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ElectricCurrentMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ElectricCurrentMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for ElectricCurrentMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct ElectricCurrentMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElectricCurrentMeasureWithUnit<'a> = Id<ElectricCurrentMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for ElectricCurrentMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElectricCurrentMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ElectricCurrentMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ELECTRIC_CURRENT_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ElectricCurrentMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ElectricCurrentUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElectricCurrentUnit<'a> = Id<ElectricCurrentUnit_<'a>>;
impl<'a> FromEntity<'a> for ElectricCurrentUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElectricCurrentUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ElectricCurrentUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ELECTRIC_CURRENT_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ElectricCurrentUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ElementDelivery_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElementDelivery<'a> = Id<ElementDelivery_<'a>>;
impl<'a> FromEntity<'a> for ElementDelivery_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElementDelivery(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ElementDelivery_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ELEMENT_DELIVERY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ElementDelivery_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ElementarySurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ElementarySurface<'a> = Id<ElementarySurface_<'a>>;
impl<'a> FromEntity<'a> for ElementarySurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ElementarySurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ElementarySurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ELEMENTARY_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ElementarySurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Ellipse_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub semi_axis_1: PositiveLengthMeasure<'a>,
    pub semi_axis_2: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Ellipse<'a> = Id<Ellipse_<'a>>;
impl<'a> FromEntity<'a> for Ellipse_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Ellipse(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Ellipse_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ELLIPSE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, semi_axis_1) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, semi_axis_2) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            semi_axis_1,
            semi_axis_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Ellipse_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.semi_axis_1.append_ids(_v);
        self.semi_axis_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Environment_<'a> { // entity
    pub syntactic_representation: GenericVariable<'a>,
    pub semantics: VariableSemantics<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Environment<'a> = Id<Environment_<'a>>;
impl<'a> FromEntity<'a> for Environment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Environment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Environment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ENVIRONMENT(")(strs[0])?;
        let (s, syntactic_representation) = param_from_chunks::<GenericVariable<'a>>(false, s, &mut i, strs)?;
        let (s, semantics) = param_from_chunks::<VariableSemantics<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            syntactic_representation,
            semantics,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Environment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.syntactic_representation.append_ids(_v);
        self.semantics.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EqualsExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EqualsExpression<'a> = Id<EqualsExpression_<'a>>;
impl<'a> FromEntity<'a> for EqualsExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EqualsExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EqualsExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EQUALS_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EqualsExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EvaluatedDegeneratePcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    pub equivalent_point: CartesianPoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EvaluatedDegeneratePcurve<'a> = Id<EvaluatedDegeneratePcurve_<'a>>;
impl<'a> FromEntity<'a> for EvaluatedDegeneratePcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EvaluatedDegeneratePcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EvaluatedDegeneratePcurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EVALUATED_DEGENERATE_PCURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, reference_to_curve) = param_from_chunks::<DefinitionalRepresentation<'a>>(false, s, &mut i, strs)?;
        let (s, equivalent_point) = param_from_chunks::<CartesianPoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_surface,
            reference_to_curve,
            equivalent_point,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EvaluatedDegeneratePcurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.reference_to_curve.append_ids(_v);
        self.equivalent_point.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EventOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrence<'a> = Id<EventOccurrence_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EventOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EVENT_OCCURRENCE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EventOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EventOccurrenceAssignment_<'a> { // entity
    pub assigned_event_occurrence: EventOccurrence<'a>,
    pub role: EventOccurrenceRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceAssignment<'a> = Id<EventOccurrenceAssignment_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EventOccurrenceAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EVENT_OCCURRENCE_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_event_occurrence) = param_from_chunks::<EventOccurrence<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<EventOccurrenceRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_event_occurrence,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EventOccurrenceAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_event_occurrence.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EventOccurrenceContextAssignment_<'a> { // entity
    pub assigned_event_occurrence_assignment: EventOccurrenceAssignment<'a>,
    pub role: EventOccurrenceContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceContextAssignment<'a> = Id<EventOccurrenceContextAssignment_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceContextAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceContextAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EventOccurrenceContextAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EVENT_OCCURRENCE_CONTEXT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_event_occurrence_assignment) = param_from_chunks::<EventOccurrenceAssignment<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<EventOccurrenceContextRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_event_occurrence_assignment,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EventOccurrenceContextAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_event_occurrence_assignment.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EventOccurrenceContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceContextRole<'a> = Id<EventOccurrenceContextRole_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceContextRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceContextRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EventOccurrenceContextRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EVENT_OCCURRENCE_CONTEXT_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EventOccurrenceContextRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct EventOccurrenceItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type EventOccurrenceItem<'a> = Id<EventOccurrenceItem_<'a>>;

#[derive(Debug)]
pub struct EventOccurrenceRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type EventOccurrenceRole<'a> = Id<EventOccurrenceRole_<'a>>;
impl<'a> FromEntity<'a> for EventOccurrenceRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::EventOccurrenceRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for EventOccurrenceRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EVENT_OCCURRENCE_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for EventOccurrenceRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExclusiveProductConceptFeatureCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExclusiveProductConceptFeatureCategory<'a> = Id<ExclusiveProductConceptFeatureCategory_<'a>>;
impl<'a> FromEntity<'a> for ExclusiveProductConceptFeatureCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExclusiveProductConceptFeatureCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExclusiveProductConceptFeatureCategory_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExclusiveProductConceptFeatureCategory_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExecutedAction_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExecutedAction<'a> = Id<ExecutedAction_<'a>>;
impl<'a> FromEntity<'a> for ExecutedAction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExecutedAction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExecutedAction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXECUTED_ACTION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExecutedAction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExpFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExpFunction<'a> = Id<ExpFunction_<'a>>;
impl<'a> FromEntity<'a> for ExpFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExpFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExpFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXP_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExpFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Expression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Expression<'a> = Id<Expression_<'a>>;
impl<'a> FromEntity<'a> for Expression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Expression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Expression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Expression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct ExpressionConversionBasedUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExpressionConversionBasedUnit<'a> = Id<ExpressionConversionBasedUnit_<'a>>;
impl<'a> FromEntity<'a> for ExpressionConversionBasedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExpressionConversionBasedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExpressionConversionBasedUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXPRESSION_CONVERSION_BASED_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExpressionConversionBasedUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Extension_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Extension<'a> = Id<Extension_<'a>>;
impl<'a> FromEntity<'a> for Extension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Extension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Extension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Extension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternalIdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternalIdentificationAssignment<'a> = Id<ExternalIdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for ExternalIdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternalIdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternalIdentificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNAL_IDENTIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<IdentificationRole<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_id,
            role,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternalIdentificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_id.append_ids(_v);
        self.role.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternalIdentificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ExternalIdentificationItem<'a> = Id<ExternalIdentificationItem_<'a>>;

#[derive(Debug)]
pub struct ExternalSource_<'a> { // entity
    pub source_id: SourceItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternalSource<'a> = Id<ExternalSource_<'a>>;
impl<'a> FromEntity<'a> for ExternalSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternalSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternalSource_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNAL_SOURCE(")(strs[0])?;
        let (s, source_id) = param_from_chunks::<SourceItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            source_id,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternalSource_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.source_id.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedCharacterGlyph_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedCharacterGlyph<'a> = Id<ExternallyDefinedCharacterGlyph_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedCharacterGlyph_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedCharacterGlyph(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedCharacterGlyph_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_CHARACTER_GLYPH(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedCharacterGlyph_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedClass_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedClass<'a> = Id<ExternallyDefinedClass_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedClass_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedClass(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedClass_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_CLASS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedClass_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedCurveFont_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedCurveFont<'a> = Id<ExternallyDefinedCurveFont_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedCurveFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedCurveFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedCurveFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_CURVE_FONT(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedCurveFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedDimensionDefinition_<'a> { // entity
    pub applies_to: ShapeAspect<'a>,
    pub name: Label<'a>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedDimensionDefinition<'a> = Id<ExternallyDefinedDimensionDefinition_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedDimensionDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedDimensionDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedDimensionDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_DIMENSION_DEFINITION(")(strs[0])?;
        let (s, applies_to) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to,
            name,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedDimensionDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to.append_ids(_v);
        self.name.append_ids(_v);
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedFeatureDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedFeatureDefinition<'a> = Id<ExternallyDefinedFeatureDefinition_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedFeatureDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedFeatureDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedFeatureDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_FEATURE_DEFINITION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedFeatureDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedGeneralProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedGeneralProperty<'a> = Id<ExternallyDefinedGeneralProperty_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedGeneralProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedGeneralProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedGeneralProperty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_GENERAL_PROPERTY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedGeneralProperty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedHatchStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedHatchStyle<'a> = Id<ExternallyDefinedHatchStyle_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedHatchStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedHatchStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedHatchStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_HATCH_STYLE(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedHatchStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedItem_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedItem<'a> = Id<ExternallyDefinedItem_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_ITEM(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedItemRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_item: ExternallyDefinedItem<'a>,
    pub related_item: ExternallyDefinedItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedItemRelationship<'a> = Id<ExternallyDefinedItemRelationship_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedItemRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedItemRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedItemRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_ITEM_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_item) = param_from_chunks::<ExternallyDefinedItem<'a>>(false, s, &mut i, strs)?;
        let (s, related_item) = param_from_chunks::<ExternallyDefinedItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_item,
            related_item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedItemRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_item.append_ids(_v);
        self.related_item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedStyle<'a> = Id<ExternallyDefinedStyle_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_STYLE(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedSymbol_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedSymbol<'a> = Id<ExternallyDefinedSymbol_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_SYMBOL(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedTextFont_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedTextFont<'a> = Id<ExternallyDefinedTextFont_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedTextFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedTextFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedTextFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_TEXT_FONT(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedTextFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExternallyDefinedTileStyle_<'a> { // entity
    pub item_id: SourceItem<'a>,
    pub source: ExternalSource<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExternallyDefinedTileStyle<'a> = Id<ExternallyDefinedTileStyle_<'a>>;
impl<'a> FromEntity<'a> for ExternallyDefinedTileStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExternallyDefinedTileStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExternallyDefinedTileStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTERNALLY_DEFINED_TILE_STYLE(")(strs[0])?;
        let (s, item_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<ExternalSource<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            item_id,
            source,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExternallyDefinedTileStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.item_id.append_ids(_v);
        self.source.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExtrudedAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub extruded_direction: Direction<'a>,
    pub depth: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExtrudedAreaSolid<'a> = Id<ExtrudedAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for ExtrudedAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExtrudedAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExtrudedAreaSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTRUDED_AREA_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_area) = param_from_chunks::<CurveBoundedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, extruded_direction) = param_from_chunks::<Direction<'a>>(false, s, &mut i, strs)?;
        let (s, depth) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_area,
            extruded_direction,
            depth,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExtrudedAreaSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_area.append_ids(_v);
        self.extruded_direction.append_ids(_v);
        self.depth.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ExtrudedFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    pub extruded_direction: Direction<'a>,
    pub depth: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ExtrudedFaceSolid<'a> = Id<ExtrudedFaceSolid_<'a>>;
impl<'a> FromEntity<'a> for ExtrudedFaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ExtrudedFaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ExtrudedFaceSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("EXTRUDED_FACE_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_face) = param_from_chunks::<FaceSurface<'a>>(false, s, &mut i, strs)?;
        let (s, extruded_direction) = param_from_chunks::<Direction<'a>>(false, s, &mut i, strs)?;
        let (s, depth) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_face,
            extruded_direction,
            depth,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ExtrudedFaceSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_face.append_ids(_v);
        self.extruded_direction.append_ids(_v);
        self.depth.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Face_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Face<'a> = Id<Face_<'a>>;
impl<'a> FromEntity<'a> for Face_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Face(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Face_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, bounds) = param_from_chunks::<Vec<FaceBound<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            bounds,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Face_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.bounds.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FaceBasedSurfaceModel_<'a> { // entity
    pub name: Label<'a>,
    pub fbsm_faces: Vec<ConnectedFaceSet<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceBasedSurfaceModel<'a> = Id<FaceBasedSurfaceModel_<'a>>;
impl<'a> FromEntity<'a> for FaceBasedSurfaceModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceBasedSurfaceModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FaceBasedSurfaceModel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACE_BASED_SURFACE_MODEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, fbsm_faces) = param_from_chunks::<Vec<ConnectedFaceSet<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            fbsm_faces,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FaceBasedSurfaceModel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.fbsm_faces.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FaceBound_<'a> { // entity
    pub name: Label<'a>,
    pub bound: Loop<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceBound<'a> = Id<FaceBound_<'a>>;
impl<'a> FromEntity<'a> for FaceBound_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceBound(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FaceBound_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACE_BOUND(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, bound) = param_from_chunks::<Loop<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            bound,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FaceBound_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.bound.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FaceOuterBound_<'a> { // entity
    pub name: Label<'a>,
    pub bound: Loop<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceOuterBound<'a> = Id<FaceOuterBound_<'a>>;
impl<'a> FromEntity<'a> for FaceOuterBound_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceOuterBound(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FaceOuterBound_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACE_OUTER_BOUND(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, bound) = param_from_chunks::<Loop<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            bound,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FaceOuterBound_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.bound.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceShapeRepresentation<'a> = Id<FaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for FaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FaceShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACE_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FaceShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct FaceSurface_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub face_geometry: Surface<'a>,
    pub same_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FaceSurface<'a> = Id<FaceSurface_<'a>>;
impl<'a> FromEntity<'a> for FaceSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FaceSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FaceSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACE_SURFACE(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, bounds) = param_from_chunks::<Vec<FaceBound<'a>>>(false, s, &mut i, strs)?;
        let (s, face_geometry) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, same_sense) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            bounds,
            face_geometry,
            same_sense,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FaceSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.bounds.append_ids(_v);
        self.face_geometry.append_ids(_v);
        self.same_sense.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FacetedBrep_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FacetedBrep<'a> = Id<FacetedBrep_<'a>>;
impl<'a> FromEntity<'a> for FacetedBrep_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FacetedBrep(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FacetedBrep_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACETED_BREP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, outer) = param_from_chunks::<ClosedShell<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            outer,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FacetedBrep_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.outer.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FacetedBrepShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FacetedBrepShapeRepresentation<'a> = Id<FacetedBrepShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for FacetedBrepShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FacetedBrepShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FacetedBrepShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FACETED_BREP_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FacetedBrepShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FeatureComponentDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureComponentDefinition<'a> = Id<FeatureComponentDefinition_<'a>>;
impl<'a> FromEntity<'a> for FeatureComponentDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureComponentDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FeatureComponentDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FEATURE_COMPONENT_DEFINITION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FeatureComponentDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FeatureComponentRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureComponentRelationship<'a> = Id<FeatureComponentRelationship_<'a>>;
impl<'a> FromEntity<'a> for FeatureComponentRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureComponentRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FeatureComponentRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FEATURE_COMPONENT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FeatureComponentRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FeatureDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureDefinition<'a> = Id<FeatureDefinition_<'a>>;
impl<'a> FromEntity<'a> for FeatureDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FeatureDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FEATURE_DEFINITION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FeatureDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FeatureInPanel_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeatureInPanel<'a> = Id<FeatureInPanel_<'a>>;
impl<'a> FromEntity<'a> for FeatureInPanel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeatureInPanel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FeatureInPanel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FEATURE_IN_PANEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FeatureInPanel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FeaturePattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeaturePattern<'a> = Id<FeaturePattern_<'a>>;
impl<'a> FromEntity<'a> for FeaturePattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeaturePattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FeaturePattern_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FEATURE_PATTERN(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FeaturePattern_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FeaturedShape_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FeaturedShape<'a> = Id<FeaturedShape_<'a>>;
impl<'a> FromEntity<'a> for FeaturedShape_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FeaturedShape(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FeaturedShape_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FEATURED_SHAPE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<CharacterizedDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FeaturedShape_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FillAreaStyle_<'a> { // entity
    pub name: Label<'a>,
    pub fill_styles: Vec<FillStyleSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyle<'a> = Id<FillAreaStyle_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FillAreaStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FILL_AREA_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, fill_styles) = param_from_chunks::<Vec<FillStyleSelect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            fill_styles,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FillAreaStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.fill_styles.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FillAreaStyleColour_<'a> { // entity
    pub name: Label<'a>,
    pub fill_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleColour<'a> = Id<FillAreaStyleColour_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FillAreaStyleColour_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FILL_AREA_STYLE_COLOUR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, fill_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            fill_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FillAreaStyleColour_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.fill_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FillAreaStyleHatching_<'a> { // entity
    pub name: Label<'a>,
    pub hatch_line_appearance: CurveStyle<'a>,
    pub start_of_next_hatch_line: OneDirectionRepeatFactor<'a>,
    pub point_of_reference_hatch_line: CartesianPoint<'a>,
    pub pattern_start: CartesianPoint<'a>,
    pub hatch_line_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleHatching<'a> = Id<FillAreaStyleHatching_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleHatching_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleHatching(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FillAreaStyleHatching_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FILL_AREA_STYLE_HATCHING(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, hatch_line_appearance) = param_from_chunks::<CurveStyle<'a>>(false, s, &mut i, strs)?;
        let (s, start_of_next_hatch_line) = param_from_chunks::<OneDirectionRepeatFactor<'a>>(false, s, &mut i, strs)?;
        let (s, point_of_reference_hatch_line) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, pattern_start) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, hatch_line_angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            hatch_line_appearance,
            start_of_next_hatch_line,
            point_of_reference_hatch_line,
            pattern_start,
            hatch_line_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FillAreaStyleHatching_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.hatch_line_appearance.append_ids(_v);
        self.start_of_next_hatch_line.append_ids(_v);
        self.point_of_reference_hatch_line.append_ids(_v);
        self.pattern_start.append_ids(_v);
        self.hatch_line_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FillAreaStyleTileShapeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FillAreaStyleTileShapeSelect<'a> = Id<FillAreaStyleTileShapeSelect_<'a>>;

#[derive(Debug)]
pub struct FillAreaStyleTileSymbolWithStyle_<'a> { // entity
    pub name: Label<'a>,
    pub symbol: AnnotationSymbolOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleTileSymbolWithStyle<'a> = Id<FillAreaStyleTileSymbolWithStyle_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleTileSymbolWithStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleTileSymbolWithStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FillAreaStyleTileSymbolWithStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, symbol) = param_from_chunks::<AnnotationSymbolOccurrence<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            symbol,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FillAreaStyleTileSymbolWithStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.symbol.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FillAreaStyleTiles_<'a> { // entity
    pub name: Label<'a>,
    pub tiling_pattern: TwoDirectionRepeatFactor<'a>,
    pub tiles: Vec<FillAreaStyleTileShapeSelect<'a>>,
    pub tiling_scale: PositiveRatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FillAreaStyleTiles<'a> = Id<FillAreaStyleTiles_<'a>>;
impl<'a> FromEntity<'a> for FillAreaStyleTiles_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FillAreaStyleTiles(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FillAreaStyleTiles_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FILL_AREA_STYLE_TILES(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, tiling_pattern) = param_from_chunks::<TwoDirectionRepeatFactor<'a>>(false, s, &mut i, strs)?;
        let (s, tiles) = param_from_chunks::<Vec<FillAreaStyleTileShapeSelect<'a>>>(false, s, &mut i, strs)?;
        let (s, tiling_scale) = param_from_chunks::<PositiveRatioMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            tiling_pattern,
            tiles,
            tiling_scale,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FillAreaStyleTiles_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.tiling_pattern.append_ids(_v);
        self.tiles.append_ids(_v);
        self.tiling_scale.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FillStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FillStyleSelect<'a> = Id<FillStyleSelect_<'a>>;

#[derive(Debug)]
pub struct Fillet_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Fillet<'a> = Id<Fillet_<'a>>;
impl<'a> FromEntity<'a> for Fillet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Fillet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Fillet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FILLET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Fillet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FlatnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FlatnessTolerance<'a> = Id<FlatnessTolerance_<'a>>;
impl<'a> FromEntity<'a> for FlatnessTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FlatnessTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FlatnessTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FLATNESS_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FlatnessTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FontSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FontSelect<'a> = Id<FontSelect_<'a>>;

#[derive(Debug)]
pub struct FormatFunction_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FormatFunction<'a> = Id<FormatFunction_<'a>>;
impl<'a> FromEntity<'a> for FormatFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FormatFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FormatFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FORMAT_FUNCTION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FormatFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FoundedItem_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FoundedItem<'a> = Id<FoundedItem_<'a>>;
impl<'a> FromEntity<'a> for FoundedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FoundedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FoundedItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("FOUNDED_ITEM(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FoundedItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct FoundedItemSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type FoundedItemSelect<'a> = Id<FoundedItemSelect_<'a>>;

#[derive(Debug)]
pub struct FoundedKinematicPath_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FoundedKinematicPath<'a> = Id<FoundedKinematicPath_<'a>>;
impl<'a> FromEntity<'a> for FoundedKinematicPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FoundedKinematicPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FoundedKinematicPath_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FOUNDED_KINEMATIC_PATH(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FoundedKinematicPath_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FullyConstrainedPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FullyConstrainedPair<'a> = Id<FullyConstrainedPair_<'a>>;
impl<'a> FromEntity<'a> for FullyConstrainedPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FullyConstrainedPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FullyConstrainedPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FULLY_CONSTRAINED_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FullyConstrainedPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct FunctionallyDefinedTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type FunctionallyDefinedTransformation<'a> = Id<FunctionallyDefinedTransformation_<'a>>;
impl<'a> FromEntity<'a> for FunctionallyDefinedTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::FunctionallyDefinedTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for FunctionallyDefinedTransformation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("FUNCTIONALLY_DEFINED_TRANSFORMATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for FunctionallyDefinedTransformation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GearPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub radius_first_link: LengthMeasure<'a>,
    pub radius_second_link: LengthMeasure<'a>,
    pub bevel: PlaneAngleMeasure<'a>,
    pub helical_angle: PlaneAngleMeasure<'a>,
    pub gear_ratio: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPair<'a> = Id<GearPair_<'a>>;
impl<'a> FromEntity<'a> for GearPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GearPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GearPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEAR_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, radius_first_link) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, radius_second_link) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, bevel) = param_from_chunks::<PlaneAngleMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, helical_angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, gear_ratio) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            radius_first_link,
            radius_second_link,
            bevel,
            helical_angle,
            gear_ratio,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GearPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.radius_first_link.append_ids(_v);
        self.radius_second_link.append_ids(_v);
        self.bevel.append_ids(_v);
        self.helical_angle.append_ids(_v);
        self.gear_ratio.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GearPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation_1: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPairRange<'a> = Id<GearPairRange_<'a>>;
impl<'a> FromEntity<'a> for GearPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GearPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GearPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEAR_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_rotation_1) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_rotation_1) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation_1,
            upper_limit_actual_rotation_1,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GearPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_actual_rotation_1.append_ids(_v);
        self.upper_limit_actual_rotation_1.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GearPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation_1: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GearPairValue<'a> = Id<GearPairValue_<'a>>;
impl<'a> FromEntity<'a> for GearPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GearPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GearPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEAR_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_rotation_1) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation_1,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GearPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_rotation_1.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeneralFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralFeature<'a> = Id<GeneralFeature_<'a>>;
impl<'a> FromEntity<'a> for GeneralFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeneralFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GENERAL_FEATURE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeneralFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeneralMaterialProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralMaterialProperty<'a> = Id<GeneralMaterialProperty_<'a>>;
impl<'a> FromEntity<'a> for GeneralMaterialProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralMaterialProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeneralMaterialProperty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GENERAL_MATERIAL_PROPERTY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeneralMaterialProperty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeneralProperty_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralProperty<'a> = Id<GeneralProperty_<'a>>;
impl<'a> FromEntity<'a> for GeneralProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeneralProperty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GENERAL_PROPERTY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeneralProperty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeneralPropertyAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub base_definition: GeneralProperty<'a>,
    pub derived_definition: DerivedPropertySelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralPropertyAssociation<'a> = Id<GeneralPropertyAssociation_<'a>>;
impl<'a> FromEntity<'a> for GeneralPropertyAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralPropertyAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeneralPropertyAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GENERAL_PROPERTY_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, base_definition) = param_from_chunks::<GeneralProperty<'a>>(false, s, &mut i, strs)?;
        let (s, derived_definition) = param_from_chunks::<DerivedPropertySelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            base_definition,
            derived_definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeneralPropertyAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.base_definition.append_ids(_v);
        self.derived_definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeneralPropertyRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_property: GeneralProperty<'a>,
    pub related_property: GeneralProperty<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeneralPropertyRelationship<'a> = Id<GeneralPropertyRelationship_<'a>>;
impl<'a> FromEntity<'a> for GeneralPropertyRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeneralPropertyRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeneralPropertyRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GENERAL_PROPERTY_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_property) = param_from_chunks::<GeneralProperty<'a>>(false, s, &mut i, strs)?;
        let (s, related_property) = param_from_chunks::<GeneralProperty<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_property,
            related_property,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeneralPropertyRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_property.append_ids(_v);
        self.related_property.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GenericCharacterGlyphSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericCharacterGlyphSymbol<'a> = Id<GenericCharacterGlyphSymbol_<'a>>;
impl<'a> FromEntity<'a> for GenericCharacterGlyphSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericCharacterGlyphSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GenericCharacterGlyphSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GENERIC_CHARACTER_GLYPH_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GenericCharacterGlyphSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GenericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericExpression<'a> = Id<GenericExpression_<'a>>;
impl<'a> FromEntity<'a> for GenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GenericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("GENERIC_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GenericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct GenericLiteral_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericLiteral<'a> = Id<GenericLiteral_<'a>>;
impl<'a> FromEntity<'a> for GenericLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GenericLiteral_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("GENERIC_LITERAL(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GenericLiteral_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct GenericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GenericVariable<'a> = Id<GenericVariable_<'a>>;
impl<'a> FromEntity<'a> for GenericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GenericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GenericVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("GENERIC_VARIABLE(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GenericVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct GeometricAlignment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricAlignment<'a> = Id<GeometricAlignment_<'a>>;
impl<'a> FromEntity<'a> for GeometricAlignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricAlignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricAlignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_ALIGNMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricAlignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricCurveSet_<'a> { // entity
    pub name: Label<'a>,
    pub elements: Vec<GeometricSetSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricCurveSet<'a> = Id<GeometricCurveSet_<'a>>;
impl<'a> FromEntity<'a> for GeometricCurveSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricCurveSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricCurveSet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_CURVE_SET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, elements) = param_from_chunks::<Vec<GeometricSetSelect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricCurveSet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricIntersection_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricIntersection<'a> = Id<GeometricIntersection_<'a>>;
impl<'a> FromEntity<'a> for GeometricIntersection_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricIntersection(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricIntersection_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_INTERSECTION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricIntersection_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricItemSpecificUsage_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricItemSpecificUsage<'a> = Id<GeometricItemSpecificUsage_<'a>>;
impl<'a> FromEntity<'a> for GeometricItemSpecificUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricItemSpecificUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricItemSpecificUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_ITEM_SPECIFIC_USAGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<RepresentedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, used_representation) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, identified_item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            used_representation,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricItemSpecificUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
        self.used_representation.append_ids(_v);
        self.identified_item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricRepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub coordinate_space_dimension: DimensionCount<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricRepresentationContext<'a> = Id<GeometricRepresentationContext_<'a>>;
impl<'a> FromEntity<'a> for GeometricRepresentationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricRepresentationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricRepresentationContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_REPRESENTATION_CONTEXT(")(strs[0])?;
        let (s, context_identifier) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, context_type) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, coordinate_space_dimension) = param_from_chunks::<DimensionCount<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            coordinate_space_dimension,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricRepresentationContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.context_identifier.append_ids(_v);
        self.context_type.append_ids(_v);
        self.coordinate_space_dimension.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricRepresentationItem<'a> = Id<GeometricRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for GeometricRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricRepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricRepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricSet_<'a> { // entity
    pub name: Label<'a>,
    pub elements: Vec<GeometricSetSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricSet<'a> = Id<GeometricSet_<'a>>;
impl<'a> FromEntity<'a> for GeometricSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricSet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_SET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, elements) = param_from_chunks::<Vec<GeometricSetSelect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricSet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricSetSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type GeometricSetSelect<'a> = Id<GeometricSetSelect_<'a>>;

#[derive(Debug)]
pub struct GeometricTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricTolerance<'a> = Id<GeometricTolerance_<'a>>;
impl<'a> FromEntity<'a> for GeometricTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricToleranceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_geometric_tolerance: GeometricTolerance<'a>,
    pub related_geometric_tolerance: GeometricTolerance<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceRelationship<'a> = Id<GeometricToleranceRelationship_<'a>>;
impl<'a> FromEntity<'a> for GeometricToleranceRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricToleranceRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricToleranceRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_TOLERANCE_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_geometric_tolerance) = param_from_chunks::<GeometricTolerance<'a>>(false, s, &mut i, strs)?;
        let (s, related_geometric_tolerance) = param_from_chunks::<GeometricTolerance<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_geometric_tolerance,
            related_geometric_tolerance,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricToleranceRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_geometric_tolerance.append_ids(_v);
        self.related_geometric_tolerance.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricToleranceWithDatumReference_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceWithDatumReference<'a> = Id<GeometricToleranceWithDatumReference_<'a>>;
impl<'a> FromEntity<'a> for GeometricToleranceWithDatumReference_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricToleranceWithDatumReference(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricToleranceWithDatumReference_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricToleranceWithDatumReference_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricToleranceWithDefinedUnit_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub unit_size: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricToleranceWithDefinedUnit<'a> = Id<GeometricToleranceWithDefinedUnit_<'a>>;
impl<'a> FromEntity<'a> for GeometricToleranceWithDefinedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricToleranceWithDefinedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricToleranceWithDefinedUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, unit_size) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            unit_size,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricToleranceWithDefinedUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.unit_size.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricalToleranceCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricalToleranceCallout<'a> = Id<GeometricalToleranceCallout_<'a>>;
impl<'a> FromEntity<'a> for GeometricalToleranceCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricalToleranceCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricalToleranceCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRICAL_TOLERANCE_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricalToleranceCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricallyBounded2dWireframeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBounded2dWireframeRepresentation<'a> = Id<GeometricallyBounded2dWireframeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for GeometricallyBounded2dWireframeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricallyBounded2dWireframeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricallyBounded2dWireframeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricallyBounded2dWireframeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricallyBoundedSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBoundedSurfaceShapeRepresentation<'a> = Id<GeometricallyBoundedSurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for GeometricallyBoundedSurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricallyBoundedSurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricallyBoundedSurfaceShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricallyBoundedSurfaceShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GeometricallyBoundedWireframeShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GeometricallyBoundedWireframeShapeRepresentation<'a> = Id<GeometricallyBoundedWireframeShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for GeometricallyBoundedWireframeShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GeometricallyBoundedWireframeShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GeometricallyBoundedWireframeShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GeometricallyBoundedWireframeShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GlobalUncertaintyAssignedContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GlobalUncertaintyAssignedContext<'a> = Id<GlobalUncertaintyAssignedContext_<'a>>;
impl<'a> FromEntity<'a> for GlobalUncertaintyAssignedContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GlobalUncertaintyAssignedContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GlobalUncertaintyAssignedContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT(")(strs[0])?;
        let (s, context_identifier) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, context_type) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, uncertainty) = param_from_chunks::<Vec<UncertaintyMeasureWithUnit<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            uncertainty,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GlobalUncertaintyAssignedContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.context_identifier.append_ids(_v);
        self.context_type.append_ids(_v);
        self.uncertainty.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GlobalUnitAssignedContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    pub units: Vec<Unit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GlobalUnitAssignedContext<'a> = Id<GlobalUnitAssignedContext_<'a>>;
impl<'a> FromEntity<'a> for GlobalUnitAssignedContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GlobalUnitAssignedContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GlobalUnitAssignedContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GLOBAL_UNIT_ASSIGNED_CONTEXT(")(strs[0])?;
        let (s, context_identifier) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, context_type) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, units) = param_from_chunks::<Vec<Unit<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            units,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GlobalUnitAssignedContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.context_identifier.append_ids(_v);
        self.context_type.append_ids(_v);
        self.units.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Group_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Group<'a> = Id<Group_<'a>>;
impl<'a> FromEntity<'a> for Group_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Group(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Group_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GROUP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Group_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GroupAssignment_<'a> { // entity
    pub assigned_group: Group<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GroupAssignment<'a> = Id<GroupAssignment_<'a>>;
impl<'a> FromEntity<'a> for GroupAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GroupAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GroupAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GROUP_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_group) = param_from_chunks::<Group<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_group,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GroupAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_group.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct GroupItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type GroupItem<'a> = Id<GroupItem_<'a>>;

#[derive(Debug)]
pub struct GroupRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_group: Group<'a>,
    pub related_group: Group<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type GroupRelationship<'a> = Id<GroupRelationship_<'a>>;
impl<'a> FromEntity<'a> for GroupRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::GroupRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for GroupRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("GROUP_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_group) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, related_group) = param_from_chunks::<Group<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_group,
            related_group,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for GroupRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_group.append_ids(_v);
        self.related_group.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct HalfSpaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub base_surface: Surface<'a>,
    pub agreement_flag: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HalfSpaceSolid<'a> = Id<HalfSpaceSolid_<'a>>;
impl<'a> FromEntity<'a> for HalfSpaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HalfSpaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for HalfSpaceSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("HALF_SPACE_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, base_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, agreement_flag) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            base_surface,
            agreement_flag,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for HalfSpaceSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.base_surface.append_ids(_v);
        self.agreement_flag.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct HardnessRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HardnessRepresentation<'a> = Id<HardnessRepresentation_<'a>>;
impl<'a> FromEntity<'a> for HardnessRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HardnessRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for HardnessRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("HARDNESS_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for HardnessRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct HiddenElementOverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    pub style_context: Vec<StyleContextSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HiddenElementOverRidingStyledItem<'a> = Id<HiddenElementOverRidingStyledItem_<'a>>;
impl<'a> FromEntity<'a> for HiddenElementOverRidingStyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HiddenElementOverRidingStyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for HiddenElementOverRidingStyledItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, over_ridden_style) = param_from_chunks::<StyledItem<'a>>(false, s, &mut i, strs)?;
        let (s, style_context) = param_from_chunks::<Vec<StyleContextSelect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            over_ridden_style,
            style_context,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for HiddenElementOverRidingStyledItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.over_ridden_style.append_ids(_v);
        self.style_context.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct HoleBottom_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HoleBottom<'a> = Id<HoleBottom_<'a>>;
impl<'a> FromEntity<'a> for HoleBottom_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HoleBottom(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for HoleBottom_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("HOLE_BOTTOM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for HoleBottom_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct HoleInPanel_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HoleInPanel<'a> = Id<HoleInPanel_<'a>>;
impl<'a> FromEntity<'a> for HoleInPanel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HoleInPanel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for HoleInPanel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("HOLE_IN_PANEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for HoleInPanel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct HomokineticPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub input_skew_angle: Option<PlaneAngleMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type HomokineticPair<'a> = Id<HomokineticPair_<'a>>;
impl<'a> FromEntity<'a> for HomokineticPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::HomokineticPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for HomokineticPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("HOMOKINETIC_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, input_skew_angle) = param_from_chunks::<Option<PlaneAngleMeasure<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            input_skew_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for HomokineticPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.input_skew_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct HourInDay<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for HourInDay<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for HourInDay<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct Hyperbola_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub semi_axis: PositiveLengthMeasure<'a>,
    pub semi_imag_axis: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Hyperbola<'a> = Id<Hyperbola_<'a>>;
impl<'a> FromEntity<'a> for Hyperbola_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Hyperbola(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Hyperbola_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("HYPERBOLA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, semi_axis) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, semi_imag_axis) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            semi_axis,
            semi_imag_axis,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Hyperbola_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.semi_axis.append_ids(_v);
        self.semi_imag_axis.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IdAttribute_<'a> { // entity
    pub attribute_value: Identifier<'a>,
    pub identified_item: IdAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdAttribute<'a> = Id<IdAttribute_<'a>>;
impl<'a> FromEntity<'a> for IdAttribute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IdAttribute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IdAttribute_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ID_ATTRIBUTE(")(strs[0])?;
        let (s, attribute_value) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, identified_item) = param_from_chunks::<IdAttributeSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            attribute_value,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IdAttribute_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.attribute_value.append_ids(_v);
        self.identified_item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IdAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type IdAttributeSelect<'a> = Id<IdAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct IdentificationAssignment_<'a> { // entity
    pub assigned_id: Identifier<'a>,
    pub role: IdentificationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdentificationAssignment<'a> = Id<IdentificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for IdentificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IdentificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IdentificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("IDENTIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<IdentificationRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_id,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IdentificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_id.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IdentificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type IdentificationItem<'a> = Id<IdentificationItem_<'a>>;

#[derive(Debug)]
pub struct IdentificationRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IdentificationRole<'a> = Id<IdentificationRole_<'a>>;
impl<'a> FromEntity<'a> for IdentificationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IdentificationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IdentificationRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("IDENTIFICATION_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IdentificationRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Identifier<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Identifier<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for Identifier<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct InclusionProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub condition: ConceptFeatureRelationshipWithCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InclusionProductConceptFeature<'a> = Id<InclusionProductConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for InclusionProductConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InclusionProductConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for InclusionProductConceptFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INCLUSION_PRODUCT_CONCEPT_FEATURE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, condition) = param_from_chunks::<ConceptFeatureRelationshipWithCondition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            condition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for InclusionProductConceptFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.condition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IndexExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IndexExpression<'a> = Id<IndexExpression_<'a>>;
impl<'a> FromEntity<'a> for IndexExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IndexExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IndexExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INDEX_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IndexExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct InitialState_<'a> { // entity
    pub applies_to_mechanism: Mechanism<'a>,
    pub pair_values: Vec<PairValue<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InitialState<'a> = Id<InitialState_<'a>>;
impl<'a> FromEntity<'a> for InitialState_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InitialState(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for InitialState_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INITIAL_STATE(")(strs[0])?;
        let (s, applies_to_mechanism) = param_from_chunks::<Mechanism<'a>>(false, s, &mut i, strs)?;
        let (s, pair_values) = param_from_chunks::<Vec<PairValue<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_mechanism,
            pair_values,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for InitialState_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_mechanism.append_ids(_v);
        self.pair_values.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct InstancedFeature_<'a> { // entity
    pub shape_aspect__name: Label<'a>,
    pub shape_aspect__description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InstancedFeature<'a> = Id<InstancedFeature_<'a>>;
impl<'a> FromEntity<'a> for InstancedFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InstancedFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for InstancedFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INSTANCED_FEATURE(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, shape_aspect__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            shape_aspect__name,
            shape_aspect__description,
            of_shape,
            product_definitional,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for InstancedFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.shape_aspect__name.append_ids(_v);
        self.shape_aspect__description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
        self.characterized_object__name.append_ids(_v);
        self.characterized_object__description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IntLiteral_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntLiteral<'a> = Id<IntLiteral_<'a>>;
impl<'a> FromEntity<'a> for IntLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IntLiteral_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INT_LITERAL(")(strs[0])?;
        let (s, the_value) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IntLiteral_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.the_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IntNumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntNumericVariable<'a> = Id<IntNumericVariable_<'a>>;
impl<'a> FromEntity<'a> for IntNumericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntNumericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IntNumericVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("INT_NUMERIC_VARIABLE(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IntNumericVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct IntValueFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntValueFunction<'a> = Id<IntValueFunction_<'a>>;
impl<'a> FromEntity<'a> for IntValueFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntValueFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IntValueFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INT_VALUE_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IntValueFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IntegerDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntegerDefinedFunction<'a> = Id<IntegerDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for IntegerDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntegerDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IntegerDefinedFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("INTEGER_DEFINED_FUNCTION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IntegerDefinedFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct InterpolatedConfigurationSequence_<'a> { // entity
    pub interpolation: Vec<ConfigurationInterpolation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type InterpolatedConfigurationSequence<'a> = Id<InterpolatedConfigurationSequence_<'a>>;
impl<'a> FromEntity<'a> for InterpolatedConfigurationSequence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::InterpolatedConfigurationSequence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for InterpolatedConfigurationSequence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INTERPOLATED_CONFIGURATION_SEQUENCE(")(strs[0])?;
        let (s, interpolation) = param_from_chunks::<Vec<ConfigurationInterpolation<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            interpolation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for InterpolatedConfigurationSequence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.interpolation.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum InterpolationType<'a> { // enum
    Undefined,
    Synchronous,
    Linear,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for InterpolationType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use InterpolationType::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "UNDEFINED" => Undefined,
            "SYNCHRONOUS" => Synchronous,
            "LINEAR" => Linear,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for InterpolationType<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct IntersectionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: ArrayVec::<PcurveOrSurface<'a>, 2>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntersectionCurve<'a> = Id<IntersectionCurve_<'a>>;
impl<'a> FromEntity<'a> for IntersectionCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntersectionCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IntersectionCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INTERSECTION_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, curve_3d) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, associated_geometry) = param_from_chunks::<ArrayVec::<PcurveOrSurface<'a>, 2>>(false, s, &mut i, strs)?;
        let (s, master_representation) = param_from_chunks::<PreferredSurfaceCurveRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IntersectionCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.curve_3d.append_ids(_v);
        self.associated_geometry.append_ids(_v);
        self.master_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct IntervalExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type IntervalExpression<'a> = Id<IntervalExpression_<'a>>;
impl<'a> FromEntity<'a> for IntervalExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::IntervalExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for IntervalExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INTERVAL_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for IntervalExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Invisibility_<'a> { // entity
    pub invisible_items: Vec<InvisibleItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Invisibility<'a> = Id<Invisibility_<'a>>;
impl<'a> FromEntity<'a> for Invisibility_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Invisibility(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Invisibility_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("INVISIBILITY(")(strs[0])?;
        let (s, invisible_items) = param_from_chunks::<Vec<InvisibleItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            invisible_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Invisibility_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.invisible_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct InvisibilityContext_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type InvisibilityContext<'a> = Id<InvisibilityContext_<'a>>;

#[derive(Debug)]
pub struct InvisibleItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type InvisibleItem<'a> = Id<InvisibleItem_<'a>>;

#[derive(Debug)]
pub struct ItemDefinedTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ItemDefinedTransformation<'a> = Id<ItemDefinedTransformation_<'a>>;
impl<'a> FromEntity<'a> for ItemDefinedTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ItemDefinedTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ItemDefinedTransformation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ITEM_DEFINED_TRANSFORMATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ItemDefinedTransformation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ItemIdentifiedRepresentationUsage_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub identified_item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ItemIdentifiedRepresentationUsage<'a> = Id<ItemIdentifiedRepresentationUsage_<'a>>;
impl<'a> FromEntity<'a> for ItemIdentifiedRepresentationUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ItemIdentifiedRepresentationUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ItemIdentifiedRepresentationUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ITEM_IDENTIFIED_REPRESENTATION_USAGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<RepresentedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, used_representation) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, identified_item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            used_representation,
            identified_item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ItemIdentifiedRepresentationUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
        self.used_representation.append_ids(_v);
        self.identified_item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Joggle_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Joggle<'a> = Id<Joggle_<'a>>;
impl<'a> FromEntity<'a> for Joggle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Joggle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Joggle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("JOGGLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Joggle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct JoggleTermination_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type JoggleTermination<'a> = Id<JoggleTermination_<'a>>;
impl<'a> FromEntity<'a> for JoggleTermination_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::JoggleTermination(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for JoggleTermination_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("JOGGLE_TERMINATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for JoggleTermination_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicAnalysisConsistency_<'a> { // entity
    pub control: KinematicControl<'a>,
    pub result: KinematicAnalysisResult<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicAnalysisConsistency<'a> = Id<KinematicAnalysisConsistency_<'a>>;
impl<'a> FromEntity<'a> for KinematicAnalysisConsistency_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicAnalysisConsistency(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicAnalysisConsistency_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_ANALYSIS_CONSISTENCY(")(strs[0])?;
        let (s, control) = param_from_chunks::<KinematicControl<'a>>(false, s, &mut i, strs)?;
        let (s, result) = param_from_chunks::<KinematicAnalysisResult<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            control,
            result,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicAnalysisConsistency_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.control.append_ids(_v);
        self.result.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicAnalysisDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicAnalysisDefinition<'a> = Id<KinematicAnalysisDefinition_<'a>>;

#[derive(Debug)]
pub struct KinematicAnalysisResult_<'a> { // entity
    pub analysed_mechanism: Mechanism<'a>,
    pub contained_kinematic_results: Vec<KinematicResult<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicAnalysisResult<'a> = Id<KinematicAnalysisResult_<'a>>;
impl<'a> FromEntity<'a> for KinematicAnalysisResult_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicAnalysisResult(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicAnalysisResult_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_ANALYSIS_RESULT(")(strs[0])?;
        let (s, analysed_mechanism) = param_from_chunks::<Mechanism<'a>>(false, s, &mut i, strs)?;
        let (s, contained_kinematic_results) = param_from_chunks::<Vec<KinematicResult<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            analysed_mechanism,
            contained_kinematic_results,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicAnalysisResult_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.analysed_mechanism.append_ids(_v);
        self.contained_kinematic_results.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicControl_<'a> { // entity
    pub controlled_mechanism: Mechanism<'a>,
    pub contained_kinematic_programs: Vec<KinematicAnalysisDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicControl<'a> = Id<KinematicControl_<'a>>;
impl<'a> FromEntity<'a> for KinematicControl_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicControl(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicControl_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_CONTROL(")(strs[0])?;
        let (s, controlled_mechanism) = param_from_chunks::<Mechanism<'a>>(false, s, &mut i, strs)?;
        let (s, contained_kinematic_programs) = param_from_chunks::<Vec<KinematicAnalysisDefinition<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            controlled_mechanism,
            contained_kinematic_programs,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicControl_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.controlled_mechanism.append_ids(_v);
        self.contained_kinematic_programs.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicFrameBackground_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicFrameBackground<'a> = Id<KinematicFrameBackground_<'a>>;

#[derive(Debug)]
pub struct KinematicFrameBackgroundRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBackgroundRepresentation<'a> = Id<KinematicFrameBackgroundRepresentation_<'a>>;
impl<'a> FromEntity<'a> for KinematicFrameBackgroundRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicFrameBackgroundRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicFrameBackgroundRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_FRAME_BACKGROUND_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicFrameBackgroundRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicFrameBackgroundRepresentationAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBackgroundRepresentationAssociation<'a> = Id<KinematicFrameBackgroundRepresentationAssociation_<'a>>;
impl<'a> FromEntity<'a> for KinematicFrameBackgroundRepresentationAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicFrameBackgroundRepresentationAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicFrameBackgroundRepresentationAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, transformation_operator) = param_from_chunks::<Transformation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            transformation_operator,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicFrameBackgroundRepresentationAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
        self.transformation_operator.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct KinematicFrameBasedTransformation_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub functionally_defined_transformation__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transformator: RigidPlacement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicFrameBasedTransformation<'a> = Id<KinematicFrameBasedTransformation_<'a>>;
impl<'a> FromEntity<'a> for KinematicFrameBasedTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicFrameBasedTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicFrameBasedTransformation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_FRAME_BASED_TRANSFORMATION(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, functionally_defined_transformation__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transformator) = param_from_chunks::<RigidPlacement<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            functionally_defined_transformation__name,
            description,
            transformator,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicFrameBasedTransformation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.functionally_defined_transformation__name.append_ids(_v);
        self.description.append_ids(_v);
        self.transformator.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicGroundRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicGroundRepresentation<'a> = Id<KinematicGroundRepresentation_<'a>>;
impl<'a> FromEntity<'a> for KinematicGroundRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicGroundRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicGroundRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_GROUND_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicGroundRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicJoint_<'a> { // entity
    pub first_link: KinematicLink<'a>,
    pub second_link: KinematicLink<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicJoint<'a> = Id<KinematicJoint_<'a>>;
impl<'a> FromEntity<'a> for KinematicJoint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicJoint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicJoint_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_JOINT(")(strs[0])?;
        let (s, first_link) = param_from_chunks::<KinematicLink<'a>>(false, s, &mut i, strs)?;
        let (s, second_link) = param_from_chunks::<KinematicLink<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            first_link,
            second_link,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicJoint_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.first_link.append_ids(_v);
        self.second_link.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicLink_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLink<'a> = Id<KinematicLink_<'a>>;
impl<'a> FromEntity<'a> for KinematicLink_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLink(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicLink_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("KINEMATIC_LINK(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicLink_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct KinematicLinkRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentation<'a> = Id<KinematicLinkRepresentation_<'a>>;
impl<'a> FromEntity<'a> for KinematicLinkRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLinkRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicLinkRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_LINK_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicLinkRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicLinkRepresentationAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentationAssociation<'a> = Id<KinematicLinkRepresentationAssociation_<'a>>;
impl<'a> FromEntity<'a> for KinematicLinkRepresentationAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLinkRepresentationAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicLinkRepresentationAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_LINK_REPRESENTATION_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicLinkRepresentationAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicLinkRepresentationRelation_<'a> { // entity
    pub topological_aspects: KinematicLink<'a>,
    pub geometric_aspects: KinematicLinkRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicLinkRepresentationRelation<'a> = Id<KinematicLinkRepresentationRelation_<'a>>;
impl<'a> FromEntity<'a> for KinematicLinkRepresentationRelation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicLinkRepresentationRelation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicLinkRepresentationRelation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_LINK_REPRESENTATION_RELATION(")(strs[0])?;
        let (s, topological_aspects) = param_from_chunks::<KinematicLink<'a>>(false, s, &mut i, strs)?;
        let (s, geometric_aspects) = param_from_chunks::<KinematicLinkRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            topological_aspects,
            geometric_aspects,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicLinkRepresentationRelation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.topological_aspects.append_ids(_v);
        self.geometric_aspects.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPair<'a> = Id<KinematicPair_<'a>>;
impl<'a> FromEntity<'a> for KinematicPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicPath_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPath<'a> = Id<KinematicPath_<'a>>;
impl<'a> FromEntity<'a> for KinematicPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicPath_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_PATH(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicPath_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicPropertyDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    pub ground_definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPropertyDefinition<'a> = Id<KinematicPropertyDefinition_<'a>>;
impl<'a> FromEntity<'a> for KinematicPropertyDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPropertyDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicPropertyDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_PROPERTY_DEFINITION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<CharacterizedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, ground_definition) = param_from_chunks::<CharacterizedDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            ground_definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicPropertyDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
        self.ground_definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicPropertyRepresentationRelation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicPropertyRepresentationRelation<'a> = Id<KinematicPropertyRepresentationRelation_<'a>>;
impl<'a> FromEntity<'a> for KinematicPropertyRepresentationRelation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicPropertyRepresentationRelation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicPropertyRepresentationRelation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_PROPERTY_REPRESENTATION_RELATION(")(strs[0])?;
        let (s, definition) = param_from_chunks::<RepresentedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, used_representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            definition,
            used_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicPropertyRepresentationRelation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.definition.append_ids(_v);
        self.used_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct KinematicResult_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type KinematicResult<'a> = Id<KinematicResult_<'a>>;

#[derive(Debug)]
pub struct KinematicStructure_<'a> { // entity
    pub joints: Vec<KinematicJoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KinematicStructure<'a> = Id<KinematicStructure_<'a>>;
impl<'a> FromEntity<'a> for KinematicStructure_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KinematicStructure(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KinematicStructure_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KINEMATIC_STRUCTURE(")(strs[0])?;
        let (s, joints) = param_from_chunks::<Vec<KinematicJoint<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            joints,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KinematicStructure_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.joints.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum KnotType<'a> { // enum
    UniformKnots,
    QuasiUniformKnots,
    PiecewiseBezierKnots,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for KnotType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use KnotType::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "UNIFORM_KNOTS" => UniformKnots,
            "QUASI_UNIFORM_KNOTS" => QuasiUniformKnots,
            "PIECEWISE_BEZIER_KNOTS" => PiecewiseBezierKnots,
            "UNSPECIFIED" => Unspecified,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for KnotType<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct KnownSource_<'a> { // entity
    pub source_id: SourceItem<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type KnownSource<'a> = Id<KnownSource_<'a>>;
impl<'a> FromEntity<'a> for KnownSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::KnownSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for KnownSource_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("KNOWN_SOURCE(")(strs[0])?;
        let (s, source_id) = param_from_chunks::<SourceItem<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            source_id,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for KnownSource_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.source_id.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Label<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Label<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for Label<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct Language_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Language<'a> = Id<Language_<'a>>;
impl<'a> FromEntity<'a> for Language_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Language(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Language_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LANGUAGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Language_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LanguageAssignment_<'a> { // entity
    pub assigned_class: Group<'a>,
    pub role: ClassificationRole<'a>,
    pub items: Vec<LanguageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LanguageAssignment<'a> = Id<LanguageAssignment_<'a>>;
impl<'a> FromEntity<'a> for LanguageAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LanguageAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LanguageAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LANGUAGE_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_class) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<ClassificationRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<LanguageItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_class,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LanguageAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_class.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LanguageItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type LanguageItem<'a> = Id<LanguageItem_<'a>>;

#[derive(Debug)]
pub struct LayeredItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type LayeredItem<'a> = Id<LayeredItem_<'a>>;

#[derive(Debug)]
pub struct LeaderCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderCurve<'a> = Id<LeaderCurve_<'a>>;
impl<'a> FromEntity<'a> for LeaderCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LeaderCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LEADER_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LeaderCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LeaderDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderDirectedCallout<'a> = Id<LeaderDirectedCallout_<'a>>;
impl<'a> FromEntity<'a> for LeaderDirectedCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderDirectedCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LeaderDirectedCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LEADER_DIRECTED_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LeaderDirectedCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LeaderDirectedDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderDirectedDimension<'a> = Id<LeaderDirectedDimension_<'a>>;
impl<'a> FromEntity<'a> for LeaderDirectedDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderDirectedDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LeaderDirectedDimension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LEADER_DIRECTED_DIMENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LeaderDirectedDimension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LeaderTerminator_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LeaderTerminator<'a> = Id<LeaderTerminator_<'a>>;
impl<'a> FromEntity<'a> for LeaderTerminator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LeaderTerminator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LeaderTerminator_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LEADER_TERMINATOR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, annotated_curve) = param_from_chunks::<AnnotationCurveOccurrence<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            annotated_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LeaderTerminator_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.annotated_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LengthFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthFunction<'a> = Id<LengthFunction_<'a>>;
impl<'a> FromEntity<'a> for LengthFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LengthFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LengthFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LENGTH_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LengthFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LengthMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for LengthMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct LengthMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthMeasureWithUnit<'a> = Id<LengthMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for LengthMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LengthMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LengthMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LENGTH_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LengthMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LengthUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LengthUnit<'a> = Id<LengthUnit_<'a>>;
impl<'a> FromEntity<'a> for LengthUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LengthUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LengthUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LENGTH_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LengthUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LightSource_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSource<'a> = Id<LightSource_<'a>>;
impl<'a> FromEntity<'a> for LightSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LightSource_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LIGHT_SOURCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, light_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            light_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LightSource_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.light_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LightSourceAmbient_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceAmbient<'a> = Id<LightSourceAmbient_<'a>>;
impl<'a> FromEntity<'a> for LightSourceAmbient_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourceAmbient(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LightSourceAmbient_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LIGHT_SOURCE_AMBIENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, light_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            light_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LightSourceAmbient_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.light_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LightSourceDirectional_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub orientation: Direction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceDirectional<'a> = Id<LightSourceDirectional_<'a>>;
impl<'a> FromEntity<'a> for LightSourceDirectional_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourceDirectional(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LightSourceDirectional_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LIGHT_SOURCE_DIRECTIONAL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, light_colour) = param_from_chunks::<Colour<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<Direction<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            light_colour,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LightSourceDirectional_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.light_colour.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LightSourcePositional_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub position: CartesianPoint<'a>,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourcePositional<'a> = Id<LightSourcePositional_<'a>>;
impl<'a> FromEntity<'a> for LightSourcePositional_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourcePositional(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LightSourcePositional_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LIGHT_SOURCE_POSITIONAL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, light_colour) = param_from_chunks::<Colour<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, constant_attenuation) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, distance_attenuation) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            light_colour,
            position,
            constant_attenuation,
            distance_attenuation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LightSourcePositional_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.light_colour.append_ids(_v);
        self.position.append_ids(_v);
        self.constant_attenuation.append_ids(_v);
        self.distance_attenuation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LightSourceSpot_<'a> { // entity
    pub name: Label<'a>,
    pub light_colour: Colour<'a>,
    pub position: CartesianPoint<'a>,
    pub orientation: Direction<'a>,
    pub concentration_exponent: f64,
    pub constant_attenuation: f64,
    pub distance_attenuation: f64,
    pub spread_angle: PositivePlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LightSourceSpot<'a> = Id<LightSourceSpot_<'a>>;
impl<'a> FromEntity<'a> for LightSourceSpot_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LightSourceSpot(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LightSourceSpot_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LIGHT_SOURCE_SPOT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, light_colour) = param_from_chunks::<Colour<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<Direction<'a>>(false, s, &mut i, strs)?;
        let (s, concentration_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, constant_attenuation) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, distance_attenuation) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, spread_angle) = param_from_chunks::<PositivePlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            light_colour,
            position,
            orientation,
            concentration_exponent,
            constant_attenuation,
            distance_attenuation,
            spread_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LightSourceSpot_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.light_colour.append_ids(_v);
        self.position.append_ids(_v);
        self.orientation.append_ids(_v);
        self.concentration_exponent.append_ids(_v);
        self.constant_attenuation.append_ids(_v);
        self.distance_attenuation.append_ids(_v);
        self.spread_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LikeExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LikeExpression<'a> = Id<LikeExpression_<'a>>;
impl<'a> FromEntity<'a> for LikeExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LikeExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LikeExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LIKE_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LikeExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum LimitCondition<'a> { // enum
    MaximumMaterialCondition,
    LeastMaterialCondition,
    RegardlessOfFeatureSize,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for LimitCondition<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use LimitCondition::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "MAXIMUM_MATERIAL_CONDITION" => MaximumMaterialCondition,
            "LEAST_MATERIAL_CONDITION" => LeastMaterialCondition,
            "REGARDLESS_OF_FEATURE_SIZE" => RegardlessOfFeatureSize,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for LimitCondition<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct LimitsAndFits_<'a> { // entity
    pub form_variance: Label<'a>,
    pub zone_variance: Label<'a>,
    pub grade: Label<'a>,
    pub source: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LimitsAndFits<'a> = Id<LimitsAndFits_<'a>>;
impl<'a> FromEntity<'a> for LimitsAndFits_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LimitsAndFits(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LimitsAndFits_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LIMITS_AND_FITS(")(strs[0])?;
        let (s, form_variance) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, zone_variance) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, grade) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, source) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            form_variance,
            zone_variance,
            grade,
            source,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LimitsAndFits_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.form_variance.append_ids(_v);
        self.zone_variance.append_ids(_v);
        self.grade.append_ids(_v);
        self.source.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Line_<'a> { // entity
    pub name: Label<'a>,
    pub pnt: CartesianPoint<'a>,
    pub dir: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Line<'a> = Id<Line_<'a>>;
impl<'a> FromEntity<'a> for Line_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Line(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Line_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LINE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, pnt) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, dir) = param_from_chunks::<Vector<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            pnt,
            dir,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Line_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.pnt.append_ids(_v);
        self.dir.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LineProfileTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LineProfileTolerance<'a> = Id<LineProfileTolerance_<'a>>;
impl<'a> FromEntity<'a> for LineProfileTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LineProfileTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LineProfileTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LINE_PROFILE_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LineProfileTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LinearDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LinearDimension<'a> = Id<LinearDimension_<'a>>;
impl<'a> FromEntity<'a> for LinearDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LinearDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LinearDimension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LINEAR_DIMENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LinearDimension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ListOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for ListOfReversibleTopologyItem<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        for i in &self.0 {
            i.append_ids(v);
        }
    }
}

#[derive(Debug)]
pub struct ListRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for ListRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for ListRepresentationItem<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        for i in &self.0 {
            i.append_ids(v);
        }
    }
}

#[derive(Debug)]
pub struct LiteralNumber_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LiteralNumber<'a> = Id<LiteralNumber_<'a>>;
impl<'a> FromEntity<'a> for LiteralNumber_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LiteralNumber(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LiteralNumber_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LITERAL_NUMBER(")(strs[0])?;
        let (s, the_value) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LiteralNumber_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.the_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LocalTime_<'a> { // entity
    pub hour_component: HourInDay<'a>,
    pub minute_component: Option<MinuteInHour<'a>>,
    pub second_component: Option<SecondInMinute<'a>>,
    pub zone: CoordinatedUniversalTimeOffset<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LocalTime<'a> = Id<LocalTime_<'a>>;
impl<'a> FromEntity<'a> for LocalTime_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LocalTime(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LocalTime_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOCAL_TIME(")(strs[0])?;
        let (s, hour_component) = param_from_chunks::<HourInDay<'a>>(false, s, &mut i, strs)?;
        let (s, minute_component) = param_from_chunks::<Option<MinuteInHour<'a>>>(false, s, &mut i, strs)?;
        let (s, second_component) = param_from_chunks::<Option<SecondInMinute<'a>>>(false, s, &mut i, strs)?;
        let (s, zone) = param_from_chunks::<CoordinatedUniversalTimeOffset<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            hour_component,
            minute_component,
            second_component,
            zone,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LocalTime_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.hour_component.append_ids(_v);
        self.minute_component.append_ids(_v);
        self.second_component.append_ids(_v);
        self.zone.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LocationShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LocationShapeRepresentation<'a> = Id<LocationShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for LocationShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LocationShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LocationShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOCATION_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LocationShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Locator_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Locator<'a> = Id<Locator_<'a>>;
impl<'a> FromEntity<'a> for Locator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Locator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Locator_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOCATOR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Locator_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Log10Function_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Log10Function<'a> = Id<Log10Function_<'a>>;
impl<'a> FromEntity<'a> for Log10Function_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Log10Function(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Log10Function_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOG10_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Log10Function_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Log2Function_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Log2Function<'a> = Id<Log2Function_<'a>>;
impl<'a> FromEntity<'a> for Log2Function_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Log2Function(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Log2Function_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOG2_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Log2Function_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LogFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LogFunction<'a> = Id<LogFunction_<'a>>;
impl<'a> FromEntity<'a> for LogFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LogFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LogFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOG_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LogFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Loop_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Loop<'a> = Id<Loop_<'a>>;
impl<'a> FromEntity<'a> for Loop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Loop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Loop_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOOP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Loop_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LotEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_lot_id: Identifier<'a>,
    pub effectivity_lot_size: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LotEffectivity<'a> = Id<LotEffectivity_<'a>>;
impl<'a> FromEntity<'a> for LotEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LotEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LotEffectivity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LOT_EFFECTIVITY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, effectivity_lot_id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, effectivity_lot_size) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            effectivity_lot_id,
            effectivity_lot_size,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LotEffectivity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.effectivity_lot_id.append_ids(_v);
        self.effectivity_lot_size.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LuminousIntensityMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for LuminousIntensityMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for LuminousIntensityMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct LuminousIntensityMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LuminousIntensityMeasureWithUnit<'a> = Id<LuminousIntensityMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for LuminousIntensityMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LuminousIntensityMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LuminousIntensityMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LUMINOUS_INTENSITY_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LuminousIntensityMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct LuminousIntensityUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type LuminousIntensityUnit<'a> = Id<LuminousIntensityUnit_<'a>>;
impl<'a> FromEntity<'a> for LuminousIntensityUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::LuminousIntensityUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for LuminousIntensityUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("LUMINOUS_INTENSITY_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for LuminousIntensityUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MakeFromUsageOption_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub ranking: i64,
    pub ranking_rationale: Text<'a>,
    pub quantity: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MakeFromUsageOption<'a> = Id<MakeFromUsageOption_<'a>>;
impl<'a> FromEntity<'a> for MakeFromUsageOption_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MakeFromUsageOption(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MakeFromUsageOption_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MAKE_FROM_USAGE_OPTION(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, ranking) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, ranking_rationale) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, quantity) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            ranking,
            ranking_rationale,
            quantity,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MakeFromUsageOption_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
        self.ranking.append_ids(_v);
        self.ranking_rationale.append_ids(_v);
        self.quantity.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ManifoldSolidBrep_<'a> { // entity
    pub name: Label<'a>,
    pub outer: ClosedShell<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSolidBrep<'a> = Id<ManifoldSolidBrep_<'a>>;
impl<'a> FromEntity<'a> for ManifoldSolidBrep_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ManifoldSolidBrep(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ManifoldSolidBrep_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MANIFOLD_SOLID_BREP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, outer) = param_from_chunks::<ClosedShell<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            outer,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ManifoldSolidBrep_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.outer.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ManifoldSubsurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSubsurfaceShapeRepresentation<'a> = Id<ManifoldSubsurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ManifoldSubsurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ManifoldSubsurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ManifoldSubsurfaceShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ManifoldSubsurfaceShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ManifoldSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ManifoldSurfaceShapeRepresentation<'a> = Id<ManifoldSurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ManifoldSurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ManifoldSurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ManifoldSurfaceShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MANIFOLD_SURFACE_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ManifoldSurfaceShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MappedItem_<'a> { // entity
    pub name: Label<'a>,
    pub mapping_source: RepresentationMap<'a>,
    pub mapping_target: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MappedItem<'a> = Id<MappedItem_<'a>>;
impl<'a> FromEntity<'a> for MappedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MappedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MappedItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MAPPED_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_source) = param_from_chunks::<RepresentationMap<'a>>(false, s, &mut i, strs)?;
        let (s, mapping_target) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            mapping_source,
            mapping_target,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MappedItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.mapping_source.append_ids(_v);
        self.mapping_target.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum MarkerSelect<'a> { // select
    MarkerType(MarkerType<'a>),
    PreDefinedMarker(PreDefinedMarker<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MarkerSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("MARKER_TYPE("), <MarkerType<'a>>::parse, char(')')), MarkerSelect::MarkerType),
            map(<PreDefinedMarker<'a>>::parse, MarkerSelect::PreDefinedMarker),
        ))(s)
    }
}
impl<'a> HasId for MarkerSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            MarkerSelect::MarkerType(c) => c.append_ids(_v),
            MarkerSelect::PreDefinedMarker(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub enum MarkerType<'a> { // enum
    Dot,
    X,
    Plus,
    Asterisk,
    Ring,
    Square,
    Triangle,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for MarkerType<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use MarkerType::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "DOT" => Dot,
            "X" => X,
            "PLUS" => Plus,
            "ASTERISK" => Asterisk,
            "RING" => Ring,
            "SQUARE" => Square,
            "TRIANGLE" => Triangle,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for MarkerType<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct MassMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MassMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for MassMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct MassMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MassMeasureWithUnit<'a> = Id<MassMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for MassMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MassMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MassMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MASS_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MassMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MassUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MassUnit<'a> = Id<MassUnit_<'a>>;
impl<'a> FromEntity<'a> for MassUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MassUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MassUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MASS_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MassUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MaterialDesignation_<'a> { // entity
    pub name: Label<'a>,
    pub definitions: Vec<CharacterizedDefinition<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialDesignation<'a> = Id<MaterialDesignation_<'a>>;
impl<'a> FromEntity<'a> for MaterialDesignation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialDesignation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MaterialDesignation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MATERIAL_DESIGNATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, definitions) = param_from_chunks::<Vec<CharacterizedDefinition<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            definitions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MaterialDesignation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.definitions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MaterialDesignationCharacterization_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub designation: MaterialDesignation<'a>,
    pub property: CharacterizedMaterialProperty<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialDesignationCharacterization<'a> = Id<MaterialDesignationCharacterization_<'a>>;
impl<'a> FromEntity<'a> for MaterialDesignationCharacterization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialDesignationCharacterization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MaterialDesignationCharacterization_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MATERIAL_DESIGNATION_CHARACTERIZATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, designation) = param_from_chunks::<MaterialDesignation<'a>>(false, s, &mut i, strs)?;
        let (s, property) = param_from_chunks::<CharacterizedMaterialProperty<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            designation,
            property,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MaterialDesignationCharacterization_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.designation.append_ids(_v);
        self.property.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MaterialProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialProperty<'a> = Id<MaterialProperty_<'a>>;
impl<'a> FromEntity<'a> for MaterialProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MaterialProperty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MATERIAL_PROPERTY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<CharacterizedDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MaterialProperty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MaterialPropertyRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    pub dependent_environment: DataEnvironment<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaterialPropertyRepresentation<'a> = Id<MaterialPropertyRepresentation_<'a>>;
impl<'a> FromEntity<'a> for MaterialPropertyRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaterialPropertyRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MaterialPropertyRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MATERIAL_PROPERTY_REPRESENTATION(")(strs[0])?;
        let (s, definition) = param_from_chunks::<RepresentedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, used_representation) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, dependent_environment) = param_from_chunks::<DataEnvironment<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            definition,
            used_representation,
            dependent_environment,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MaterialPropertyRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.definition.append_ids(_v);
        self.used_representation.append_ids(_v);
        self.dependent_environment.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MaximumFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MaximumFunction<'a> = Id<MaximumFunction_<'a>>;
impl<'a> FromEntity<'a> for MaximumFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MaximumFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MaximumFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MAXIMUM_FUNCTION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MaximumFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MeasureQualification_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub qualified_measure: MeasureWithUnit<'a>,
    pub qualifiers: Vec<ValueQualifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureQualification<'a> = Id<MeasureQualification_<'a>>;
impl<'a> FromEntity<'a> for MeasureQualification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MeasureQualification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MeasureQualification_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MEASURE_QUALIFICATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, qualified_measure) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, qualifiers) = param_from_chunks::<Vec<ValueQualifier<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            qualified_measure,
            qualifiers,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MeasureQualification_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.qualified_measure.append_ids(_v);
        self.qualifiers.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MeasureRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureRepresentationItem<'a> = Id<MeasureRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for MeasureRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MeasureRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MeasureRepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MEASURE_REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MeasureRepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum MeasureValue<'a> { // select
    AmountOfSubstanceMeasure(AmountOfSubstanceMeasure<'a>),
    AreaMeasure(AreaMeasure<'a>),
    CelsiusTemperatureMeasure(CelsiusTemperatureMeasure<'a>),
    ContextDependentMeasure(ContextDependentMeasure<'a>),
    CountMeasure(CountMeasure<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    ElectricCurrentMeasure(ElectricCurrentMeasure<'a>),
    LengthMeasure(LengthMeasure<'a>),
    LuminousIntensityMeasure(LuminousIntensityMeasure<'a>),
    MassMeasure(MassMeasure<'a>),
    NumericMeasure(NumericMeasure<'a>),
    NonNegativeLengthMeasure(NonNegativeLengthMeasure<'a>),
    ParameterValue(ParameterValue<'a>),
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    PositivePlaneAngleMeasure(PositivePlaneAngleMeasure<'a>),
    PositiveRatioMeasure(PositiveRatioMeasure<'a>),
    RatioMeasure(RatioMeasure<'a>),
    SolidAngleMeasure(SolidAngleMeasure<'a>),
    ThermodynamicTemperatureMeasure(ThermodynamicTemperatureMeasure<'a>),
    TimeMeasure(TimeMeasure<'a>),
    VolumeMeasure(VolumeMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MeasureValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("AMOUNT_OF_SUBSTANCE_MEASURE("), <AmountOfSubstanceMeasure<'a>>::parse, char(')')), MeasureValue::AmountOfSubstanceMeasure),
            map(delimited(tag("AREA_MEASURE("), <AreaMeasure<'a>>::parse, char(')')), MeasureValue::AreaMeasure),
            map(delimited(tag("CELSIUS_TEMPERATURE_MEASURE("), <CelsiusTemperatureMeasure<'a>>::parse, char(')')), MeasureValue::CelsiusTemperatureMeasure),
            map(delimited(tag("CONTEXT_DEPENDENT_MEASURE("), <ContextDependentMeasure<'a>>::parse, char(')')), MeasureValue::ContextDependentMeasure),
            map(delimited(tag("COUNT_MEASURE("), <CountMeasure<'a>>::parse, char(')')), MeasureValue::CountMeasure),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), MeasureValue::DescriptiveMeasure),
            map(delimited(tag("ELECTRIC_CURRENT_MEASURE("), <ElectricCurrentMeasure<'a>>::parse, char(')')), MeasureValue::ElectricCurrentMeasure),
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), MeasureValue::LengthMeasure),
            map(delimited(tag("LUMINOUS_INTENSITY_MEASURE("), <LuminousIntensityMeasure<'a>>::parse, char(')')), MeasureValue::LuminousIntensityMeasure),
            map(delimited(tag("MASS_MEASURE("), <MassMeasure<'a>>::parse, char(')')), MeasureValue::MassMeasure),
            map(delimited(tag("NUMERIC_MEASURE("), <NumericMeasure<'a>>::parse, char(')')), MeasureValue::NumericMeasure),
            map(delimited(tag("NON_NEGATIVE_LENGTH_MEASURE("), <NonNegativeLengthMeasure<'a>>::parse, char(')')), MeasureValue::NonNegativeLengthMeasure),
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), MeasureValue::ParameterValue),
            map(delimited(tag("PLANE_ANGLE_MEASURE("), <PlaneAngleMeasure<'a>>::parse, char(')')), MeasureValue::PlaneAngleMeasure),
            map(delimited(tag("POSITIVE_LENGTH_MEASURE("), <PositiveLengthMeasure<'a>>::parse, char(')')), MeasureValue::PositiveLengthMeasure),
            map(delimited(tag("POSITIVE_PLANE_ANGLE_MEASURE("), <PositivePlaneAngleMeasure<'a>>::parse, char(')')), MeasureValue::PositivePlaneAngleMeasure),
            map(delimited(tag("POSITIVE_RATIO_MEASURE("), <PositiveRatioMeasure<'a>>::parse, char(')')), MeasureValue::PositiveRatioMeasure),
            map(delimited(tag("RATIO_MEASURE("), <RatioMeasure<'a>>::parse, char(')')), MeasureValue::RatioMeasure),
            map(delimited(tag("SOLID_ANGLE_MEASURE("), <SolidAngleMeasure<'a>>::parse, char(')')), MeasureValue::SolidAngleMeasure),
        alt((
            map(delimited(tag("THERMODYNAMIC_TEMPERATURE_MEASURE("), <ThermodynamicTemperatureMeasure<'a>>::parse, char(')')), MeasureValue::ThermodynamicTemperatureMeasure),
            map(delimited(tag("TIME_MEASURE("), <TimeMeasure<'a>>::parse, char(')')), MeasureValue::TimeMeasure),
            map(delimited(tag("VOLUME_MEASURE("), <VolumeMeasure<'a>>::parse, char(')')), MeasureValue::VolumeMeasure),
        ))))(s)
    }
}
impl<'a> HasId for MeasureValue<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            MeasureValue::AmountOfSubstanceMeasure(c) => c.append_ids(_v),
            MeasureValue::AreaMeasure(c) => c.append_ids(_v),
            MeasureValue::CelsiusTemperatureMeasure(c) => c.append_ids(_v),
            MeasureValue::ContextDependentMeasure(c) => c.append_ids(_v),
            MeasureValue::CountMeasure(c) => c.append_ids(_v),
            MeasureValue::DescriptiveMeasure(c) => c.append_ids(_v),
            MeasureValue::ElectricCurrentMeasure(c) => c.append_ids(_v),
            MeasureValue::LengthMeasure(c) => c.append_ids(_v),
            MeasureValue::LuminousIntensityMeasure(c) => c.append_ids(_v),
            MeasureValue::MassMeasure(c) => c.append_ids(_v),
            MeasureValue::NumericMeasure(c) => c.append_ids(_v),
            MeasureValue::NonNegativeLengthMeasure(c) => c.append_ids(_v),
            MeasureValue::ParameterValue(c) => c.append_ids(_v),
            MeasureValue::PlaneAngleMeasure(c) => c.append_ids(_v),
            MeasureValue::PositiveLengthMeasure(c) => c.append_ids(_v),
            MeasureValue::PositivePlaneAngleMeasure(c) => c.append_ids(_v),
            MeasureValue::PositiveRatioMeasure(c) => c.append_ids(_v),
            MeasureValue::RatioMeasure(c) => c.append_ids(_v),
            MeasureValue::SolidAngleMeasure(c) => c.append_ids(_v),
            MeasureValue::ThermodynamicTemperatureMeasure(c) => c.append_ids(_v),
            MeasureValue::TimeMeasure(c) => c.append_ids(_v),
            MeasureValue::VolumeMeasure(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct MeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MeasureWithUnit<'a> = Id<MeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for MeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MechanicalDesignGeometricPresentationArea_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanicalDesignGeometricPresentationArea<'a> = Id<MechanicalDesignGeometricPresentationArea_<'a>>;
impl<'a> FromEntity<'a> for MechanicalDesignGeometricPresentationArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MechanicalDesignGeometricPresentationArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MechanicalDesignGeometricPresentationArea_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MechanicalDesignGeometricPresentationArea_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MechanicalDesignGeometricPresentationRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanicalDesignGeometricPresentationRepresentation<'a> = Id<MechanicalDesignGeometricPresentationRepresentation_<'a>>;
impl<'a> FromEntity<'a> for MechanicalDesignGeometricPresentationRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MechanicalDesignGeometricPresentationRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MechanicalDesignGeometricPresentationRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MechanicalDesignGeometricPresentationRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Mechanism_<'a> { // entity
    pub structure_definition: KinematicStructure<'a>,
    pub base: KinematicLink<'a>,
    pub containing_property: KinematicPropertyDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Mechanism<'a> = Id<Mechanism_<'a>>;
impl<'a> FromEntity<'a> for Mechanism_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Mechanism(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Mechanism_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MECHANISM(")(strs[0])?;
        let (s, structure_definition) = param_from_chunks::<KinematicStructure<'a>>(false, s, &mut i, strs)?;
        let (s, base) = param_from_chunks::<KinematicLink<'a>>(false, s, &mut i, strs)?;
        let (s, containing_property) = param_from_chunks::<KinematicPropertyDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            structure_definition,
            base,
            containing_property,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Mechanism_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.structure_definition.append_ids(_v);
        self.base.append_ids(_v);
        self.containing_property.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MechanismBasePlacement_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    pub base_of_mechanism: Mechanism<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MechanismBasePlacement<'a> = Id<MechanismBasePlacement_<'a>>;
impl<'a> FromEntity<'a> for MechanismBasePlacement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MechanismBasePlacement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MechanismBasePlacement_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MECHANISM_BASE_PLACEMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, transformation_operator) = param_from_chunks::<Transformation<'a>>(false, s, &mut i, strs)?;
        let (s, base_of_mechanism) = param_from_chunks::<Mechanism<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            transformation_operator,
            base_of_mechanism,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MechanismBasePlacement_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.transformation_operator.append_ids(_v);
        self.base_of_mechanism.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MinimumFunction_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinimumFunction<'a> = Id<MinimumFunction_<'a>>;
impl<'a> FromEntity<'a> for MinimumFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MinimumFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MinimumFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MINIMUM_FUNCTION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MinimumFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MinusExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinusExpression<'a> = Id<MinusExpression_<'a>>;
impl<'a> FromEntity<'a> for MinusExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MinusExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MinusExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MINUS_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MinusExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MinusFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MinusFunction<'a> = Id<MinusFunction_<'a>>;
impl<'a> FromEntity<'a> for MinusFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MinusFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MinusFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MINUS_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MinusFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MinuteInHour<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MinuteInHour<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for MinuteInHour<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct ModExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModExpression<'a> = Id<ModExpression_<'a>>;
impl<'a> FromEntity<'a> for ModExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ModExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ModExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MOD_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ModExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ModifiedGeometricTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub modifier: LimitCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModifiedGeometricTolerance<'a> = Id<ModifiedGeometricTolerance_<'a>>;
impl<'a> FromEntity<'a> for ModifiedGeometricTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ModifiedGeometricTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ModifiedGeometricTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MODIFIED_GEOMETRIC_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, modifier) = param_from_chunks::<LimitCondition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            modifier,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ModifiedGeometricTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.modifier.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ModifiedPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ModifiedPattern<'a> = Id<ModifiedPattern_<'a>>;
impl<'a> FromEntity<'a> for ModifiedPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ModifiedPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ModifiedPattern_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MODIFIED_PATTERN(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ModifiedPattern_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MomentsOfInertiaRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MomentsOfInertiaRepresentation<'a> = Id<MomentsOfInertiaRepresentation_<'a>>;
impl<'a> FromEntity<'a> for MomentsOfInertiaRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MomentsOfInertiaRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MomentsOfInertiaRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MOMENTS_OF_INERTIA_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MomentsOfInertiaRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MonthInYearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for MonthInYearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for MonthInYearNumber<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct MotionLinkRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub related_frame: RigidPlacement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MotionLinkRelationship<'a> = Id<MotionLinkRelationship_<'a>>;
impl<'a> FromEntity<'a> for MotionLinkRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MotionLinkRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MotionLinkRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MOTION_LINK_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, related_frame) = param_from_chunks::<RigidPlacement<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            related_frame,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MotionLinkRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
        self.related_frame.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum MotionParameterMeasure<'a> { // select
    ParameterValue(ParameterValue<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for MotionParameterMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), MotionParameterMeasure::ParameterValue),
            map(<MeasureWithUnit<'a>>::parse, MotionParameterMeasure::MeasureWithUnit),
        ))(s)
    }
}
impl<'a> HasId for MotionParameterMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            MotionParameterMeasure::ParameterValue(c) => c.append_ids(_v),
            MotionParameterMeasure::MeasureWithUnit(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct MultExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultExpression<'a> = Id<MultExpression_<'a>>;
impl<'a> FromEntity<'a> for MultExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MultExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MULT_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MultExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MultiLanguageAttributeAssignment_<'a> { // entity
    pub attribute_name: Label<'a>,
    pub attribute_value: AttributeType<'a>,
    pub role: AttributeValueRole<'a>,
    pub items: Vec<MultiLanguageAttributeItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultiLanguageAttributeAssignment<'a> = Id<MultiLanguageAttributeAssignment_<'a>>;
impl<'a> FromEntity<'a> for MultiLanguageAttributeAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultiLanguageAttributeAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MultiLanguageAttributeAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT(")(strs[0])?;
        let (s, attribute_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, attribute_value) = param_from_chunks::<AttributeType<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<AttributeValueRole<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<MultiLanguageAttributeItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            attribute_name,
            attribute_value,
            role,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MultiLanguageAttributeAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.attribute_name.append_ids(_v);
        self.attribute_value.append_ids(_v);
        self.role.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MultiLanguageAttributeItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type MultiLanguageAttributeItem<'a> = Id<MultiLanguageAttributeItem_<'a>>;

#[derive(Debug)]
pub struct MultipleArityBooleanExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityBooleanExpression<'a> = Id<MultipleArityBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MultipleArityBooleanExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MULTIPLE_ARITY_BOOLEAN_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MultipleArityBooleanExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MultipleArityFunctionCall_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityFunctionCall<'a> = Id<MultipleArityFunctionCall_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityFunctionCall_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityFunctionCall(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MultipleArityFunctionCall_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MULTIPLE_ARITY_FUNCTION_CALL(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MultipleArityFunctionCall_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MultipleArityGenericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityGenericExpression<'a> = Id<MultipleArityGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MultipleArityGenericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MULTIPLE_ARITY_GENERIC_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MultipleArityGenericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct MultipleArityNumericExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type MultipleArityNumericExpression<'a> = Id<MultipleArityNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for MultipleArityNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::MultipleArityNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for MultipleArityNumericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("MULTIPLE_ARITY_NUMERIC_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for MultipleArityNumericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct NameAssignment_<'a> { // entity
    pub assigned_name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NameAssignment<'a> = Id<NameAssignment_<'a>>;
impl<'a> FromEntity<'a> for NameAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NameAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NameAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NAME_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NameAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct NameAttribute_<'a> { // entity
    pub attribute_value: Label<'a>,
    pub named_item: NameAttributeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NameAttribute<'a> = Id<NameAttribute_<'a>>;
impl<'a> FromEntity<'a> for NameAttribute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NameAttribute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NameAttribute_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NAME_ATTRIBUTE(")(strs[0])?;
        let (s, attribute_value) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, named_item) = param_from_chunks::<NameAttributeSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            attribute_value,
            named_item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NameAttribute_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.attribute_value.append_ids(_v);
        self.named_item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct NameAttributeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type NameAttributeSelect<'a> = Id<NameAttributeSelect_<'a>>;

#[derive(Debug)]
pub struct NameItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type NameItem<'a> = Id<NameItem_<'a>>;

#[derive(Debug)]
pub struct NamedUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NamedUnit<'a> = Id<NamedUnit_<'a>>;
impl<'a> FromEntity<'a> for NamedUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NamedUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NamedUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NAMED_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NamedUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct NamedUnitVariable_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NamedUnitVariable<'a> = Id<NamedUnitVariable_<'a>>;
impl<'a> FromEntity<'a> for NamedUnitVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NamedUnitVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NamedUnitVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NAMED_UNIT_VARIABLE(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NamedUnitVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct NextAssemblyUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NextAssemblyUsageOccurrence<'a> = Id<NextAssemblyUsageOccurrence_<'a>>;
impl<'a> FromEntity<'a> for NextAssemblyUsageOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NextAssemblyUsageOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NextAssemblyUsageOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NEXT_ASSEMBLY_USAGE_OCCURRENCE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, reference_designator) = param_from_chunks::<Option<Identifier<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NextAssemblyUsageOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
        self.reference_designator.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct NgonClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NgonClosedProfile<'a> = Id<NgonClosedProfile_<'a>>;
impl<'a> FromEntity<'a> for NgonClosedProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NgonClosedProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NgonClosedProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NGON_CLOSED_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NgonClosedProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct NonManifoldSurfaceShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NonManifoldSurfaceShapeRepresentation<'a> = Id<NonManifoldSurfaceShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for NonManifoldSurfaceShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NonManifoldSurfaceShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NonManifoldSurfaceShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NonManifoldSurfaceShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}

#[derive(Debug)]
pub struct NonNegativeLengthMeasure<'a>(pub LengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for NonNegativeLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(LengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for NonNegativeLengthMeasure<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}

#[derive(Debug)]
pub struct NotExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NotExpression<'a> = Id<NotExpression_<'a>>;
impl<'a> FromEntity<'a> for NotExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NotExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NotExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("NOT_EXPRESSION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NotExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum NullStyle<'a> { // enum
    Null,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for NullStyle<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use NullStyle::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "NULL" => Null,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for NullStyle<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct NumericDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericDefinedFunction<'a> = Id<NumericDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for NumericDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NumericDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NumericDefinedFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("NUMERIC_DEFINED_FUNCTION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NumericDefinedFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct NumericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericExpression<'a> = Id<NumericExpression_<'a>>;
impl<'a> FromEntity<'a> for NumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NumericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("NUMERIC_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NumericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct NumericMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for NumericMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for NumericMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct NumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type NumericVariable<'a> = Id<NumericVariable_<'a>>;
impl<'a> FromEntity<'a> for NumericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::NumericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for NumericVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("NUMERIC_VARIABLE(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for NumericVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct ObjectRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ObjectRole<'a> = Id<ObjectRole_<'a>>;
impl<'a> FromEntity<'a> for ObjectRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ObjectRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ObjectRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OBJECT_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ObjectRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OddFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OddFunction<'a> = Id<OddFunction_<'a>>;
impl<'a> FromEntity<'a> for OddFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OddFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OddFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ODD_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OddFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OffsetCurve2d_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetCurve2d<'a> = Id<OffsetCurve2d_<'a>>;
impl<'a> FromEntity<'a> for OffsetCurve2d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OffsetCurve2d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OffsetCurve2d_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OFFSET_CURVE_2D(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, distance) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_curve,
            distance,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OffsetCurve2d_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_curve.append_ids(_v);
        self.distance.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OffsetCurve3d_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Logical,
    pub ref_direction: Direction<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetCurve3d<'a> = Id<OffsetCurve3d_<'a>>;
impl<'a> FromEntity<'a> for OffsetCurve3d_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OffsetCurve3d(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OffsetCurve3d_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OFFSET_CURVE_3D(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, distance) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, ref_direction) = param_from_chunks::<Direction<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_curve,
            distance,
            self_intersect,
            ref_direction,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OffsetCurve3d_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_curve.append_ids(_v);
        self.distance.append_ids(_v);
        self.self_intersect.append_ids(_v);
        self.ref_direction.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OffsetSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub distance: LengthMeasure<'a>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OffsetSurface<'a> = Id<OffsetSurface_<'a>>;
impl<'a> FromEntity<'a> for OffsetSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OffsetSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OffsetSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OFFSET_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, distance) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_surface,
            distance,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OffsetSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.distance.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OneDirectionRepeatFactor_<'a> { // entity
    pub name: Label<'a>,
    pub repeat_factor: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OneDirectionRepeatFactor<'a> = Id<OneDirectionRepeatFactor_<'a>>;
impl<'a> FromEntity<'a> for OneDirectionRepeatFactor_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OneDirectionRepeatFactor(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OneDirectionRepeatFactor_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ONE_DIRECTION_REPEAT_FACTOR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, repeat_factor) = param_from_chunks::<Vector<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            repeat_factor,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OneDirectionRepeatFactor_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.repeat_factor.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OpenPathProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OpenPathProfile<'a> = Id<OpenPathProfile_<'a>>;
impl<'a> FromEntity<'a> for OpenPathProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OpenPathProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OpenPathProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OPEN_PATH_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OpenPathProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OpenShell_<'a> { // entity
    pub name: Label<'a>,
    pub cfs_faces: Vec<Face<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OpenShell<'a> = Id<OpenShell_<'a>>;
impl<'a> FromEntity<'a> for OpenShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OpenShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OpenShell_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OPEN_SHELL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, cfs_faces) = param_from_chunks::<Vec<Face<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            cfs_faces,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OpenShell_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.cfs_faces.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrExpression<'a> = Id<OrExpression_<'a>>;
impl<'a> FromEntity<'a> for OrExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OR_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrdinateDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrdinateDimension<'a> = Id<OrdinateDimension_<'a>>;
impl<'a> FromEntity<'a> for OrdinateDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrdinateDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrdinateDimension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORDINATE_DIMENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrdinateDimension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Organization_<'a> { // entity
    pub id: Option<Identifier<'a>>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Organization<'a> = Id<Organization_<'a>>;
impl<'a> FromEntity<'a> for Organization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Organization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Organization_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATION(")(strs[0])?;
        let (s, id) = param_from_chunks::<Option<Identifier<'a>>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Organization_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationAssignment_<'a> { // entity
    pub assigned_organization: Organization<'a>,
    pub role: OrganizationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationAssignment<'a> = Id<OrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for OrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_organization) = param_from_chunks::<Organization<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<OrganizationRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_organization,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_organization.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type OrganizationItem<'a> = Id<OrganizationItem_<'a>>;

#[derive(Debug)]
pub struct OrganizationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_organization: Organization<'a>,
    pub related_organization: Organization<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationRelationship<'a> = Id<OrganizationRelationship_<'a>>;
impl<'a> FromEntity<'a> for OrganizationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATION_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_organization) = param_from_chunks::<Organization<'a>>(false, s, &mut i, strs)?;
        let (s, related_organization) = param_from_chunks::<Organization<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_organization,
            related_organization,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_organization.append_ids(_v);
        self.related_organization.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationRole<'a> = Id<OrganizationRole_<'a>>;
impl<'a> FromEntity<'a> for OrganizationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATION_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationalAddress_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    pub organizations: Vec<Organization<'a>>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalAddress<'a> = Id<OrganizationalAddress_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalAddress_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalAddress(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationalAddress_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATIONAL_ADDRESS(")(strs[0])?;
        let (s, internal_location) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, street_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, street) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, postal_box) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, town) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, region) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, postal_code) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, country) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, facsimile_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, telephone_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, electronic_mail_address) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, telex_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, organizations) = param_from_chunks::<Vec<Organization<'a>>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            internal_location,
            street_number,
            street,
            postal_box,
            town,
            region,
            postal_code,
            country,
            facsimile_number,
            telephone_number,
            electronic_mail_address,
            telex_number,
            organizations,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationalAddress_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.internal_location.append_ids(_v);
        self.street_number.append_ids(_v);
        self.street.append_ids(_v);
        self.postal_box.append_ids(_v);
        self.town.append_ids(_v);
        self.region.append_ids(_v);
        self.postal_code.append_ids(_v);
        self.country.append_ids(_v);
        self.facsimile_number.append_ids(_v);
        self.telephone_number.append_ids(_v);
        self.electronic_mail_address.append_ids(_v);
        self.telex_number.append_ids(_v);
        self.organizations.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationalProject_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub responsible_organizations: Vec<Organization<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProject<'a> = Id<OrganizationalProject_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProject_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProject(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationalProject_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATIONAL_PROJECT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, responsible_organizations) = param_from_chunks::<Vec<Organization<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            responsible_organizations,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationalProject_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.responsible_organizations.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationalProjectAssignment_<'a> { // entity
    pub assigned_organizational_project: OrganizationalProject<'a>,
    pub role: OrganizationalProjectRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectAssignment<'a> = Id<OrganizationalProjectAssignment_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProjectAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProjectAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationalProjectAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATIONAL_PROJECT_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_organizational_project) = param_from_chunks::<OrganizationalProject<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<OrganizationalProjectRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_organizational_project,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationalProjectAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_organizational_project.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationalProjectItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type OrganizationalProjectItem<'a> = Id<OrganizationalProjectItem_<'a>>;

#[derive(Debug)]
pub struct OrganizationalProjectRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_organizational_project: OrganizationalProject<'a>,
    pub related_organizational_project: OrganizationalProject<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectRelationship<'a> = Id<OrganizationalProjectRelationship_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProjectRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProjectRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationalProjectRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATIONAL_PROJECT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_organizational_project) = param_from_chunks::<OrganizationalProject<'a>>(false, s, &mut i, strs)?;
        let (s, related_organizational_project) = param_from_chunks::<OrganizationalProject<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_organizational_project,
            related_organizational_project,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationalProjectRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_organizational_project.append_ids(_v);
        self.related_organizational_project.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrganizationalProjectRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrganizationalProjectRole<'a> = Id<OrganizationalProjectRole_<'a>>;
impl<'a> FromEntity<'a> for OrganizationalProjectRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrganizationalProjectRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrganizationalProjectRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORGANIZATIONAL_PROJECT_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrganizationalProjectRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrientedClosedShell_<'a> { // entity
    pub name: Label<'a>,
    pub closed_shell_element: ClosedShell<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedClosedShell<'a> = Id<OrientedClosedShell_<'a>>;
impl<'a> FromEntity<'a> for OrientedClosedShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedClosedShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrientedClosedShell_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORIENTED_CLOSED_SHELL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, closed_shell_element) = param_from_chunks::<ClosedShell<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            closed_shell_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrientedClosedShell_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.closed_shell_element.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrientedEdge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_element: Edge<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedEdge<'a> = Id<OrientedEdge_<'a>>;
impl<'a> FromEntity<'a> for OrientedEdge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedEdge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrientedEdge_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORIENTED_EDGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, edge_element) = param_from_chunks::<Edge<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            edge_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrientedEdge_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.edge_element.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrientedFace_<'a> { // entity
    pub name: Label<'a>,
    pub face_element: Face<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedFace<'a> = Id<OrientedFace_<'a>>;
impl<'a> FromEntity<'a> for OrientedFace_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedFace(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrientedFace_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORIENTED_FACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, face_element) = param_from_chunks::<Face<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            face_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrientedFace_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.face_element.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrientedOpenShell_<'a> { // entity
    pub name: Label<'a>,
    pub open_shell_element: OpenShell<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedOpenShell<'a> = Id<OrientedOpenShell_<'a>>;
impl<'a> FromEntity<'a> for OrientedOpenShell_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedOpenShell(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrientedOpenShell_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORIENTED_OPEN_SHELL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, open_shell_element) = param_from_chunks::<OpenShell<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            open_shell_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrientedOpenShell_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.open_shell_element.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrientedPath_<'a> { // entity
    pub name: Label<'a>,
    pub path_element: Path<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedPath<'a> = Id<OrientedPath_<'a>>;
impl<'a> FromEntity<'a> for OrientedPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrientedPath_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORIENTED_PATH(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, path_element) = param_from_chunks::<Path<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            path_element,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrientedPath_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.path_element.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OrientedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OrientedSurface<'a> = Id<OrientedSurface_<'a>>;
impl<'a> FromEntity<'a> for OrientedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OrientedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OrientedSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ORIENTED_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OrientedSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OuterBoundaryCurve_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<CompositeCurveSegment<'a>>,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OuterBoundaryCurve<'a> = Id<OuterBoundaryCurve_<'a>>;
impl<'a> FromEntity<'a> for OuterBoundaryCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OuterBoundaryCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OuterBoundaryCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OUTER_BOUNDARY_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, segments) = param_from_chunks::<Vec<CompositeCurveSegment<'a>>>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            segments,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OuterBoundaryCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.segments.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct OverRidingStyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub over_ridden_style: StyledItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type OverRidingStyledItem<'a> = Id<OverRidingStyledItem_<'a>>;
impl<'a> FromEntity<'a> for OverRidingStyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::OverRidingStyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for OverRidingStyledItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("OVER_RIDING_STYLED_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, over_ridden_style) = param_from_chunks::<StyledItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            over_ridden_style,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for OverRidingStyledItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.over_ridden_style.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PackageProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PackageProductConceptFeature<'a> = Id<PackageProductConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for PackageProductConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PackageProductConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PackageProductConceptFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PACKAGE_PRODUCT_CONCEPT_FEATURE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PackageProductConceptFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PairActuator_<'a> { // entity
    pub actuated_pair: KinematicPair<'a>,
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PairActuator<'a> = Id<PairActuator_<'a>>;
impl<'a> FromEntity<'a> for PairActuator_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PairActuator(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PairActuator_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PAIR_ACTUATOR(")(strs[0])?;
        let (s, actuated_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            actuated_pair,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PairActuator_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.actuated_pair.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PairValue<'a> = Id<PairValue_<'a>>;
impl<'a> FromEntity<'a> for PairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Parabola_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement<'a>,
    pub focal_dist: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Parabola<'a> = Id<Parabola_<'a>>;
impl<'a> FromEntity<'a> for Parabola_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Parabola(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Parabola_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PARABOLA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, focal_dist) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            focal_dist,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Parabola_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.focal_dist.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ParallelOffset_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub offset: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParallelOffset<'a> = Id<ParallelOffset_<'a>>;
impl<'a> FromEntity<'a> for ParallelOffset_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ParallelOffset(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ParallelOffset_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PARALLEL_OFFSET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, offset) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            offset,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ParallelOffset_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
        self.offset.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ParallelismTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParallelismTolerance<'a> = Id<ParallelismTolerance_<'a>>;
impl<'a> FromEntity<'a> for ParallelismTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ParallelismTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ParallelismTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PARALLELISM_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ParallelismTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ParameterValue<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ParameterValue<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for ParameterValue<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct ParametricRepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ParametricRepresentationContext<'a> = Id<ParametricRepresentationContext_<'a>>;
impl<'a> FromEntity<'a> for ParametricRepresentationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ParametricRepresentationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ParametricRepresentationContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PARAMETRIC_REPRESENTATION_CONTEXT(")(strs[0])?;
        let (s, context_identifier) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, context_type) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ParametricRepresentationContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.context_identifier.append_ids(_v);
        self.context_type.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PartialCircularProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PartialCircularProfile<'a> = Id<PartialCircularProfile_<'a>>;
impl<'a> FromEntity<'a> for PartialCircularProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PartialCircularProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PartialCircularProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PARTIAL_CIRCULAR_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PartialCircularProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Path_<'a> { // entity
    pub name: Label<'a>,
    pub edge_list: Vec<OrientedEdge<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Path<'a> = Id<Path_<'a>>;
impl<'a> FromEntity<'a> for Path_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Path(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Path_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PATH(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, edge_list) = param_from_chunks::<Vec<OrientedEdge<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            edge_list,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Path_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.edge_list.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PathFeatureComponent_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PathFeatureComponent<'a> = Id<PathFeatureComponent_<'a>>;
impl<'a> FromEntity<'a> for PathFeatureComponent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PathFeatureComponent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PathFeatureComponent_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PATH_FEATURE_COMPONENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PathFeatureComponent_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PathShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PathShapeRepresentation<'a> = Id<PathShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PathShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PathShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PathShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PATH_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PathShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PatternOffsetMembership_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PatternOffsetMembership<'a> = Id<PatternOffsetMembership_<'a>>;
impl<'a> FromEntity<'a> for PatternOffsetMembership_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PatternOffsetMembership(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PatternOffsetMembership_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PATTERN_OFFSET_MEMBERSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PatternOffsetMembership_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PatternOmitMembership_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PatternOmitMembership<'a> = Id<PatternOmitMembership_<'a>>;
impl<'a> FromEntity<'a> for PatternOmitMembership_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PatternOmitMembership(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PatternOmitMembership_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PATTERN_OMIT_MEMBERSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PatternOmitMembership_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Pcurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub reference_to_curve: DefinitionalRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Pcurve<'a> = Id<Pcurve_<'a>>;
impl<'a> FromEntity<'a> for Pcurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Pcurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Pcurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PCURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, reference_to_curve) = param_from_chunks::<DefinitionalRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_surface,
            reference_to_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Pcurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.reference_to_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PcurveOrSurface_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PcurveOrSurface<'a> = Id<PcurveOrSurface_<'a>>;

#[derive(Debug)]
pub struct PerpendicularTo_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PerpendicularTo<'a> = Id<PerpendicularTo_<'a>>;
impl<'a> FromEntity<'a> for PerpendicularTo_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PerpendicularTo(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PerpendicularTo_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERPENDICULAR_TO(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PerpendicularTo_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PerpendicularityTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PerpendicularityTolerance<'a> = Id<PerpendicularityTolerance_<'a>>;
impl<'a> FromEntity<'a> for PerpendicularityTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PerpendicularityTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PerpendicularityTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERPENDICULARITY_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PerpendicularityTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Person_<'a> { // entity
    pub id: Identifier<'a>,
    pub last_name: Option<Label<'a>>,
    pub first_name: Option<Label<'a>>,
    pub middle_names: Option<Vec<Label<'a>>>,
    pub prefix_titles: Option<Vec<Label<'a>>>,
    pub suffix_titles: Option<Vec<Label<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Person<'a> = Id<Person_<'a>>;
impl<'a> FromEntity<'a> for Person_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Person(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Person_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERSON(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, last_name) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, first_name) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, middle_names) = param_from_chunks::<Option<Vec<Label<'a>>>>(false, s, &mut i, strs)?;
        let (s, prefix_titles) = param_from_chunks::<Option<Vec<Label<'a>>>>(false, s, &mut i, strs)?;
        let (s, suffix_titles) = param_from_chunks::<Option<Vec<Label<'a>>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            last_name,
            first_name,
            middle_names,
            prefix_titles,
            suffix_titles,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Person_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.last_name.append_ids(_v);
        self.first_name.append_ids(_v);
        self.middle_names.append_ids(_v);
        self.prefix_titles.append_ids(_v);
        self.suffix_titles.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PersonAndOrganization_<'a> { // entity
    pub the_person: Person<'a>,
    pub the_organization: Organization<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganization<'a> = Id<PersonAndOrganization_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganization_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganization(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PersonAndOrganization_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERSON_AND_ORGANIZATION(")(strs[0])?;
        let (s, the_person) = param_from_chunks::<Person<'a>>(false, s, &mut i, strs)?;
        let (s, the_organization) = param_from_chunks::<Organization<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            the_person,
            the_organization,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PersonAndOrganization_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.the_person.append_ids(_v);
        self.the_organization.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct PersonAndOrganizationAddress_<'a> { // entity
    pub address__internal_location: Option<Label<'a>>,
    pub address__street_number: Option<Label<'a>>,
    pub address__street: Option<Label<'a>>,
    pub address__postal_box: Option<Label<'a>>,
    pub address__town: Option<Label<'a>>,
    pub address__region: Option<Label<'a>>,
    pub address__postal_code: Option<Label<'a>>,
    pub address__country: Option<Label<'a>>,
    pub address__facsimile_number: Option<Label<'a>>,
    pub address__telephone_number: Option<Label<'a>>,
    pub address__electronic_mail_address: Option<Label<'a>>,
    pub address__telex_number: Option<Label<'a>>,
    pub organizations: Vec<Organization<'a>>,
    pub organizational_address__description: Option<Text<'a>>,
    pub people: Vec<Person<'a>>,
    pub personal_address__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationAddress<'a> = Id<PersonAndOrganizationAddress_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganizationAddress_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganizationAddress(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PersonAndOrganizationAddress_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERSON_AND_ORGANIZATION_ADDRESS(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, address__internal_location) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__street_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__street) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__postal_box) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__town) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__region) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__postal_code) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__country) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__facsimile_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__telephone_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__electronic_mail_address) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, address__telex_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, organizations) = param_from_chunks::<Vec<Organization<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, organizational_address__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, people) = param_from_chunks::<Vec<Person<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, personal_address__description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            address__internal_location,
            address__street_number,
            address__street,
            address__postal_box,
            address__town,
            address__region,
            address__postal_code,
            address__country,
            address__facsimile_number,
            address__telephone_number,
            address__electronic_mail_address,
            address__telex_number,
            organizations,
            organizational_address__description,
            people,
            personal_address__description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PersonAndOrganizationAddress_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.address__internal_location.append_ids(_v);
        self.address__street_number.append_ids(_v);
        self.address__street.append_ids(_v);
        self.address__postal_box.append_ids(_v);
        self.address__town.append_ids(_v);
        self.address__region.append_ids(_v);
        self.address__postal_code.append_ids(_v);
        self.address__country.append_ids(_v);
        self.address__facsimile_number.append_ids(_v);
        self.address__telephone_number.append_ids(_v);
        self.address__electronic_mail_address.append_ids(_v);
        self.address__telex_number.append_ids(_v);
        self.organizations.append_ids(_v);
        self.organizational_address__description.append_ids(_v);
        self.people.append_ids(_v);
        self.personal_address__description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PersonAndOrganizationAssignment_<'a> { // entity
    pub assigned_person_and_organization: PersonAndOrganization<'a>,
    pub role: PersonAndOrganizationRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationAssignment<'a> = Id<PersonAndOrganizationAssignment_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganizationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganizationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PersonAndOrganizationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERSON_AND_ORGANIZATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_person_and_organization) = param_from_chunks::<PersonAndOrganization<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<PersonAndOrganizationRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_person_and_organization,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PersonAndOrganizationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_person_and_organization.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PersonAndOrganizationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PersonAndOrganizationItem<'a> = Id<PersonAndOrganizationItem_<'a>>;

#[derive(Debug)]
pub struct PersonAndOrganizationRole_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonAndOrganizationRole<'a> = Id<PersonAndOrganizationRole_<'a>>;
impl<'a> FromEntity<'a> for PersonAndOrganizationRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonAndOrganizationRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PersonAndOrganizationRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERSON_AND_ORGANIZATION_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PersonAndOrganizationRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PersonOrganizationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PersonOrganizationSelect<'a> = Id<PersonOrganizationSelect_<'a>>;

#[derive(Debug)]
pub struct PersonalAddress_<'a> { // entity
    pub internal_location: Option<Label<'a>>,
    pub street_number: Option<Label<'a>>,
    pub street: Option<Label<'a>>,
    pub postal_box: Option<Label<'a>>,
    pub town: Option<Label<'a>>,
    pub region: Option<Label<'a>>,
    pub postal_code: Option<Label<'a>>,
    pub country: Option<Label<'a>>,
    pub facsimile_number: Option<Label<'a>>,
    pub telephone_number: Option<Label<'a>>,
    pub electronic_mail_address: Option<Label<'a>>,
    pub telex_number: Option<Label<'a>>,
    pub people: Vec<Person<'a>>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PersonalAddress<'a> = Id<PersonalAddress_<'a>>;
impl<'a> FromEntity<'a> for PersonalAddress_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PersonalAddress(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PersonalAddress_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PERSONAL_ADDRESS(")(strs[0])?;
        let (s, internal_location) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, street_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, street) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, postal_box) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, town) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, region) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, postal_code) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, country) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, facsimile_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, telephone_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, electronic_mail_address) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, telex_number) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        let (s, people) = param_from_chunks::<Vec<Person<'a>>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            internal_location,
            street_number,
            street,
            postal_box,
            town,
            region,
            postal_code,
            country,
            facsimile_number,
            telephone_number,
            electronic_mail_address,
            telex_number,
            people,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PersonalAddress_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.internal_location.append_ids(_v);
        self.street_number.append_ids(_v);
        self.street.append_ids(_v);
        self.postal_box.append_ids(_v);
        self.town.append_ids(_v);
        self.region.append_ids(_v);
        self.postal_code.append_ids(_v);
        self.country.append_ids(_v);
        self.facsimile_number.append_ids(_v);
        self.telephone_number.append_ids(_v);
        self.electronic_mail_address.append_ids(_v);
        self.telex_number.append_ids(_v);
        self.people.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PhysicallyModelledProductDefinition_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub documentation_ids: Vec<Document<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PhysicallyModelledProductDefinition<'a> = Id<PhysicallyModelledProductDefinition_<'a>>;
impl<'a> FromEntity<'a> for PhysicallyModelledProductDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PhysicallyModelledProductDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PhysicallyModelledProductDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PHYSICALLY_MODELLED_PRODUCT_DEFINITION(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, formation) = param_from_chunks::<ProductDefinitionFormation<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ProductDefinitionContext<'a>>(false, s, &mut i, strs)?;
        let (s, documentation_ids) = param_from_chunks::<Vec<Document<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            description,
            formation,
            frame_of_reference,
            documentation_ids,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PhysicallyModelledProductDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.description.append_ids(_v);
        self.formation.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
        self.documentation_ids.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlacedDatumTargetFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub target_id: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlacedDatumTargetFeature<'a> = Id<PlacedDatumTargetFeature_<'a>>;
impl<'a> FromEntity<'a> for PlacedDatumTargetFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlacedDatumTargetFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlacedDatumTargetFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLACED_DATUM_TARGET_FEATURE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, target_id) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            target_id,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlacedDatumTargetFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
        self.target_id.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlacedFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlacedFeature<'a> = Id<PlacedFeature_<'a>>;
impl<'a> FromEntity<'a> for PlacedFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlacedFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlacedFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLACED_FEATURE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlacedFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Placement_<'a> { // entity
    pub name: Label<'a>,
    pub location: CartesianPoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Placement<'a> = Id<Placement_<'a>>;
impl<'a> FromEntity<'a> for Placement_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Placement(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Placement_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLACEMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, location) = param_from_chunks::<CartesianPoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            location,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Placement_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.location.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarBox_<'a> { // entity
    pub name: Label<'a>,
    pub size_in_x: LengthMeasure<'a>,
    pub size_in_y: LengthMeasure<'a>,
    pub placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarBox<'a> = Id<PlanarBox_<'a>>;
impl<'a> FromEntity<'a> for PlanarBox_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarBox(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarBox_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_BOX(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, size_in_x) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, size_in_y) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            size_in_x,
            size_in_y,
            placement,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarBox_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.size_in_x.append_ids(_v);
        self.size_in_y.append_ids(_v);
        self.placement.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarCurvePair<'a> = Id<PlanarCurvePair_<'a>>;
impl<'a> FromEntity<'a> for PlanarCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarCurvePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_CURVE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, curve_1) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, curve_2) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            curve_1,
            curve_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarCurvePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.curve_1.append_ids(_v);
        self.curve_2.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarCurvePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_curve_1: TrimmedCurve<'a>,
    pub range_on_curve_2: TrimmedCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarCurvePairRange<'a> = Id<PlanarCurvePairRange_<'a>>;
impl<'a> FromEntity<'a> for PlanarCurvePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarCurvePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarCurvePairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_CURVE_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, range_on_curve_1) = param_from_chunks::<TrimmedCurve<'a>>(false, s, &mut i, strs)?;
        let (s, range_on_curve_2) = param_from_chunks::<TrimmedCurve<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_curve_1,
            range_on_curve_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarCurvePairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.range_on_curve_1.append_ids(_v);
        self.range_on_curve_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarExtent_<'a> { // entity
    pub name: Label<'a>,
    pub size_in_x: LengthMeasure<'a>,
    pub size_in_y: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarExtent<'a> = Id<PlanarExtent_<'a>>;
impl<'a> FromEntity<'a> for PlanarExtent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarExtent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarExtent_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_EXTENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, size_in_x) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, size_in_y) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            size_in_x,
            size_in_y,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarExtent_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.size_in_x.append_ids(_v);
        self.size_in_y.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPair<'a> = Id<PlanarPair_<'a>>;
impl<'a> FromEntity<'a> for PlanarPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub lower_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation_x: TranslationalRangeMeasure<'a>,
    pub lower_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation_y: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPairRange<'a> = Id<PlanarPairRange_<'a>>;
impl<'a> FromEntity<'a> for PlanarPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_translation_x) = param_from_chunks::<TranslationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_translation_x) = param_from_chunks::<TranslationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_translation_y) = param_from_chunks::<TranslationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_translation_y) = param_from_chunks::<TranslationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            lower_limit_actual_translation_x,
            upper_limit_actual_translation_x,
            lower_limit_actual_translation_y,
            upper_limit_actual_translation_y,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_actual_rotation.append_ids(_v);
        self.upper_limit_actual_rotation.append_ids(_v);
        self.lower_limit_actual_translation_x.append_ids(_v);
        self.upper_limit_actual_translation_x.append_ids(_v);
        self.lower_limit_actual_translation_y.append_ids(_v);
        self.upper_limit_actual_translation_y.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    pub actual_translation_x: LengthMeasure<'a>,
    pub actual_translation_y: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarPairValue<'a> = Id<PlanarPairValue_<'a>>;
impl<'a> FromEntity<'a> for PlanarPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_rotation) = param_from_chunks::<PlaneAngleMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, actual_translation_x) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, actual_translation_y) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation,
            actual_translation_x,
            actual_translation_y,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_rotation.append_ids(_v);
        self.actual_translation_x.append_ids(_v);
        self.actual_translation_y.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlanarShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlanarShapeRepresentation<'a> = Id<PlanarShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PlanarShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlanarShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlanarShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANAR_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlanarShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Plane_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Plane<'a> = Id<Plane_<'a>>;
impl<'a> FromEntity<'a> for Plane_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Plane(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Plane_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Plane_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlaneAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for PlaneAngleMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct PlaneAngleMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlaneAngleMeasureWithUnit<'a> = Id<PlaneAngleMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for PlaneAngleMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlaneAngleMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlaneAngleMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANE_ANGLE_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlaneAngleMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlaneAngleUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlaneAngleUnit<'a> = Id<PlaneAngleUnit_<'a>>;
impl<'a> FromEntity<'a> for PlaneAngleUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlaneAngleUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlaneAngleUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLANE_ANGLE_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlaneAngleUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlaneOrPlanarBox_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PlaneOrPlanarBox<'a> = Id<PlaneOrPlanarBox_<'a>>;

#[derive(Debug)]
pub struct PlusExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlusExpression<'a> = Id<PlusExpression_<'a>>;
impl<'a> FromEntity<'a> for PlusExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlusExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlusExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLUS_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlusExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PlusMinusTolerance_<'a> { // entity
    pub range: ToleranceMethodDefinition<'a>,
    pub toleranced_dimension: DimensionalCharacteristic<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PlusMinusTolerance<'a> = Id<PlusMinusTolerance_<'a>>;
impl<'a> FromEntity<'a> for PlusMinusTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PlusMinusTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PlusMinusTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PLUS_MINUS_TOLERANCE(")(strs[0])?;
        let (s, range) = param_from_chunks::<ToleranceMethodDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_dimension) = param_from_chunks::<DimensionalCharacteristic<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            range,
            toleranced_dimension,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PlusMinusTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.range.append_ids(_v);
        self.toleranced_dimension.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Pocket_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Pocket<'a> = Id<Pocket_<'a>>;
impl<'a> FromEntity<'a> for Pocket_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Pocket(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Pocket_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POCKET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Pocket_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PocketBottom_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PocketBottom<'a> = Id<PocketBottom_<'a>>;
impl<'a> FromEntity<'a> for PocketBottom_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PocketBottom(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PocketBottom_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POCKET_BOTTOM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PocketBottom_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Point_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Point<'a> = Id<Point_<'a>>;
impl<'a> FromEntity<'a> for Point_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Point(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Point_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Point_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnCurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub point_parameter: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnCurve<'a> = Id<PointOnCurve_<'a>>;
impl<'a> FromEntity<'a> for PointOnCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, point_parameter) = param_from_chunks::<ParameterValue<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_curve,
            point_parameter,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_curve.append_ids(_v);
        self.point_parameter.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnPlanarCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pair_curve: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePair<'a> = Id<PointOnPlanarCurvePair_<'a>>;
impl<'a> FromEntity<'a> for PointOnPlanarCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnPlanarCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnPlanarCurvePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_PLANAR_CURVE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, pair_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pair_curve,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnPlanarCurvePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.pair_curve.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnPlanarCurvePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_pair_curve: TrimmedCurve<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePairRange<'a> = Id<PointOnPlanarCurvePairRange_<'a>>;
impl<'a> FromEntity<'a> for PointOnPlanarCurvePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnPlanarCurvePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnPlanarCurvePairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_PLANAR_CURVE_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, range_on_pair_curve) = param_from_chunks::<TrimmedCurve<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_yaw) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_yaw) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_pitch) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_pitch) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_roll) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_roll) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_pair_curve,
            lower_limit_yaw,
            upper_limit_yaw,
            lower_limit_pitch,
            upper_limit_pitch,
            lower_limit_roll,
            upper_limit_roll,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnPlanarCurvePairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.range_on_pair_curve.append_ids(_v);
        self.lower_limit_yaw.append_ids(_v);
        self.upper_limit_yaw.append_ids(_v);
        self.lower_limit_pitch.append_ids(_v);
        self.upper_limit_pitch.append_ids(_v);
        self.lower_limit_roll.append_ids(_v);
        self.upper_limit_roll.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnPlanarCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve: PointOnCurve<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnPlanarCurvePairValue<'a> = Id<PointOnPlanarCurvePairValue_<'a>>;
impl<'a> FromEntity<'a> for PointOnPlanarCurvePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnPlanarCurvePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnPlanarCurvePairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_PLANAR_CURVE_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_curve) = param_from_chunks::<PointOnCurve<'a>>(false, s, &mut i, strs)?;
        let (s, input_orientation) = param_from_chunks::<SpatialRotation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_curve,
            input_orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnPlanarCurvePairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_point_on_curve.append_ids(_v);
        self.input_orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub point_parameter_u: ParameterValue<'a>,
    pub point_parameter_v: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurface<'a> = Id<PointOnSurface_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, point_parameter_u) = param_from_chunks::<ParameterValue<'a>>(false, s, &mut i, strs)?;
        let (s, point_parameter_v) = param_from_chunks::<ParameterValue<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_surface,
            point_parameter_u,
            point_parameter_v,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.point_parameter_u.append_ids(_v);
        self.point_parameter_v.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pair_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePair<'a> = Id<PointOnSurfacePair_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnSurfacePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_SURFACE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, pair_surface) = param_from_chunks::<Surface<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pair_surface,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnSurfacePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.pair_surface.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnSurfacePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_pair_surface: RectangularTrimmedSurface<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePairRange<'a> = Id<PointOnSurfacePairRange_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurfacePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurfacePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnSurfacePairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_SURFACE_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, range_on_pair_surface) = param_from_chunks::<RectangularTrimmedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_yaw) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_yaw) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_pitch) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_pitch) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_roll) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_roll) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_pair_surface,
            lower_limit_yaw,
            upper_limit_yaw,
            lower_limit_pitch,
            upper_limit_pitch,
            lower_limit_roll,
            upper_limit_roll,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnSurfacePairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.range_on_pair_surface.append_ids(_v);
        self.lower_limit_yaw.append_ids(_v);
        self.upper_limit_yaw.append_ids(_v);
        self.lower_limit_pitch.append_ids(_v);
        self.upper_limit_pitch.append_ids(_v);
        self.lower_limit_roll.append_ids(_v);
        self.upper_limit_roll.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointOnSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface: PointOnSurface<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointOnSurfacePairValue<'a> = Id<PointOnSurfacePairValue_<'a>>;
impl<'a> FromEntity<'a> for PointOnSurfacePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointOnSurfacePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointOnSurfacePairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_ON_SURFACE_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_surface) = param_from_chunks::<PointOnSurface<'a>>(false, s, &mut i, strs)?;
        let (s, input_orientation) = param_from_chunks::<SpatialRotation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_surface,
            input_orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointOnSurfacePairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_point_on_surface.append_ids(_v);
        self.input_orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointPlacementShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointPlacementShapeRepresentation<'a> = Id<PointPlacementShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PointPlacementShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointPlacementShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointPlacementShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_PLACEMENT_SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointPlacementShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_pt: Point<'a>,
    pub transformation: CartesianTransformationOperator<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointReplica<'a> = Id<PointReplica_<'a>>;
impl<'a> FromEntity<'a> for PointReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointReplica_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_REPLICA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, parent_pt) = param_from_chunks::<Point<'a>>(false, s, &mut i, strs)?;
        let (s, transformation) = param_from_chunks::<CartesianTransformationOperator<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            parent_pt,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointReplica_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.parent_pt.append_ids(_v);
        self.transformation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PointStyle_<'a> { // entity
    pub name: Label<'a>,
    pub marker: MarkerSelect<'a>,
    pub marker_size: SizeSelect<'a>,
    pub marker_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PointStyle<'a> = Id<PointStyle_<'a>>;
impl<'a> FromEntity<'a> for PointStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PointStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PointStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POINT_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, marker) = param_from_chunks::<MarkerSelect<'a>>(false, s, &mut i, strs)?;
        let (s, marker_size) = param_from_chunks::<SizeSelect<'a>>(false, s, &mut i, strs)?;
        let (s, marker_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            marker,
            marker_size,
            marker_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PointStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.marker.append_ids(_v);
        self.marker_size.append_ids(_v);
        self.marker_colour.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct PolyLoop_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub polygon: Vec<CartesianPoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PolyLoop<'a> = Id<PolyLoop_<'a>>;
impl<'a> FromEntity<'a> for PolyLoop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PolyLoop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PolyLoop_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POLY_LOOP(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, polygon) = param_from_chunks::<Vec<CartesianPoint<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            polygon,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PolyLoop_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.polygon.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Polyline_<'a> { // entity
    pub name: Label<'a>,
    pub points: Vec<CartesianPoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Polyline<'a> = Id<Polyline_<'a>>;
impl<'a> FromEntity<'a> for Polyline_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Polyline(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Polyline_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POLYLINE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, points) = param_from_chunks::<Vec<CartesianPoint<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            points,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Polyline_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.points.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PositionTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PositionTolerance<'a> = Id<PositionTolerance_<'a>>;
impl<'a> FromEntity<'a> for PositionTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PositionTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PositionTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POSITION_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PositionTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}

#[derive(Debug)]
pub struct PositiveLengthMeasure<'a>(pub NonNegativeLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveLengthMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(NonNegativeLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for PositiveLengthMeasure<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}


#[derive(Debug)]
pub struct PositivePlaneAngleMeasure<'a>(pub PlaneAngleMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositivePlaneAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PlaneAngleMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for PositivePlaneAngleMeasure<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}


#[derive(Debug)]
pub struct PositiveRatioMeasure<'a>(pub RatioMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for PositiveRatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(RatioMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for PositiveRatioMeasure<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}

#[derive(Debug)]
pub struct PowerExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PowerExpression<'a> = Id<PowerExpression_<'a>>;
impl<'a> FromEntity<'a> for PowerExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PowerExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PowerExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("POWER_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PowerExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedColour_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedColour<'a> = Id<PreDefinedColour_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedColour_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_COLOUR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedColour_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedCurveFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedCurveFont<'a> = Id<PreDefinedCurveFont_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedCurveFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedCurveFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedCurveFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_CURVE_FONT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedCurveFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedDimensionSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedDimensionSymbol<'a> = Id<PreDefinedDimensionSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedDimensionSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedDimensionSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedDimensionSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_DIMENSION_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedDimensionSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedGeometricalToleranceSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedGeometricalToleranceSymbol<'a> = Id<PreDefinedGeometricalToleranceSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedGeometricalToleranceSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedGeometricalToleranceSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedGeometricalToleranceSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedGeometricalToleranceSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedItem<'a> = Id<PreDefinedItem_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedMarker_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedMarker<'a> = Id<PreDefinedMarker_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedMarker_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedMarker(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedMarker_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_MARKER(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedMarker_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct PreDefinedPointMarkerSymbol_<'a> { // entity
    pub pre_defined_item__name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedPointMarkerSymbol<'a> = Id<PreDefinedPointMarkerSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedPointMarkerSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedPointMarkerSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedPointMarkerSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_POINT_MARKER_SYMBOL(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, pre_defined_item__name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            pre_defined_item__name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedPointMarkerSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.pre_defined_item__name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedPresentationStyle_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedPresentationStyle<'a> = Id<PreDefinedPresentationStyle_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedPresentationStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedPresentationStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedPresentationStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_PRESENTATION_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedPresentationStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedSurfaceConditionSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedSurfaceConditionSymbol<'a> = Id<PreDefinedSurfaceConditionSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedSurfaceConditionSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedSurfaceConditionSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedSurfaceConditionSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_SURFACE_CONDITION_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedSurfaceConditionSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedSymbol<'a> = Id<PreDefinedSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedTerminatorSymbol_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedTerminatorSymbol<'a> = Id<PreDefinedTerminatorSymbol_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedTerminatorSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedTerminatorSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedTerminatorSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_TERMINATOR_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedTerminatorSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PreDefinedTextFont_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PreDefinedTextFont<'a> = Id<PreDefinedTextFont_<'a>>;
impl<'a> FromEntity<'a> for PreDefinedTextFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PreDefinedTextFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PreDefinedTextFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRE_DEFINED_TEXT_FONT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PreDefinedTextFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PrecisionQualifier_<'a> { // entity
    pub precision_value: i64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrecisionQualifier<'a> = Id<PrecisionQualifier_<'a>>;
impl<'a> FromEntity<'a> for PrecisionQualifier_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrecisionQualifier(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PrecisionQualifier_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRECISION_QUALIFIER(")(strs[0])?;
        let (s, precision_value) = param_from_chunks::<i64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            precision_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PrecisionQualifier_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.precision_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum PreferredSurfaceCurveRepresentation<'a> { // enum
    Curve3d,
    PcurveS1,
    PcurveS2,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for PreferredSurfaceCurveRepresentation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use PreferredSurfaceCurveRepresentation::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "CURVE_3D" => Curve3d,
            "PCURVE_S1" => PcurveS1,
            "PCURVE_S2" => PcurveS2,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for PreferredSurfaceCurveRepresentation<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct PresentableText<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for PresentableText<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for PresentableText<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct PresentationArea_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationArea<'a> = Id<PresentationArea_<'a>>;
impl<'a> FromEntity<'a> for PresentationArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationArea_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTATION_AREA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationArea_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PresentationLayerAssignment_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub assigned_items: Vec<LayeredItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationLayerAssignment<'a> = Id<PresentationLayerAssignment_<'a>>;
impl<'a> FromEntity<'a> for PresentationLayerAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationLayerAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationLayerAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTATION_LAYER_ASSIGNMENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, assigned_items) = param_from_chunks::<Vec<LayeredItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            assigned_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationLayerAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.assigned_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PresentationRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationRepresentation<'a> = Id<PresentationRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PresentationRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTATION_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PresentationRepresentationSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentationRepresentationSelect<'a> = Id<PresentationRepresentationSelect_<'a>>;

#[derive(Debug)]
pub struct PresentationSet_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationSet<'a> = Id<PresentationSet_<'a>>;
impl<'a> FromEntity<'a> for PresentationSet_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationSet(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationSet_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTATION_SET(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationSet_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct PresentationSize_<'a> { // entity
    pub unit: PresentationSizeAssignmentSelect<'a>,
    pub size: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationSize<'a> = Id<PresentationSize_<'a>>;
impl<'a> FromEntity<'a> for PresentationSize_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationSize(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationSize_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTATION_SIZE(")(strs[0])?;
        let (s, unit) = param_from_chunks::<PresentationSizeAssignmentSelect<'a>>(false, s, &mut i, strs)?;
        let (s, size) = param_from_chunks::<PlanarBox<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            unit,
            size,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationSize_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.unit.append_ids(_v);
        self.size.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PresentationSizeAssignmentSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentationSizeAssignmentSelect<'a> = Id<PresentationSizeAssignmentSelect_<'a>>;

#[derive(Debug)]
pub struct PresentationStyleAssignment_<'a> { // entity
    pub styles: Vec<PresentationStyleSelect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationStyleAssignment<'a> = Id<PresentationStyleAssignment_<'a>>;
impl<'a> FromEntity<'a> for PresentationStyleAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationStyleAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationStyleAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTATION_STYLE_ASSIGNMENT(")(strs[0])?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleSelect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            styles,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationStyleAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.styles.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PresentationStyleByContext_<'a> { // entity
    pub styles: Vec<PresentationStyleSelect<'a>>,
    pub style_context: StyleContextSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationStyleByContext<'a> = Id<PresentationStyleByContext_<'a>>;
impl<'a> FromEntity<'a> for PresentationStyleByContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationStyleByContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationStyleByContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTATION_STYLE_BY_CONTEXT(")(strs[0])?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleSelect<'a>>>(false, s, &mut i, strs)?;
        let (s, style_context) = param_from_chunks::<StyleContextSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            styles,
            style_context,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationStyleByContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.styles.append_ids(_v);
        self.style_context.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum PresentationStyleSelect<'a> { // select
    PreDefinedPresentationStyle(PreDefinedPresentationStyle<'a>),
    PointStyle(PointStyle<'a>),
    CurveStyle(CurveStyle<'a>),
    SurfaceStyleUsage(SurfaceStyleUsage<'a>),
    SymbolStyle(SymbolStyle<'a>),
    FillAreaStyle(FillAreaStyle<'a>),
    TextStyle(TextStyle<'a>),
    ApproximationTolerance(ApproximationTolerance<'a>),
    ExternallyDefinedStyle(ExternallyDefinedStyle<'a>),
    NullStyle(NullStyle<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for PresentationStyleSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<PreDefinedPresentationStyle<'a>>::parse, PresentationStyleSelect::PreDefinedPresentationStyle),
            map(<PointStyle<'a>>::parse, PresentationStyleSelect::PointStyle),
            map(<CurveStyle<'a>>::parse, PresentationStyleSelect::CurveStyle),
            map(<SurfaceStyleUsage<'a>>::parse, PresentationStyleSelect::SurfaceStyleUsage),
            map(<SymbolStyle<'a>>::parse, PresentationStyleSelect::SymbolStyle),
            map(<FillAreaStyle<'a>>::parse, PresentationStyleSelect::FillAreaStyle),
            map(<TextStyle<'a>>::parse, PresentationStyleSelect::TextStyle),
            map(<ApproximationTolerance<'a>>::parse, PresentationStyleSelect::ApproximationTolerance),
            map(<ExternallyDefinedStyle<'a>>::parse, PresentationStyleSelect::ExternallyDefinedStyle),
            map(delimited(tag("NULL_STYLE("), <NullStyle<'a>>::parse, char(')')), PresentationStyleSelect::NullStyle),
        ))(s)
    }
}
impl<'a> HasId for PresentationStyleSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            PresentationStyleSelect::PreDefinedPresentationStyle(c) => c.append_ids(_v),
            PresentationStyleSelect::PointStyle(c) => c.append_ids(_v),
            PresentationStyleSelect::CurveStyle(c) => c.append_ids(_v),
            PresentationStyleSelect::SurfaceStyleUsage(c) => c.append_ids(_v),
            PresentationStyleSelect::SymbolStyle(c) => c.append_ids(_v),
            PresentationStyleSelect::FillAreaStyle(c) => c.append_ids(_v),
            PresentationStyleSelect::TextStyle(c) => c.append_ids(_v),
            PresentationStyleSelect::ApproximationTolerance(c) => c.append_ids(_v),
            PresentationStyleSelect::ExternallyDefinedStyle(c) => c.append_ids(_v),
            PresentationStyleSelect::NullStyle(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct PresentationView_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentationView<'a> = Id<PresentationView_<'a>>;
impl<'a> FromEntity<'a> for PresentationView_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentationView(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentationView_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTATION_VIEW(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentationView_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PresentedItem_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentedItem<'a> = Id<PresentedItem_<'a>>;
impl<'a> FromEntity<'a> for PresentedItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentedItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentedItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("PRESENTED_ITEM(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentedItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct PresentedItemRepresentation_<'a> { // entity
    pub presentation: PresentationRepresentationSelect<'a>,
    pub item: PresentedItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PresentedItemRepresentation<'a> = Id<PresentedItemRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PresentedItemRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PresentedItemRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PresentedItemRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRESENTED_ITEM_REPRESENTATION(")(strs[0])?;
        let (s, presentation) = param_from_chunks::<PresentationRepresentationSelect<'a>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<PresentedItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            presentation,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PresentedItemRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.presentation.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PresentedItemSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PresentedItemSelect<'a> = Id<PresentedItemSelect_<'a>>;

#[derive(Debug)]
pub struct PrismaticPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPair<'a> = Id<PrismaticPair_<'a>>;
impl<'a> FromEntity<'a> for PrismaticPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrismaticPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PrismaticPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRISMATIC_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PrismaticPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PrismaticPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_translation: TranslationalRangeMeasure<'a>,
    pub upper_limit_actual_translation: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPairRange<'a> = Id<PrismaticPairRange_<'a>>;
impl<'a> FromEntity<'a> for PrismaticPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrismaticPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PrismaticPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRISMATIC_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_translation) = param_from_chunks::<TranslationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_translation) = param_from_chunks::<TranslationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_translation,
            upper_limit_actual_translation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PrismaticPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_actual_translation.append_ids(_v);
        self.upper_limit_actual_translation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PrismaticPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_translation: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PrismaticPairValue<'a> = Id<PrismaticPairValue_<'a>>;
impl<'a> FromEntity<'a> for PrismaticPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PrismaticPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PrismaticPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRISMATIC_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_translation) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_translation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PrismaticPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_translation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProcessOperation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub consequence: Text<'a>,
    pub purpose: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessOperation<'a> = Id<ProcessOperation_<'a>>;
impl<'a> FromEntity<'a> for ProcessOperation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessOperation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProcessOperation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROCESS_OPERATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, consequence) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            consequence,
            purpose,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProcessOperation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.consequence.append_ids(_v);
        self.purpose.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProcessPlan_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessPlan<'a> = Id<ProcessPlan_<'a>>;
impl<'a> FromEntity<'a> for ProcessPlan_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessPlan(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProcessPlan_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROCESS_PLAN(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProcessPlan_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProcessProductAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub defined_product: CharacterizedProductDefinition<'a>,
    pub process: ProductDefinitionProcess<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessProductAssociation<'a> = Id<ProcessProductAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProcessProductAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessProductAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProcessProductAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROCESS_PRODUCT_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, defined_product) = param_from_chunks::<CharacterizedProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, process) = param_from_chunks::<ProductDefinitionProcess<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            defined_product,
            process,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProcessProductAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.defined_product.append_ids(_v);
        self.process.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProcessPropertyAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub process: PropertyProcess<'a>,
    pub property_or_shape: PropertyOrShapeSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProcessPropertyAssociation<'a> = Id<ProcessPropertyAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProcessPropertyAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProcessPropertyAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProcessPropertyAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROCESS_PROPERTY_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, process) = param_from_chunks::<PropertyProcess<'a>>(false, s, &mut i, strs)?;
        let (s, property_or_shape) = param_from_chunks::<PropertyOrShapeSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            process,
            property_or_shape,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProcessPropertyAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.process.append_ids(_v);
        self.property_or_shape.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Product_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub frame_of_reference: Vec<ProductContext<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Product<'a> = Id<Product_<'a>>;
impl<'a> FromEntity<'a> for Product_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Product(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Product_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<Vec<ProductContext<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Product_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductCategory<'a> = Id<ProductCategory_<'a>>;
impl<'a> FromEntity<'a> for ProductCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductCategory_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CATEGORY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductCategory_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductCategoryRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub category: ProductCategory<'a>,
    pub sub_category: ProductCategory<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductCategoryRelationship<'a> = Id<ProductCategoryRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductCategoryRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductCategoryRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductCategoryRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CATEGORY_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, category) = param_from_chunks::<ProductCategory<'a>>(false, s, &mut i, strs)?;
        let (s, sub_category) = param_from_chunks::<ProductCategory<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            category,
            sub_category,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductCategoryRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.category.append_ids(_v);
        self.sub_category.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductClass_<'a> { // entity
    pub id: Identifier<'a>,
    pub product_concept__name: Label<'a>,
    pub product_concept__description: Option<Text<'a>>,
    pub market_context: ProductConceptContext<'a>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductClass<'a> = Id<ProductClass_<'a>>;
impl<'a> FromEntity<'a> for ProductClass_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductClass(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductClass_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CLASS(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, product_concept__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, product_concept__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, market_context) = param_from_chunks::<ProductConceptContext<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            product_concept__name,
            product_concept__description,
            market_context,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductClass_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.product_concept__name.append_ids(_v);
        self.product_concept__description.append_ids(_v);
        self.market_context.append_ids(_v);
        self.characterized_object__name.append_ids(_v);
        self.characterized_object__description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductConcept_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub market_context: ProductConceptContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConcept<'a> = Id<ProductConcept_<'a>>;
impl<'a> FromEntity<'a> for ProductConcept_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConcept(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductConcept_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONCEPT(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, market_context) = param_from_chunks::<ProductConceptContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            market_context,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductConcept_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.market_context.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductConceptContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub market_segment_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptContext<'a> = Id<ProductConceptContext_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductConceptContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONCEPT_CONTEXT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ApplicationContext<'a>>(false, s, &mut i, strs)?;
        let (s, market_segment_type) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            market_segment_type,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductConceptContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
        self.market_segment_type.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductConceptFeature_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeature<'a> = Id<ProductConceptFeature_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductConceptFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductConceptFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductConceptFeatureAssociation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub concept: ProductConcept<'a>,
    pub feature: ProductConceptFeature<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureAssociation<'a> = Id<ProductConceptFeatureAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeatureAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeatureAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductConceptFeatureAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE_ASSOCIATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, concept) = param_from_chunks::<ProductConcept<'a>>(false, s, &mut i, strs)?;
        let (s, feature) = param_from_chunks::<ProductConceptFeature<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            concept,
            feature,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductConceptFeatureAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.concept.append_ids(_v);
        self.feature.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductConceptFeatureCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureCategory<'a> = Id<ProductConceptFeatureCategory_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeatureCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeatureCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductConceptFeatureCategory_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE_CATEGORY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductConceptFeatureCategory_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductConceptFeatureCategoryUsage_<'a> { // entity
    pub assigned_group: Group<'a>,
    pub items: Vec<CategoryUsageItem<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptFeatureCategoryUsage<'a> = Id<ProductConceptFeatureCategoryUsage_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptFeatureCategoryUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptFeatureCategoryUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductConceptFeatureCategoryUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE(")(strs[0])?;
        let (s, assigned_group) = param_from_chunks::<Group<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<CategoryUsageItem<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_group,
            items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductConceptFeatureCategoryUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_group.append_ids(_v);
        self.items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductConceptRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_concept: ProductConcept<'a>,
    pub related_product_concept: ProductConcept<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductConceptRelationship<'a> = Id<ProductConceptRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductConceptRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductConceptRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductConceptRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONCEPT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_concept) = param_from_chunks::<ProductConcept<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_concept) = param_from_chunks::<ProductConcept<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_product_concept,
            related_product_concept,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductConceptRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_concept.append_ids(_v);
        self.related_product_concept.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub discipline_type: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductContext<'a> = Id<ProductContext_<'a>>;
impl<'a> FromEntity<'a> for ProductContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_CONTEXT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ApplicationContext<'a>>(false, s, &mut i, strs)?;
        let (s, discipline_type) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            discipline_type,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
        self.discipline_type.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinition_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinition<'a> = Id<ProductDefinition_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, formation) = param_from_chunks::<ProductDefinitionFormation<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ProductDefinitionContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            description,
            formation,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.description.append_ids(_v);
        self.formation.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionContext_<'a> { // entity
    pub name: Label<'a>,
    pub frame_of_reference: ApplicationContext<'a>,
    pub life_cycle_stage: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContext<'a> = Id<ProductDefinitionContext_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_CONTEXT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ApplicationContext<'a>>(false, s, &mut i, strs)?;
        let (s, life_cycle_stage) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            frame_of_reference,
            life_cycle_stage,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
        self.life_cycle_stage.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionContextAssociation_<'a> { // entity
    pub definition: ProductDefinition<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub role: ProductDefinitionContextRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContextAssociation<'a> = Id<ProductDefinitionContextAssociation_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionContextAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionContextAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionContextAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_CONTEXT_ASSOCIATION(")(strs[0])?;
        let (s, definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ProductDefinitionContext<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<ProductDefinitionContextRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            definition,
            frame_of_reference,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionContextAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.definition.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionContextRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionContextRole<'a> = Id<ProductDefinitionContextRole_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionContextRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionContextRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionContextRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_CONTEXT_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionContextRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub usage: ProductDefinitionRelationship<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionEffectivity<'a> = Id<ProductDefinitionEffectivity_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionEffectivity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_EFFECTIVITY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, usage) = param_from_chunks::<ProductDefinitionRelationship<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            usage,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionEffectivity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.usage.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionFormation_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub of_product: Product<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormation<'a> = Id<ProductDefinitionFormation_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionFormation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionFormation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionFormation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_FORMATION(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_product) = param_from_chunks::<Product<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            description,
            of_product,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionFormation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.description.append_ids(_v);
        self.of_product.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionFormationRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition_formation: ProductDefinitionFormation<'a>,
    pub related_product_definition_formation: ProductDefinitionFormation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormationRelationship<'a> = Id<ProductDefinitionFormationRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionFormationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionFormationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionFormationRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_FORMATION_RELATIONSHIP(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition_formation) = param_from_chunks::<ProductDefinitionFormation<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition_formation) = param_from_chunks::<ProductDefinitionFormation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition_formation,
            related_product_definition_formation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionFormationRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition_formation.append_ids(_v);
        self.related_product_definition_formation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionFormationWithSpecifiedSource_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub of_product: Product<'a>,
    pub make_or_buy: Source<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionFormationWithSpecifiedSource<'a> = Id<ProductDefinitionFormationWithSpecifiedSource_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionFormationWithSpecifiedSource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionFormationWithSpecifiedSource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionFormationWithSpecifiedSource_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_product) = param_from_chunks::<Product<'a>>(false, s, &mut i, strs)?;
        let (s, make_or_buy) = param_from_chunks::<Source<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            description,
            of_product,
            make_or_buy,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionFormationWithSpecifiedSource_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.description.append_ids(_v);
        self.of_product.append_ids(_v);
        self.make_or_buy.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionOccurrenceRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub occurrence: ProductDefinition<'a>,
    pub occurrence_usage: AssemblyComponentUsage<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionOccurrenceRelationship<'a> = Id<ProductDefinitionOccurrenceRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionOccurrenceRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionOccurrenceRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionOccurrenceRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, occurrence) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, occurrence_usage) = param_from_chunks::<AssemblyComponentUsage<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            occurrence,
            occurrence_usage,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionOccurrenceRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.occurrence.append_ids(_v);
        self.occurrence_usage.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionProcess_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionProcess<'a> = Id<ProductDefinitionProcess_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionProcess_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionProcess(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionProcess_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_PROCESS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(false, s, &mut i, strs)?;
        let (s, identification) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionProcess_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
        self.identification.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionRelationship<'a> = Id<ProductDefinitionRelationship_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_RELATIONSHIP(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductDefinitionResource_<'a> { // entity
    pub name: Label<'a>,
    pub action_resource__description: Option<Text<'a>>,
    pub usage: Vec<SupportedItem<'a>>,
    pub kind: ActionResourceType<'a>,
    pub id: Identifier<'a>,
    pub product_definition__description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionResource<'a> = Id<ProductDefinitionResource_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionResource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionResource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionResource_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_RESOURCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, action_resource__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, usage) = param_from_chunks::<Vec<SupportedItem<'a>>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<ActionResourceType<'a>>(false, s, &mut i, strs)?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, product_definition__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, formation) = param_from_chunks::<ProductDefinitionFormation<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ProductDefinitionContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            action_resource__description,
            usage,
            kind,
            id,
            product_definition__description,
            formation,
            frame_of_reference,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionResource_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.action_resource__description.append_ids(_v);
        self.usage.append_ids(_v);
        self.kind.append_ids(_v);
        self.id.append_ids(_v);
        self.product_definition__description.append_ids(_v);
        self.formation.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionShape_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionShape<'a> = Id<ProductDefinitionShape_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionShape_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionShape(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionShape_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_SHAPE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<CharacterizedDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionShape_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionSubstitute_<'a> { // entity
    pub description: Option<Text<'a>>,
    pub context_relationship: ProductDefinitionRelationship<'a>,
    pub substitute_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionSubstitute<'a> = Id<ProductDefinitionSubstitute_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionSubstitute_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionSubstitute(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionSubstitute_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_SUBSTITUTE(")(strs[0])?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, context_relationship) = param_from_chunks::<ProductDefinitionRelationship<'a>>(false, s, &mut i, strs)?;
        let (s, substitute_definition) = param_from_chunks::<ProductDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            description,
            context_relationship,
            substitute_definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionSubstitute_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.description.append_ids(_v);
        self.context_relationship.append_ids(_v);
        self.substitute_definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionUsage<'a> = Id<ProductDefinitionUsage_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_USAGE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductDefinitionWithAssociatedDocuments_<'a> { // entity
    pub id: Identifier<'a>,
    pub description: Option<Text<'a>>,
    pub formation: ProductDefinitionFormation<'a>,
    pub frame_of_reference: ProductDefinitionContext<'a>,
    pub documentation_ids: Vec<Document<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductDefinitionWithAssociatedDocuments<'a> = Id<ProductDefinitionWithAssociatedDocuments_<'a>>;
impl<'a> FromEntity<'a> for ProductDefinitionWithAssociatedDocuments_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductDefinitionWithAssociatedDocuments(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductDefinitionWithAssociatedDocuments_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, formation) = param_from_chunks::<ProductDefinitionFormation<'a>>(false, s, &mut i, strs)?;
        let (s, frame_of_reference) = param_from_chunks::<ProductDefinitionContext<'a>>(false, s, &mut i, strs)?;
        let (s, documentation_ids) = param_from_chunks::<Vec<Document<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            description,
            formation,
            frame_of_reference,
            documentation_ids,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductDefinitionWithAssociatedDocuments_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.description.append_ids(_v);
        self.formation.append_ids(_v);
        self.frame_of_reference.append_ids(_v);
        self.documentation_ids.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductIdentification_<'a> { // entity
    pub id: Identifier<'a>,
    pub configuration_item__name: Label<'a>,
    pub configuration_item__description: Option<Text<'a>>,
    pub item_concept: ProductConcept<'a>,
    pub purpose: Option<Label<'a>>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductIdentification<'a> = Id<ProductIdentification_<'a>>;
impl<'a> FromEntity<'a> for ProductIdentification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductIdentification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductIdentification_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_IDENTIFICATION(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, item_concept) = param_from_chunks::<ProductConcept<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            configuration_item__name,
            configuration_item__description,
            item_concept,
            purpose,
            characterized_object__name,
            characterized_object__description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductIdentification_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.configuration_item__name.append_ids(_v);
        self.configuration_item__description.append_ids(_v);
        self.item_concept.append_ids(_v);
        self.purpose.append_ids(_v);
        self.characterized_object__name.append_ids(_v);
        self.characterized_object__description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductOrFormationOrDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ProductOrFormationOrDefinition<'a> = Id<ProductOrFormationOrDefinition_<'a>>;

#[derive(Debug)]
pub enum ProductOrPresentationSpace<'a> { // enum
    ProductShapeSpace,
    PresentationAreaSpace,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ProductOrPresentationSpace<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ProductOrPresentationSpace::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "PRODUCT_SHAPE_SPACE" => ProductShapeSpace,
            "PRESENTATION_AREA_SPACE" => PresentationAreaSpace,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for ProductOrPresentationSpace<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct ProductProcessPlan_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductProcessPlan<'a> = Id<ProductProcessPlan_<'a>>;
impl<'a> FromEntity<'a> for ProductProcessPlan_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductProcessPlan(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductProcessPlan_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_PROCESS_PLAN(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(false, s, &mut i, strs)?;
        let (s, identification) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductProcessPlan_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
        self.identification.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProductRelatedProductCategory_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub products: Vec<Product<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductRelatedProductCategory<'a> = Id<ProductRelatedProductCategory_<'a>>;
impl<'a> FromEntity<'a> for ProductRelatedProductCategory_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductRelatedProductCategory(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductRelatedProductCategory_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_RELATED_PRODUCT_CATEGORY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, products) = param_from_chunks::<Vec<Product<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            products,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductRelatedProductCategory_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.products.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct ProductSpecification_<'a> { // entity
    pub configuration_item__id: Identifier<'a>,
    pub configuration_item__name: Label<'a>,
    pub configuration_item__description: Option<Text<'a>>,
    pub configuration_item__item_concept: ProductConcept<'a>,
    pub configuration_item__purpose: Option<Label<'a>>,
    pub characterized_object__name: Label<'a>,
    pub characterized_object__description: Option<Text<'a>>,
    pub item_concept_feature: Vec<ProductConceptFeatureAssociation<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProductSpecification<'a> = Id<ProductSpecification_<'a>>;
impl<'a> FromEntity<'a> for ProductSpecification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProductSpecification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProductSpecification_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PRODUCT_SPECIFICATION(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, configuration_item__id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__item_concept) = param_from_chunks::<ProductConcept<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, configuration_item__purpose) = param_from_chunks::<Option<Label<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, characterized_object__description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, item_concept_feature) = param_from_chunks::<Vec<ProductConceptFeatureAssociation<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            configuration_item__id,
            configuration_item__name,
            configuration_item__description,
            configuration_item__item_concept,
            configuration_item__purpose,
            characterized_object__name,
            characterized_object__description,
            item_concept_feature,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProductSpecification_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.configuration_item__id.append_ids(_v);
        self.configuration_item__name.append_ids(_v);
        self.configuration_item__description.append_ids(_v);
        self.configuration_item__item_concept.append_ids(_v);
        self.configuration_item__purpose.append_ids(_v);
        self.characterized_object__name.append_ids(_v);
        self.characterized_object__description.append_ids(_v);
        self.item_concept_feature.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProjectedZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    pub projection_end: ShapeAspect<'a>,
    pub projected_length: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectedZoneDefinition<'a> = Id<ProjectedZoneDefinition_<'a>>;
impl<'a> FromEntity<'a> for ProjectedZoneDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProjectedZoneDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProjectedZoneDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROJECTED_ZONE_DEFINITION(")(strs[0])?;
        let (s, zone) = param_from_chunks::<ToleranceZone<'a>>(false, s, &mut i, strs)?;
        let (s, boundaries) = param_from_chunks::<Vec<ShapeAspect<'a>>>(false, s, &mut i, strs)?;
        let (s, projection_end) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, projected_length) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            zone,
            boundaries,
            projection_end,
            projected_length,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProjectedZoneDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.zone.append_ids(_v);
        self.boundaries.append_ids(_v);
        self.projection_end.append_ids(_v);
        self.projected_length.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProjectionCurve_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectionCurve<'a> = Id<ProjectionCurve_<'a>>;
impl<'a> FromEntity<'a> for ProjectionCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProjectionCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProjectionCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROJECTION_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProjectionCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ProjectionDirectedCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ProjectionDirectedCallout<'a> = Id<ProjectionDirectedCallout_<'a>>;
impl<'a> FromEntity<'a> for ProjectionDirectedCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ProjectionDirectedCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ProjectionDirectedCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROJECTION_DIRECTED_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ProjectionDirectedCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PromissoryUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PromissoryUsageOccurrence<'a> = Id<PromissoryUsageOccurrence_<'a>>;
impl<'a> FromEntity<'a> for PromissoryUsageOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PromissoryUsageOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PromissoryUsageOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROMISSORY_USAGE_OCCURRENCE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, reference_designator) = param_from_chunks::<Option<Identifier<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PromissoryUsageOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
        self.reference_designator.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PropertyDefinition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub definition: CharacterizedDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinition<'a> = Id<PropertyDefinition_<'a>>;
impl<'a> FromEntity<'a> for PropertyDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PropertyDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROPERTY_DEFINITION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, definition) = param_from_chunks::<CharacterizedDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PropertyDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PropertyDefinitionRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub relating_property_definition: PropertyDefinition<'a>,
    pub related_property_definition: PropertyDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinitionRelationship<'a> = Id<PropertyDefinitionRelationship_<'a>>;
impl<'a> FromEntity<'a> for PropertyDefinitionRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyDefinitionRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PropertyDefinitionRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROPERTY_DEFINITION_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, relating_property_definition) = param_from_chunks::<PropertyDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_property_definition) = param_from_chunks::<PropertyDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_property_definition,
            related_property_definition,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PropertyDefinitionRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_property_definition.append_ids(_v);
        self.related_property_definition.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PropertyDefinitionRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyDefinitionRepresentation<'a> = Id<PropertyDefinitionRepresentation_<'a>>;
impl<'a> FromEntity<'a> for PropertyDefinitionRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyDefinitionRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PropertyDefinitionRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROPERTY_DEFINITION_REPRESENTATION(")(strs[0])?;
        let (s, definition) = param_from_chunks::<RepresentedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, used_representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            definition,
            used_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PropertyDefinitionRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.definition.append_ids(_v);
        self.used_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct PropertyOrShapeSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type PropertyOrShapeSelect<'a> = Id<PropertyOrShapeSelect_<'a>>;

#[derive(Debug)]
pub struct PropertyProcess_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    pub identification: Identifier<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type PropertyProcess<'a> = Id<PropertyProcess_<'a>>;
impl<'a> FromEntity<'a> for PropertyProcess_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::PropertyProcess(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for PropertyProcess_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("PROPERTY_PROCESS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(false, s, &mut i, strs)?;
        let (s, identification) = param_from_chunks::<Identifier<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            identification,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for PropertyProcess_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
        self.identification.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct QualifiedRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub qualifiers: Vec<ValueQualifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QualifiedRepresentationItem<'a> = Id<QualifiedRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for QualifiedRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QualifiedRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for QualifiedRepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("QUALIFIED_REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, qualifiers) = param_from_chunks::<Vec<ValueQualifier<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            qualifiers,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for QualifiedRepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.qualifiers.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct QualitativeUncertainty_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    pub uncertainty_value: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QualitativeUncertainty<'a> = Id<QualitativeUncertainty_<'a>>;
impl<'a> FromEntity<'a> for QualitativeUncertainty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QualitativeUncertainty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for QualitativeUncertainty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("QUALITATIVE_UNCERTAINTY(")(strs[0])?;
        let (s, measure_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, uncertainty_value) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            measure_name,
            description,
            uncertainty_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for QualitativeUncertainty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.measure_name.append_ids(_v);
        self.description.append_ids(_v);
        self.uncertainty_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct QuantifiedAssemblyComponentUsage_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    pub quantity: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuantifiedAssemblyComponentUsage<'a> = Id<QuantifiedAssemblyComponentUsage_<'a>>;
impl<'a> FromEntity<'a> for QuantifiedAssemblyComponentUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QuantifiedAssemblyComponentUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for QuantifiedAssemblyComponentUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("QUANTIFIED_ASSEMBLY_COMPONENT_USAGE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, reference_designator) = param_from_chunks::<Option<Identifier<'a>>>(false, s, &mut i, strs)?;
        let (s, quantity) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            quantity,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for QuantifiedAssemblyComponentUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
        self.reference_designator.append_ids(_v);
        self.quantity.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct QuasiUniformCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuasiUniformCurve<'a> = Id<QuasiUniformCurve_<'a>>;
impl<'a> FromEntity<'a> for QuasiUniformCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QuasiUniformCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for QuasiUniformCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("QUASI_UNIFORM_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<CartesianPoint<'a>>>(false, s, &mut i, strs)?;
        let (s, curve_form) = param_from_chunks::<BSplineCurveForm<'a>>(false, s, &mut i, strs)?;
        let (s, closed_curve) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for QuasiUniformCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.curve_form.append_ids(_v);
        self.closed_curve.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct QuasiUniformSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type QuasiUniformSurface<'a> = Id<QuasiUniformSurface_<'a>>;
impl<'a> FromEntity<'a> for QuasiUniformSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::QuasiUniformSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for QuasiUniformSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("QUASI_UNIFORM_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, u_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, v_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<Vec<CartesianPoint<'a>>>>(false, s, &mut i, strs)?;
        let (s, surface_form) = param_from_chunks::<BSplineSurfaceForm<'a>>(false, s, &mut i, strs)?;
        let (s, u_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, v_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for QuasiUniformSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.u_degree.append_ids(_v);
        self.v_degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.surface_form.append_ids(_v);
        self.u_closed.append_ids(_v);
        self.v_closed.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RackAndPinionPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pinion_radius: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPair<'a> = Id<RackAndPinionPair_<'a>>;
impl<'a> FromEntity<'a> for RackAndPinionPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RackAndPinionPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RackAndPinionPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RACK_AND_PINION_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, pinion_radius) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pinion_radius,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RackAndPinionPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.pinion_radius.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RackAndPinionPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_rack_displacement: TranslationalRangeMeasure<'a>,
    pub upper_limit_rack_displacement: TranslationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPairRange<'a> = Id<RackAndPinionPairRange_<'a>>;
impl<'a> FromEntity<'a> for RackAndPinionPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RackAndPinionPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RackAndPinionPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RACK_AND_PINION_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_rack_displacement) = param_from_chunks::<TranslationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_rack_displacement) = param_from_chunks::<TranslationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_rack_displacement,
            upper_limit_rack_displacement,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RackAndPinionPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_rack_displacement.append_ids(_v);
        self.upper_limit_rack_displacement.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RackAndPinionPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_displacement: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RackAndPinionPairValue<'a> = Id<RackAndPinionPairValue_<'a>>;
impl<'a> FromEntity<'a> for RackAndPinionPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RackAndPinionPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RackAndPinionPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RACK_AND_PINION_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_displacement) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_displacement,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RackAndPinionPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_displacement.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RadiusDimension_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RadiusDimension<'a> = Id<RadiusDimension_<'a>>;
impl<'a> FromEntity<'a> for RadiusDimension_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RadiusDimension(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RadiusDimension_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RADIUS_DIMENSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RadiusDimension_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RatioMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for RatioMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for RatioMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct RatioMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RatioMeasureWithUnit<'a> = Id<RatioMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for RatioMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RatioMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RatioMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RATIO_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RatioMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RatioUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RatioUnit<'a> = Id<RatioUnit_<'a>>;
impl<'a> FromEntity<'a> for RatioUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RatioUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RatioUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RATIO_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RatioUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RationalBSplineCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    pub weights_data: Vec<f64>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RationalBSplineCurve<'a> = Id<RationalBSplineCurve_<'a>>;
impl<'a> FromEntity<'a> for RationalBSplineCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RationalBSplineCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RationalBSplineCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RATIONAL_B_SPLINE_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<CartesianPoint<'a>>>(false, s, &mut i, strs)?;
        let (s, curve_form) = param_from_chunks::<BSplineCurveForm<'a>>(false, s, &mut i, strs)?;
        let (s, closed_curve) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, weights_data) = param_from_chunks::<Vec<f64>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            weights_data,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RationalBSplineCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.curve_form.append_ids(_v);
        self.closed_curve.append_ids(_v);
        self.self_intersect.append_ids(_v);
        self.weights_data.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RationalBSplineSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    pub weights_data: Vec<Vec<f64>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RationalBSplineSurface<'a> = Id<RationalBSplineSurface_<'a>>;
impl<'a> FromEntity<'a> for RationalBSplineSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RationalBSplineSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RationalBSplineSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RATIONAL_B_SPLINE_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, u_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, v_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<Vec<CartesianPoint<'a>>>>(false, s, &mut i, strs)?;
        let (s, surface_form) = param_from_chunks::<BSplineSurfaceForm<'a>>(false, s, &mut i, strs)?;
        let (s, u_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, v_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, weights_data) = param_from_chunks::<Vec<Vec<f64>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            weights_data,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RationalBSplineSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.u_degree.append_ids(_v);
        self.v_degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.surface_form.append_ids(_v);
        self.u_closed.append_ids(_v);
        self.v_closed.append_ids(_v);
        self.self_intersect.append_ids(_v);
        self.weights_data.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RealDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealDefinedFunction<'a> = Id<RealDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for RealDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RealDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RealDefinedFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("REAL_DEFINED_FUNCTION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RealDefinedFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct RealLiteral_<'a> { // entity
    pub the_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealLiteral<'a> = Id<RealLiteral_<'a>>;
impl<'a> FromEntity<'a> for RealLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RealLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RealLiteral_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REAL_LITERAL(")(strs[0])?;
        let (s, the_value) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RealLiteral_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.the_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RealNumericVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RealNumericVariable<'a> = Id<RealNumericVariable_<'a>>;
impl<'a> FromEntity<'a> for RealNumericVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RealNumericVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RealNumericVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("REAL_NUMERIC_VARIABLE(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RealNumericVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct RectangularClosedProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularClosedProfile<'a> = Id<RectangularClosedProfile_<'a>>;
impl<'a> FromEntity<'a> for RectangularClosedProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularClosedProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RectangularClosedProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RECTANGULAR_CLOSED_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RectangularClosedProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RectangularCompositeSurface_<'a> { // entity
    pub name: Label<'a>,
    pub segments: Vec<Vec<SurfacePatch<'a>>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularCompositeSurface<'a> = Id<RectangularCompositeSurface_<'a>>;
impl<'a> FromEntity<'a> for RectangularCompositeSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularCompositeSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RectangularCompositeSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RECTANGULAR_COMPOSITE_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, segments) = param_from_chunks::<Vec<Vec<SurfacePatch<'a>>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            segments,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RectangularCompositeSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.segments.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RectangularPattern_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularPattern<'a> = Id<RectangularPattern_<'a>>;
impl<'a> FromEntity<'a> for RectangularPattern_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularPattern(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RectangularPattern_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RECTANGULAR_PATTERN(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RectangularPattern_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RectangularTrimmedSurface_<'a> { // entity
    pub name: Label<'a>,
    pub basis_surface: Surface<'a>,
    pub u1: ParameterValue<'a>,
    pub u2: ParameterValue<'a>,
    pub v1: ParameterValue<'a>,
    pub v2: ParameterValue<'a>,
    pub usense: bool,
    pub vsense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RectangularTrimmedSurface<'a> = Id<RectangularTrimmedSurface_<'a>>;
impl<'a> FromEntity<'a> for RectangularTrimmedSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RectangularTrimmedSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RectangularTrimmedSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RECTANGULAR_TRIMMED_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, u1) = param_from_chunks::<ParameterValue<'a>>(false, s, &mut i, strs)?;
        let (s, u2) = param_from_chunks::<ParameterValue<'a>>(false, s, &mut i, strs)?;
        let (s, v1) = param_from_chunks::<ParameterValue<'a>>(false, s, &mut i, strs)?;
        let (s, v2) = param_from_chunks::<ParameterValue<'a>>(false, s, &mut i, strs)?;
        let (s, usense) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, vsense) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_surface,
            u1,
            u2,
            v1,
            v2,
            usense,
            vsense,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RectangularTrimmedSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_surface.append_ids(_v);
        self.u1.append_ids(_v);
        self.u2.append_ids(_v);
        self.v1.append_ids(_v);
        self.v2.append_ids(_v);
        self.usense.append_ids(_v);
        self.vsense.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ReferencedModifiedDatum_<'a> { // entity
    pub precedence: i64,
    pub referenced_datum: Datum<'a>,
    pub modifier: LimitCondition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReferencedModifiedDatum<'a> = Id<ReferencedModifiedDatum_<'a>>;
impl<'a> FromEntity<'a> for ReferencedModifiedDatum_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ReferencedModifiedDatum(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ReferencedModifiedDatum_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REFERENCED_MODIFIED_DATUM(")(strs[0])?;
        let (s, precedence) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, referenced_datum) = param_from_chunks::<Datum<'a>>(false, s, &mut i, strs)?;
        let (s, modifier) = param_from_chunks::<LimitCondition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            precedence,
            referenced_datum,
            modifier,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ReferencedModifiedDatum_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.precedence.append_ids(_v);
        self.referenced_datum.append_ids(_v);
        self.modifier.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RelativeEventOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub base_event: EventOccurrence<'a>,
    pub offset: TimeMeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RelativeEventOccurrence<'a> = Id<RelativeEventOccurrence_<'a>>;
impl<'a> FromEntity<'a> for RelativeEventOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RelativeEventOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RelativeEventOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RELATIVE_EVENT_OCCURRENCE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, base_event) = param_from_chunks::<EventOccurrence<'a>>(false, s, &mut i, strs)?;
        let (s, offset) = param_from_chunks::<TimeMeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            base_event,
            offset,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RelativeEventOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.base_event.append_ids(_v);
        self.offset.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RenderingPropertiesSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RenderingPropertiesSelect<'a> = Id<RenderingPropertiesSelect_<'a>>;

#[allow(non_snake_case)]
#[derive(Debug)]
pub struct RepItemGroup_<'a> { // entity
    pub group__name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub representation_item__name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepItemGroup<'a> = Id<RepItemGroup_<'a>>;
impl<'a> FromEntity<'a> for RepItemGroup_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepItemGroup(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RepItemGroup_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REP_ITEM_GROUP(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, group__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            group__name,
            description,
            representation_item__name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RepItemGroup_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.group__name.append_ids(_v);
        self.description.append_ids(_v);
        self.representation_item__name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ReparametrisedCompositeCurveSegment_<'a> { // entity
    pub transition: TransitionCode<'a>,
    pub same_sense: bool,
    pub parent_curve: Curve<'a>,
    pub param_length: ParameterValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReparametrisedCompositeCurveSegment<'a> = Id<ReparametrisedCompositeCurveSegment_<'a>>;
impl<'a> FromEntity<'a> for ReparametrisedCompositeCurveSegment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ReparametrisedCompositeCurveSegment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ReparametrisedCompositeCurveSegment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPARAMETRISED_COMPOSITE_CURVE_SEGMENT(")(strs[0])?;
        let (s, transition) = param_from_chunks::<TransitionCode<'a>>(false, s, &mut i, strs)?;
        let (s, same_sense) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, parent_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, param_length) = param_from_chunks::<ParameterValue<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            transition,
            same_sense,
            parent_curve,
            param_length,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ReparametrisedCompositeCurveSegment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.transition.append_ids(_v);
        self.same_sense.append_ids(_v);
        self.parent_curve.append_ids(_v);
        self.param_length.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ReplicateFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ReplicateFeature<'a> = Id<ReplicateFeature_<'a>>;
impl<'a> FromEntity<'a> for ReplicateFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ReplicateFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ReplicateFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPLICATE_FEATURE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ReplicateFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Representation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Representation<'a> = Id<Representation_<'a>>;
impl<'a> FromEntity<'a> for Representation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Representation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Representation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Representation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RepresentationContext_<'a> { // entity
    pub context_identifier: Identifier<'a>,
    pub context_type: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationContext<'a> = Id<RepresentationContext_<'a>>;
impl<'a> FromEntity<'a> for RepresentationContext_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationContext(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RepresentationContext_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPRESENTATION_CONTEXT(")(strs[0])?;
        let (s, context_identifier) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, context_type) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            context_identifier,
            context_type,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RepresentationContext_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.context_identifier.append_ids(_v);
        self.context_type.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationItem<'a> = Id<RepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for RepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RepresentationMap_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationMap<'a> = Id<RepresentationMap_<'a>>;
impl<'a> FromEntity<'a> for RepresentationMap_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationMap(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RepresentationMap_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPRESENTATION_MAP(")(strs[0])?;
        let (s, mapping_origin) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, mapped_representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            mapping_origin,
            mapped_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RepresentationMap_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.mapping_origin.append_ids(_v);
        self.mapped_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationRelationship<'a> = Id<RepresentationRelationship_<'a>>;
impl<'a> FromEntity<'a> for RepresentationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RepresentationRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPRESENTATION_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RepresentationRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RepresentationRelationshipWithTransformation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub transformation_operator: Transformation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RepresentationRelationshipWithTransformation<'a> = Id<RepresentationRelationshipWithTransformation_<'a>>;
impl<'a> FromEntity<'a> for RepresentationRelationshipWithTransformation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RepresentationRelationshipWithTransformation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RepresentationRelationshipWithTransformation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, transformation_operator) = param_from_chunks::<Transformation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            transformation_operator,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RepresentationRelationshipWithTransformation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
        self.transformation_operator.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RepresentedDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RepresentedDefinition<'a> = Id<RepresentedDefinition_<'a>>;

#[derive(Debug)]
pub struct RequirementForActionResource_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub kind: ResourceRequirementType<'a>,
    pub operations: Vec<CharacterizedActionDefinition<'a>>,
    pub resources: Vec<ActionResource<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RequirementForActionResource<'a> = Id<RequirementForActionResource_<'a>>;
impl<'a> FromEntity<'a> for RequirementForActionResource_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RequirementForActionResource(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RequirementForActionResource_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REQUIREMENT_FOR_ACTION_RESOURCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, kind) = param_from_chunks::<ResourceRequirementType<'a>>(false, s, &mut i, strs)?;
        let (s, operations) = param_from_chunks::<Vec<CharacterizedActionDefinition<'a>>>(false, s, &mut i, strs)?;
        let (s, resources) = param_from_chunks::<Vec<ActionResource<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            kind,
            operations,
            resources,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RequirementForActionResource_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.kind.append_ids(_v);
        self.operations.append_ids(_v);
        self.resources.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ResourceProperty_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub resource: CharacterizedResourceDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourceProperty<'a> = Id<ResourceProperty_<'a>>;
impl<'a> FromEntity<'a> for ResourceProperty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResourceProperty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ResourceProperty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RESOURCE_PROPERTY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, resource) = param_from_chunks::<CharacterizedResourceDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            resource,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ResourceProperty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.resource.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ResourcePropertyRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub property: ResourceProperty<'a>,
    pub representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourcePropertyRepresentation<'a> = Id<ResourcePropertyRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ResourcePropertyRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResourcePropertyRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ResourcePropertyRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RESOURCE_PROPERTY_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, property) = param_from_chunks::<ResourceProperty<'a>>(false, s, &mut i, strs)?;
        let (s, representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            property,
            representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ResourcePropertyRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.property.append_ids(_v);
        self.representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ResourceRequirementType_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResourceRequirementType<'a> = Id<ResourceRequirementType_<'a>>;
impl<'a> FromEntity<'a> for ResourceRequirementType_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResourceRequirementType(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ResourceRequirementType_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RESOURCE_REQUIREMENT_TYPE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ResourceRequirementType_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ResultingPath_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    pub related_frame: RigidPlacement<'a>,
    pub controlling_joints: Vec<KinematicJoint<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ResultingPath<'a> = Id<ResultingPath_<'a>>;
impl<'a> FromEntity<'a> for ResultingPath_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ResultingPath(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ResultingPath_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RESULTING_PATH(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, related_frame) = param_from_chunks::<RigidPlacement<'a>>(false, s, &mut i, strs)?;
        let (s, controlling_joints) = param_from_chunks::<Vec<KinematicJoint<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            related_frame,
            controlling_joints,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ResultingPath_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
        self.related_frame.append_ids(_v);
        self.controlling_joints.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Retention_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub chosen_method: ActionMethod<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Retention<'a> = Id<Retention_<'a>>;
impl<'a> FromEntity<'a> for Retention_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Retention(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Retention_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RETENTION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, chosen_method) = param_from_chunks::<ActionMethod<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            chosen_method,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Retention_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.chosen_method.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum ReversibleTopology<'a> { // select
    ReversibleTopologyItem(ReversibleTopologyItem<'a>),
    ListOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    SetOfReversibleTopologyItem(Vec<ReversibleTopologyItem<'a>>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ReversibleTopology<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<ReversibleTopologyItem<'a>>::parse, ReversibleTopology::ReversibleTopologyItem),
            map(delimited(tag("LIST_OF_REVERSIBLE_TOPOLOGY_ITEM("), <Vec<ReversibleTopologyItem<'a>>>::parse, char(')')), ReversibleTopology::ListOfReversibleTopologyItem),
            map(delimited(tag("SET_OF_REVERSIBLE_TOPOLOGY_ITEM("), <Vec<ReversibleTopologyItem<'a>>>::parse, char(')')), ReversibleTopology::SetOfReversibleTopologyItem),
        ))(s)
    }
}
impl<'a> HasId for ReversibleTopology<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            ReversibleTopology::ReversibleTopologyItem(c) => c.append_ids(_v),
            ReversibleTopology::ListOfReversibleTopologyItem(c) => c.append_ids(_v),
            ReversibleTopology::SetOfReversibleTopologyItem(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct ReversibleTopologyItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ReversibleTopologyItem<'a> = Id<ReversibleTopologyItem_<'a>>;

#[derive(Debug)]
pub struct RevolutePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePair<'a> = Id<RevolutePair_<'a>>;
impl<'a> FromEntity<'a> for RevolutePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolutePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RevolutePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REVOLUTE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RevolutePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RevolutePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePairRange<'a> = Id<RevolutePairRange_<'a>>;
impl<'a> FromEntity<'a> for RevolutePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolutePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RevolutePairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REVOLUTE_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RevolutePairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_actual_rotation.append_ids(_v);
        self.upper_limit_actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RevolutePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolutePairValue<'a> = Id<RevolutePairValue_<'a>>;
impl<'a> FromEntity<'a> for RevolutePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolutePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RevolutePairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REVOLUTE_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_rotation) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RevolutePairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RevolvedAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub axis: Axis1Placement<'a>,
    pub angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolvedAreaSolid<'a> = Id<RevolvedAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for RevolvedAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolvedAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RevolvedAreaSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REVOLVED_AREA_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_area) = param_from_chunks::<CurveBoundedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, axis) = param_from_chunks::<Axis1Placement<'a>>(false, s, &mut i, strs)?;
        let (s, angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_area,
            axis,
            angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RevolvedAreaSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_area.append_ids(_v);
        self.axis.append_ids(_v);
        self.angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RevolvedFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    pub axis: Axis1Placement<'a>,
    pub angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RevolvedFaceSolid<'a> = Id<RevolvedFaceSolid_<'a>>;
impl<'a> FromEntity<'a> for RevolvedFaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RevolvedFaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RevolvedFaceSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("REVOLVED_FACE_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_face) = param_from_chunks::<FaceSurface<'a>>(false, s, &mut i, strs)?;
        let (s, axis) = param_from_chunks::<Axis1Placement<'a>>(false, s, &mut i, strs)?;
        let (s, angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_face,
            axis,
            angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RevolvedFaceSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_face.append_ids(_v);
        self.axis.append_ids(_v);
        self.angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Rib_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Rib<'a> = Id<Rib_<'a>>;
impl<'a> FromEntity<'a> for Rib_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Rib(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Rib_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RIB(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Rib_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RightAngularWedge_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub x: PositiveLengthMeasure<'a>,
    pub y: PositiveLengthMeasure<'a>,
    pub z: PositiveLengthMeasure<'a>,
    pub ltx: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightAngularWedge<'a> = Id<RightAngularWedge_<'a>>;
impl<'a> FromEntity<'a> for RightAngularWedge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RightAngularWedge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RightAngularWedge_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RIGHT_ANGULAR_WEDGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, x) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, y) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, z) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, ltx) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            x,
            y,
            z,
            ltx,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RightAngularWedge_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.x.append_ids(_v);
        self.y.append_ids(_v);
        self.z.append_ids(_v);
        self.ltx.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RightCircularCone_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub height: PositiveLengthMeasure<'a>,
    pub radius: LengthMeasure<'a>,
    pub semi_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightCircularCone<'a> = Id<RightCircularCone_<'a>>;
impl<'a> FromEntity<'a> for RightCircularCone_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RightCircularCone(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RightCircularCone_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RIGHT_CIRCULAR_CONE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis1Placement<'a>>(false, s, &mut i, strs)?;
        let (s, height) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, semi_angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            height,
            radius,
            semi_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RightCircularCone_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.height.append_ids(_v);
        self.radius.append_ids(_v);
        self.semi_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RightCircularCylinder_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub height: PositiveLengthMeasure<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RightCircularCylinder<'a> = Id<RightCircularCylinder_<'a>>;
impl<'a> FromEntity<'a> for RightCircularCylinder_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RightCircularCylinder(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RightCircularCylinder_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RIGHT_CIRCULAR_CYLINDER(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis1Placement<'a>>(false, s, &mut i, strs)?;
        let (s, height) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            height,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RightCircularCylinder_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.height.append_ids(_v);
        self.radius.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RigidPlacement_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RigidPlacement<'a> = Id<RigidPlacement_<'a>>;

#[derive(Debug)]
pub struct RoleAssociation_<'a> { // entity
    pub role: ObjectRole<'a>,
    pub item_with_role: RoleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoleAssociation<'a> = Id<RoleAssociation_<'a>>;
impl<'a> FromEntity<'a> for RoleAssociation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoleAssociation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RoleAssociation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROLE_ASSOCIATION(")(strs[0])?;
        let (s, role) = param_from_chunks::<ObjectRole<'a>>(false, s, &mut i, strs)?;
        let (s, item_with_role) = param_from_chunks::<RoleSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            role,
            item_with_role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RoleAssociation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.role.append_ids(_v);
        self.item_with_role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RoleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type RoleSelect<'a> = Id<RoleSelect_<'a>>;

#[derive(Debug)]
pub struct RollingCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingCurvePair<'a> = Id<RollingCurvePair_<'a>>;
impl<'a> FromEntity<'a> for RollingCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RollingCurvePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROLLING_CURVE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, curve_1) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, curve_2) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            curve_1,
            curve_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RollingCurvePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.curve_1.append_ids(_v);
        self.curve_2.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RollingCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve_1: PointOnCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingCurvePairValue<'a> = Id<RollingCurvePairValue_<'a>>;
impl<'a> FromEntity<'a> for RollingCurvePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingCurvePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RollingCurvePairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROLLING_CURVE_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_curve_1) = param_from_chunks::<PointOnCurve<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_curve_1,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RollingCurvePairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_point_on_curve_1.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RollingSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingSurfacePair<'a> = Id<RollingSurfacePair_<'a>>;
impl<'a> FromEntity<'a> for RollingSurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingSurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RollingSurfacePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROLLING_SURFACE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, surface_1) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, surface_2) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            surface_1,
            surface_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RollingSurfacePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.surface_1.append_ids(_v);
        self.surface_2.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RollingSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface: PointOnSurface<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RollingSurfacePairValue<'a> = Id<RollingSurfacePairValue_<'a>>;
impl<'a> FromEntity<'a> for RollingSurfacePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RollingSurfacePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RollingSurfacePairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROLLING_SURFACE_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_surface) = param_from_chunks::<PointOnSurface<'a>>(false, s, &mut i, strs)?;
        let (s, actual_rotation) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_surface,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RollingSurfacePairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_point_on_surface.append_ids(_v);
        self.actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RotationAboutDirection_<'a> { // entity
    pub direction_of_axis: Direction<'a>,
    pub rotation_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RotationAboutDirection<'a> = Id<RotationAboutDirection_<'a>>;
impl<'a> FromEntity<'a> for RotationAboutDirection_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RotationAboutDirection(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RotationAboutDirection_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROTATION_ABOUT_DIRECTION(")(strs[0])?;
        let (s, direction_of_axis) = param_from_chunks::<Direction<'a>>(false, s, &mut i, strs)?;
        let (s, rotation_angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            direction_of_axis,
            rotation_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RotationAboutDirection_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.direction_of_axis.append_ids(_v);
        self.rotation_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum RotationalRangeMeasure<'a> { // select
    PlaneAngleMeasure(PlaneAngleMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for RotationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("PLANE_ANGLE_MEASURE("), <PlaneAngleMeasure<'a>>::parse, char(')')), RotationalRangeMeasure::PlaneAngleMeasure),
            map(delimited(tag("UNLIMITED_RANGE("), <UnlimitedRange<'a>>::parse, char(')')), RotationalRangeMeasure::UnlimitedRange),
        ))(s)
    }
}
impl<'a> HasId for RotationalRangeMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            RotationalRangeMeasure::PlaneAngleMeasure(c) => c.append_ids(_v),
            RotationalRangeMeasure::UnlimitedRange(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct RoundHole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundHole<'a> = Id<RoundHole_<'a>>;
impl<'a> FromEntity<'a> for RoundHole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoundHole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RoundHole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROUND_HOLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RoundHole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RoundedUProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundedUProfile<'a> = Id<RoundedUProfile_<'a>>;
impl<'a> FromEntity<'a> for RoundedUProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoundedUProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RoundedUProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROUNDED_U_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RoundedUProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RoundnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RoundnessTolerance<'a> = Id<RoundnessTolerance_<'a>>;
impl<'a> FromEntity<'a> for RoundnessTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RoundnessTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RoundnessTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("ROUNDNESS_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RoundnessTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RuledSurfaceSweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub directrix: Curve<'a>,
    pub start_param: f64,
    pub end_param: f64,
    pub reference_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RuledSurfaceSweptAreaSolid<'a> = Id<RuledSurfaceSweptAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for RuledSurfaceSweptAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RuledSurfaceSweptAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RuledSurfaceSweptAreaSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RULED_SURFACE_SWEPT_AREA_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_area) = param_from_chunks::<CurveBoundedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, directrix) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, start_param) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, end_param) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, reference_surface) = param_from_chunks::<Surface<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_area,
            directrix,
            start_param,
            end_param,
            reference_surface,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RuledSurfaceSweptAreaSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_area.append_ids(_v);
        self.directrix.append_ids(_v);
        self.start_param.append_ids(_v);
        self.end_param.append_ids(_v);
        self.reference_surface.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RunoutZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    pub orientation: RunoutZoneOrientation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneDefinition<'a> = Id<RunoutZoneDefinition_<'a>>;
impl<'a> FromEntity<'a> for RunoutZoneDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RunoutZoneDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RunoutZoneDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RUNOUT_ZONE_DEFINITION(")(strs[0])?;
        let (s, zone) = param_from_chunks::<ToleranceZone<'a>>(false, s, &mut i, strs)?;
        let (s, boundaries) = param_from_chunks::<Vec<ShapeAspect<'a>>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<RunoutZoneOrientation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            zone,
            boundaries,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RunoutZoneDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.zone.append_ids(_v);
        self.boundaries.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RunoutZoneOrientation_<'a> { // entity
    pub angle: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneOrientation<'a> = Id<RunoutZoneOrientation_<'a>>;
impl<'a> FromEntity<'a> for RunoutZoneOrientation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RunoutZoneOrientation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RunoutZoneOrientation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RUNOUT_ZONE_ORIENTATION(")(strs[0])?;
        let (s, angle) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RunoutZoneOrientation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct RunoutZoneOrientationReferenceDirection_<'a> { // entity
    pub angle: MeasureWithUnit<'a>,
    pub orientation_defining_relationship: ShapeAspectRelationship<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type RunoutZoneOrientationReferenceDirection<'a> = Id<RunoutZoneOrientationReferenceDirection_<'a>>;
impl<'a> FromEntity<'a> for RunoutZoneOrientationReferenceDirection_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::RunoutZoneOrientationReferenceDirection(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for RunoutZoneOrientationReferenceDirection_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION(")(strs[0])?;
        let (s, angle) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, orientation_defining_relationship) = param_from_chunks::<ShapeAspectRelationship<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            angle,
            orientation_defining_relationship,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for RunoutZoneOrientationReferenceDirection_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.angle.append_ids(_v);
        self.orientation_defining_relationship.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ScrewPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub pitch: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPair<'a> = Id<ScrewPair_<'a>>;
impl<'a> FromEntity<'a> for ScrewPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ScrewPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ScrewPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SCREW_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, pitch) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            pitch,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ScrewPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.pitch.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ScrewPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPairRange<'a> = Id<ScrewPairRange_<'a>>;
impl<'a> FromEntity<'a> for ScrewPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ScrewPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ScrewPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SCREW_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ScrewPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_actual_rotation.append_ids(_v);
        self.upper_limit_actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ScrewPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ScrewPairValue<'a> = Id<ScrewPairValue_<'a>>;
impl<'a> FromEntity<'a> for ScrewPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ScrewPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ScrewPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SCREW_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_rotation) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ScrewPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SeamCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: ArrayVec::<PcurveOrSurface<'a>, 2>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SeamCurve<'a> = Id<SeamCurve_<'a>>;
impl<'a> FromEntity<'a> for SeamCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SeamCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SeamCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SEAM_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, curve_3d) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, associated_geometry) = param_from_chunks::<ArrayVec::<PcurveOrSurface<'a>, 2>>(false, s, &mut i, strs)?;
        let (s, master_representation) = param_from_chunks::<PreferredSurfaceCurveRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SeamCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.curve_3d.append_ids(_v);
        self.associated_geometry.append_ids(_v);
        self.master_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SeamEdge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub edge_element: Edge<'a>,
    pub orientation: bool,
    pub pcurve_reference: Pcurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SeamEdge<'a> = Id<SeamEdge_<'a>>;
impl<'a> FromEntity<'a> for SeamEdge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SeamEdge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SeamEdge_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SEAM_EDGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, edge_start) = param_from_chunks::<Vertex<'a>>(false, s, &mut i, strs)?;
        let (s, edge_end) = param_from_chunks::<Vertex<'a>>(false, s, &mut i, strs)?;
        let (s, edge_element) = param_from_chunks::<Edge<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, pcurve_reference) = param_from_chunks::<Pcurve<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            edge_start,
            edge_end,
            edge_element,
            orientation,
            pcurve_reference,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SeamEdge_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.edge_start.append_ids(_v);
        self.edge_end.append_ids(_v);
        self.edge_element.append_ids(_v);
        self.orientation.append_ids(_v);
        self.pcurve_reference.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SecondInMinute<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SecondInMinute<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for SecondInMinute<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct SecurityClassification_<'a> { // entity
    pub name: Label<'a>,
    pub purpose: Text<'a>,
    pub security_level: SecurityClassificationLevel<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassification<'a> = Id<SecurityClassification_<'a>>;
impl<'a> FromEntity<'a> for SecurityClassification_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SecurityClassification(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SecurityClassification_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SECURITY_CLASSIFICATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, security_level) = param_from_chunks::<SecurityClassificationLevel<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            purpose,
            security_level,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SecurityClassification_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.purpose.append_ids(_v);
        self.security_level.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SecurityClassificationAssignment_<'a> { // entity
    pub assigned_security_classification: SecurityClassification<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassificationAssignment<'a> = Id<SecurityClassificationAssignment_<'a>>;
impl<'a> FromEntity<'a> for SecurityClassificationAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SecurityClassificationAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SecurityClassificationAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SECURITY_CLASSIFICATION_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_security_classification) = param_from_chunks::<SecurityClassification<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_security_classification,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SecurityClassificationAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_security_classification.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SecurityClassificationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SecurityClassificationItem<'a> = Id<SecurityClassificationItem_<'a>>;

#[derive(Debug)]
pub struct SecurityClassificationLevel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SecurityClassificationLevel<'a> = Id<SecurityClassificationLevel_<'a>>;
impl<'a> FromEntity<'a> for SecurityClassificationLevel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SecurityClassificationLevel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SecurityClassificationLevel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SECURITY_CLASSIFICATION_LEVEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SecurityClassificationLevel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SerialNumberedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_start_id: Identifier<'a>,
    pub effectivity_end_id: Option<Identifier<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SerialNumberedEffectivity<'a> = Id<SerialNumberedEffectivity_<'a>>;
impl<'a> FromEntity<'a> for SerialNumberedEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SerialNumberedEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SerialNumberedEffectivity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SERIAL_NUMBERED_EFFECTIVITY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, effectivity_start_id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, effectivity_end_id) = param_from_chunks::<Option<Identifier<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            effectivity_start_id,
            effectivity_end_id,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SerialNumberedEffectivity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.effectivity_start_id.append_ids(_v);
        self.effectivity_end_id.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SetOfReversibleTopologyItem<'a>(pub Vec<ReversibleTopologyItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetOfReversibleTopologyItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<ReversibleTopologyItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for SetOfReversibleTopologyItem<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        for i in &self.0 {
            i.append_ids(v);
        }
    }
}

#[derive(Debug)]
pub struct SetRepresentationItem<'a>(pub Vec<RepresentationItem<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for SetRepresentationItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<RepresentationItem<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for SetRepresentationItem<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        for i in &self.0 {
            i.append_ids(v);
        }
    }
}

#[derive(Debug)]
pub enum ShadingCurveMethod<'a> { // enum
    ConstantColour,
    LinearColour,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingCurveMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingCurveMethod::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "CONSTANT_COLOUR" => ConstantColour,
            "LINEAR_COLOUR" => LinearColour,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for ShadingCurveMethod<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub enum ShadingSurfaceMethod<'a> { // enum
    ConstantShading,
    ColourShading,
    DotShading,
    NormalShading,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for ShadingSurfaceMethod<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use ShadingSurfaceMethod::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "CONSTANT_SHADING" => ConstantShading,
            "COLOUR_SHADING" => ColourShading,
            "DOT_SHADING" => DotShading,
            "NORMAL_SHADING" => NormalShading,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for ShadingSurfaceMethod<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct ShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspect<'a> = Id<ShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeAspect_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_ASPECT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeAspect_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeAspectAssociativity_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectAssociativity<'a> = Id<ShapeAspectAssociativity_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectAssociativity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectAssociativity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeAspectAssociativity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_ASPECT_ASSOCIATIVITY(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeAspectAssociativity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeAspectDerivingRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectDerivingRelationship<'a> = Id<ShapeAspectDerivingRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectDerivingRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectDerivingRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeAspectDerivingRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_ASPECT_DERIVING_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeAspectDerivingRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeAspectRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectRelationship<'a> = Id<ShapeAspectRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeAspectRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_ASPECT_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeAspectRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeAspectTransition_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeAspectTransition<'a> = Id<ShapeAspectTransition_<'a>>;
impl<'a> FromEntity<'a> for ShapeAspectTransition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeAspectTransition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeAspectTransition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_ASPECT_TRANSITION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeAspectTransition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeDefiningRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_shape_aspect: ShapeAspect<'a>,
    pub related_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDefiningRelationship<'a> = Id<ShapeDefiningRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeDefiningRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeDefiningRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeDefiningRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_DEFINING_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, related_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            relating_shape_aspect,
            related_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeDefiningRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_shape_aspect.append_ids(_v);
        self.related_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ShapeDefinition<'a> = Id<ShapeDefinition_<'a>>;

#[derive(Debug)]
pub struct ShapeDefinitionRepresentation_<'a> { // entity
    pub definition: RepresentedDefinition<'a>,
    pub used_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDefinitionRepresentation<'a> = Id<ShapeDefinitionRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ShapeDefinitionRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeDefinitionRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeDefinitionRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_DEFINITION_REPRESENTATION(")(strs[0])?;
        let (s, definition) = param_from_chunks::<RepresentedDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, used_representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            definition,
            used_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeDefinitionRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.definition.append_ids(_v);
        self.used_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeDimensionRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeDimensionRepresentation<'a> = Id<ShapeDimensionRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ShapeDimensionRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeDimensionRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeDimensionRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_DIMENSION_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeDimensionRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentation<'a> = Id<ShapeRepresentation_<'a>>;
impl<'a> FromEntity<'a> for ShapeRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeRepresentationRelationship_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub rep_1: Representation<'a>,
    pub rep_2: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentationRelationship<'a> = Id<ShapeRepresentationRelationship_<'a>>;
impl<'a> FromEntity<'a> for ShapeRepresentationRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeRepresentationRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeRepresentationRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_REPRESENTATION_RELATIONSHIP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, rep_1) = param_from_chunks::<Representation<'a>>(false, s, &mut i, strs)?;
        let (s, rep_2) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            rep_1,
            rep_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeRepresentationRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.rep_1.append_ids(_v);
        self.rep_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ShapeRepresentationWithParameters_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShapeRepresentationWithParameters<'a> = Id<ShapeRepresentationWithParameters_<'a>>;
impl<'a> FromEntity<'a> for ShapeRepresentationWithParameters_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShapeRepresentationWithParameters(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShapeRepresentationWithParameters_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHAPE_REPRESENTATION_WITH_PARAMETERS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShapeRepresentationWithParameters_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Shell_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Shell<'a> = Id<Shell_<'a>>;

#[derive(Debug)]
pub struct ShellBasedSurfaceModel_<'a> { // entity
    pub name: Label<'a>,
    pub sbsm_boundary: Vec<Shell<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ShellBasedSurfaceModel<'a> = Id<ShellBasedSurfaceModel_<'a>>;
impl<'a> FromEntity<'a> for ShellBasedSurfaceModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ShellBasedSurfaceModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ShellBasedSurfaceModel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SHELL_BASED_SURFACE_MODEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, sbsm_boundary) = param_from_chunks::<Vec<Shell<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            sbsm_boundary,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ShellBasedSurfaceModel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.sbsm_boundary.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum SiPrefix<'a> { // enum
    Exa,
    Peta,
    Tera,
    Giga,
    Mega,
    Kilo,
    Hecto,
    Deca,
    Deci,
    Centi,
    Milli,
    Micro,
    Nano,
    Pico,
    Femto,
    Atto,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiPrefix<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiPrefix::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "EXA" => Exa,
            "PETA" => Peta,
            "TERA" => Tera,
            "GIGA" => Giga,
            "MEGA" => Mega,
            "KILO" => Kilo,
            "HECTO" => Hecto,
            "DECA" => Deca,
            "DECI" => Deci,
            "CENTI" => Centi,
            "MILLI" => Milli,
            "MICRO" => Micro,
            "NANO" => Nano,
            "PICO" => Pico,
            "FEMTO" => Femto,
            "ATTO" => Atto,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for SiPrefix<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct SiUnit_<'a> { // entity
    pub prefix: Option<SiPrefix<'a>>,
    pub name: SiUnitName<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SiUnit<'a> = Id<SiUnit_<'a>>;
impl<'a> FromEntity<'a> for SiUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SiUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SiUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SI_UNIT(")(strs[0])?;
        let (s, _) = param_from_chunks::<Derived>(false, s, &mut i, strs)?;
        let (s, prefix) = param_from_chunks::<Option<SiPrefix<'a>>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<SiUnitName<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            prefix,
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SiUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.prefix.append_ids(_v);
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum SiUnitName<'a> { // enum
    Metre,
    Gram,
    Second,
    Ampere,
    Kelvin,
    Mole,
    Candela,
    Radian,
    Steradian,
    Hertz,
    Newton,
    Pascal,
    Joule,
    Watt,
    Coulomb,
    Volt,
    Farad,
    Ohm,
    Siemens,
    Weber,
    Tesla,
    Henry,
    DegreeCelsius,
    Lumen,
    Lux,
    Becquerel,
    Gray,
    Sievert,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SiUnitName<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SiUnitName::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "METRE" => Metre,
            "GRAM" => Gram,
            "SECOND" => Second,
            "AMPERE" => Ampere,
            "KELVIN" => Kelvin,
            "MOLE" => Mole,
            "CANDELA" => Candela,
            "RADIAN" => Radian,
            "STERADIAN" => Steradian,
            "HERTZ" => Hertz,
            "NEWTON" => Newton,
            "PASCAL" => Pascal,
            "JOULE" => Joule,
            "WATT" => Watt,
            "COULOMB" => Coulomb,
            "VOLT" => Volt,
            "FARAD" => Farad,
            "OHM" => Ohm,
            "SIEMENS" => Siemens,
            "WEBER" => Weber,
            "TESLA" => Tesla,
            "HENRY" => Henry,
            "DEGREE_CELSIUS" => DegreeCelsius,
            "LUMEN" => Lumen,
            "LUX" => Lux,
            "BECQUEREL" => Becquerel,
            "GRAY" => Gray,
            "SIEVERT" => Sievert,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for SiUnitName<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct SimpleBooleanExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleBooleanExpression<'a> = Id<SimpleBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SimpleBooleanExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_BOOLEAN_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SimpleBooleanExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct SimpleGenericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleGenericExpression<'a> = Id<SimpleGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SimpleGenericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_GENERIC_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SimpleGenericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct SimpleNumericExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleNumericExpression<'a> = Id<SimpleNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SimpleNumericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_NUMERIC_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SimpleNumericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct SimplePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimplePairRange<'a> = Id<SimplePairRange_<'a>>;
impl<'a> FromEntity<'a> for SimplePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimplePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SimplePairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SIMPLE_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SimplePairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SimpleStringExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SimpleStringExpression<'a> = Id<SimpleStringExpression_<'a>>;
impl<'a> FromEntity<'a> for SimpleStringExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SimpleStringExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SimpleStringExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("SIMPLE_STRING_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SimpleStringExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct SinFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SinFunction<'a> = Id<SinFunction_<'a>>;
impl<'a> FromEntity<'a> for SinFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SinFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SinFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SIN_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SinFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum SizeSelect<'a> { // select
    PositiveLengthMeasure(PositiveLengthMeasure<'a>),
    MeasureWithUnit(MeasureWithUnit<'a>),
    DescriptiveMeasure(DescriptiveMeasure<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SizeSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("POSITIVE_LENGTH_MEASURE("), <PositiveLengthMeasure<'a>>::parse, char(')')), SizeSelect::PositiveLengthMeasure),
            map(<MeasureWithUnit<'a>>::parse, SizeSelect::MeasureWithUnit),
            map(delimited(tag("DESCRIPTIVE_MEASURE("), <DescriptiveMeasure<'a>>::parse, char(')')), SizeSelect::DescriptiveMeasure),
        ))(s)
    }
}
impl<'a> HasId for SizeSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            SizeSelect::PositiveLengthMeasure(c) => c.append_ids(_v),
            SizeSelect::MeasureWithUnit(c) => c.append_ids(_v),
            SizeSelect::DescriptiveMeasure(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct SlashExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlashExpression<'a> = Id<SlashExpression_<'a>>;
impl<'a> FromEntity<'a> for SlashExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlashExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SlashExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SLASH_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SlashExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SlidingCurvePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub curve_1: Curve<'a>,
    pub curve_2: Curve<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingCurvePair<'a> = Id<SlidingCurvePair_<'a>>;
impl<'a> FromEntity<'a> for SlidingCurvePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingCurvePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SlidingCurvePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SLIDING_CURVE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, curve_1) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, curve_2) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            curve_1,
            curve_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SlidingCurvePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.curve_1.append_ids(_v);
        self.curve_2.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SlidingCurvePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_curve_1: PointOnCurve<'a>,
    pub actual_point_on_curve_2: PointOnCurve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingCurvePairValue<'a> = Id<SlidingCurvePairValue_<'a>>;
impl<'a> FromEntity<'a> for SlidingCurvePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingCurvePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SlidingCurvePairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SLIDING_CURVE_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_curve_1) = param_from_chunks::<PointOnCurve<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_curve_2) = param_from_chunks::<PointOnCurve<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_curve_1,
            actual_point_on_curve_2,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SlidingCurvePairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_point_on_curve_1.append_ids(_v);
        self.actual_point_on_curve_2.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SlidingSurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingSurfacePair<'a> = Id<SlidingSurfacePair_<'a>>;
impl<'a> FromEntity<'a> for SlidingSurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingSurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SlidingSurfacePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SLIDING_SURFACE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, surface_1) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, surface_2) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            surface_1,
            surface_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SlidingSurfacePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.surface_1.append_ids(_v);
        self.surface_2.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SlidingSurfacePairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_point_on_surface_1: PointOnSurface<'a>,
    pub actual_point_on_surface_2: PointOnSurface<'a>,
    pub actual_rotation: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlidingSurfacePairValue<'a> = Id<SlidingSurfacePairValue_<'a>>;
impl<'a> FromEntity<'a> for SlidingSurfacePairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlidingSurfacePairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SlidingSurfacePairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SLIDING_SURFACE_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_surface_1) = param_from_chunks::<PointOnSurface<'a>>(false, s, &mut i, strs)?;
        let (s, actual_point_on_surface_2) = param_from_chunks::<PointOnSurface<'a>>(false, s, &mut i, strs)?;
        let (s, actual_rotation) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_point_on_surface_1,
            actual_point_on_surface_2,
            actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SlidingSurfacePairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_point_on_surface_1.append_ids(_v);
        self.actual_point_on_surface_2.append_ids(_v);
        self.actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Slot_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Slot<'a> = Id<Slot_<'a>>;
impl<'a> FromEntity<'a> for Slot_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Slot(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Slot_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SLOT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Slot_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SlotEnd_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SlotEnd<'a> = Id<SlotEnd_<'a>>;
impl<'a> FromEntity<'a> for SlotEnd_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SlotEnd(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SlotEnd_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SLOT_END(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SlotEnd_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SolidAngleMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SolidAngleMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for SolidAngleMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct SolidAngleMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidAngleMeasureWithUnit<'a> = Id<SolidAngleMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for SolidAngleMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidAngleMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SolidAngleMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SOLID_ANGLE_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SolidAngleMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SolidAngleUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidAngleUnit<'a> = Id<SolidAngleUnit_<'a>>;
impl<'a> FromEntity<'a> for SolidAngleUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidAngleUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SolidAngleUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SOLID_ANGLE_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SolidAngleUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SolidModel_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidModel<'a> = Id<SolidModel_<'a>>;
impl<'a> FromEntity<'a> for SolidModel_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidModel(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SolidModel_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SOLID_MODEL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SolidModel_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SolidReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_solid: SolidModel<'a>,
    pub transformation: CartesianTransformationOperator3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SolidReplica<'a> = Id<SolidReplica_<'a>>;
impl<'a> FromEntity<'a> for SolidReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SolidReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SolidReplica_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SOLID_REPLICA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, parent_solid) = param_from_chunks::<SolidModel<'a>>(false, s, &mut i, strs)?;
        let (s, transformation) = param_from_chunks::<CartesianTransformationOperator3d<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            parent_solid,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SolidReplica_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.parent_solid.append_ids(_v);
        self.transformation.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum Source<'a> { // enum
    Made,
    Bought,
    NotKnown,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for Source<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use Source::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "MADE" => Made,
            "BOUGHT" => Bought,
            "NOT_KNOWN" => NotKnown,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for Source<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub enum SourceItem<'a> { // select
    Identifier(Identifier<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SourceItem<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(delimited(tag("IDENTIFIER("), <Identifier<'a>>::parse, char(')')), SourceItem::Identifier)(s)
    }
}
impl<'a> HasId for SourceItem<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            SourceItem::Identifier(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub enum SpatialRotation<'a> { // select
    YprRotation(Vec<PlaneAngleMeasure<'a>>),
    RotationAboutDirection(RotationAboutDirection<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for SpatialRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("YPR_ROTATION("), <Vec<PlaneAngleMeasure<'a>>>::parse, char(')')), SpatialRotation::YprRotation),
            map(<RotationAboutDirection<'a>>::parse, SpatialRotation::RotationAboutDirection),
        ))(s)
    }
}
impl<'a> HasId for SpatialRotation<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            SpatialRotation::YprRotation(c) => c.append_ids(_v),
            SpatialRotation::RotationAboutDirection(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct SpecifiedHigherUsageOccurrence_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_product_definition: ProductDefinition<'a>,
    pub related_product_definition: ProductDefinition<'a>,
    pub reference_designator: Option<Identifier<'a>>,
    pub upper_usage: AssemblyComponentUsage<'a>,
    pub next_usage: NextAssemblyUsageOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SpecifiedHigherUsageOccurrence<'a> = Id<SpecifiedHigherUsageOccurrence_<'a>>;
impl<'a> FromEntity<'a> for SpecifiedHigherUsageOccurrence_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SpecifiedHigherUsageOccurrence(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SpecifiedHigherUsageOccurrence_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SPECIFIED_HIGHER_USAGE_OCCURRENCE(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, related_product_definition) = param_from_chunks::<ProductDefinition<'a>>(false, s, &mut i, strs)?;
        let (s, reference_designator) = param_from_chunks::<Option<Identifier<'a>>>(false, s, &mut i, strs)?;
        let (s, upper_usage) = param_from_chunks::<AssemblyComponentUsage<'a>>(false, s, &mut i, strs)?;
        let (s, next_usage) = param_from_chunks::<NextAssemblyUsageOccurrence<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_product_definition,
            related_product_definition,
            reference_designator,
            upper_usage,
            next_usage,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SpecifiedHigherUsageOccurrence_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_product_definition.append_ids(_v);
        self.related_product_definition.append_ids(_v);
        self.reference_designator.append_ids(_v);
        self.upper_usage.append_ids(_v);
        self.next_usage.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SpecifiedItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SpecifiedItem<'a> = Id<SpecifiedItem_<'a>>;

#[derive(Debug)]
pub struct Sphere_<'a> { // entity
    pub name: Label<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    pub centre: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Sphere<'a> = Id<Sphere_<'a>>;
impl<'a> FromEntity<'a> for Sphere_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Sphere(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Sphere_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SPHERE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, centre) = param_from_chunks::<Point<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            radius,
            centre,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Sphere_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.radius.append_ids(_v);
        self.centre.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SphericalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPair<'a> = Id<SphericalPair_<'a>>;
impl<'a> FromEntity<'a> for SphericalPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SphericalPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SPHERICAL_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SphericalPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SphericalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_yaw: RotationalRangeMeasure<'a>,
    pub upper_limit_yaw: RotationalRangeMeasure<'a>,
    pub lower_limit_pitch: RotationalRangeMeasure<'a>,
    pub upper_limit_pitch: RotationalRangeMeasure<'a>,
    pub lower_limit_roll: RotationalRangeMeasure<'a>,
    pub upper_limit_roll: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPairRange<'a> = Id<SphericalPairRange_<'a>>;
impl<'a> FromEntity<'a> for SphericalPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SphericalPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SPHERICAL_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_yaw) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_yaw) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_pitch) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_pitch) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_roll) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_roll) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_yaw,
            upper_limit_yaw,
            lower_limit_pitch,
            upper_limit_pitch,
            lower_limit_roll,
            upper_limit_roll,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SphericalPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_yaw.append_ids(_v);
        self.upper_limit_yaw.append_ids(_v);
        self.lower_limit_pitch.append_ids(_v);
        self.upper_limit_pitch.append_ids(_v);
        self.lower_limit_roll.append_ids(_v);
        self.upper_limit_roll.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SphericalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub input_orientation: SpatialRotation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalPairValue<'a> = Id<SphericalPairValue_<'a>>;
impl<'a> FromEntity<'a> for SphericalPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SphericalPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SPHERICAL_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, input_orientation) = param_from_chunks::<SpatialRotation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            input_orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SphericalPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.input_orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SphericalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SphericalSurface<'a> = Id<SphericalSurface_<'a>>;
impl<'a> FromEntity<'a> for SphericalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SphericalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SphericalSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SPHERICAL_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            radius,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SphericalSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.radius.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SqlMappableDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SqlMappableDefinedFunction<'a> = Id<SqlMappableDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for SqlMappableDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SqlMappableDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SqlMappableDefinedFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("SQL_MAPPABLE_DEFINED_FUNCTION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SqlMappableDefinedFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct SquareRootFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SquareRootFunction<'a> = Id<SquareRootFunction_<'a>>;
impl<'a> FromEntity<'a> for SquareRootFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SquareRootFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SquareRootFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SQUARE_ROOT_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SquareRootFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SquareUProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SquareUProfile<'a> = Id<SquareUProfile_<'a>>;
impl<'a> FromEntity<'a> for SquareUProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SquareUProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SquareUProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SQUARE_U_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SquareUProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct StandardUncertainty_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    pub uncertainty_value: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StandardUncertainty<'a> = Id<StandardUncertainty_<'a>>;
impl<'a> FromEntity<'a> for StandardUncertainty_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StandardUncertainty(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StandardUncertainty_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("STANDARD_UNCERTAINTY(")(strs[0])?;
        let (s, measure_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, uncertainty_value) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            measure_name,
            description,
            uncertainty_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StandardUncertainty_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.measure_name.append_ids(_v);
        self.description.append_ids(_v);
        self.uncertainty_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct StraightnessTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StraightnessTolerance<'a> = Id<StraightnessTolerance_<'a>>;
impl<'a> FromEntity<'a> for StraightnessTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StraightnessTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StraightnessTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("STRAIGHTNESS_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StraightnessTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct StringDefinedFunction_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringDefinedFunction<'a> = Id<StringDefinedFunction_<'a>>;
impl<'a> FromEntity<'a> for StringDefinedFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringDefinedFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StringDefinedFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("STRING_DEFINED_FUNCTION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StringDefinedFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct StringExpression_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringExpression<'a> = Id<StringExpression_<'a>>;
impl<'a> FromEntity<'a> for StringExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StringExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("STRING_EXPRESSION(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StringExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct StringLiteral_<'a> { // entity
    pub the_value: &'a str,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringLiteral<'a> = Id<StringLiteral_<'a>>;
impl<'a> FromEntity<'a> for StringLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StringLiteral_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("STRING_LITERAL(")(strs[0])?;
        let (s, the_value) = param_from_chunks::<&'a str>(true, s, &mut i, strs)?;
        Ok((s, Self {
            the_value,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StringLiteral_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.the_value.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct StringVariable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StringVariable<'a> = Id<StringVariable_<'a>>;
impl<'a> FromEntity<'a> for StringVariable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StringVariable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StringVariable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("STRING_VARIABLE(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StringVariable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct StructuredDimensionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StructuredDimensionCallout<'a> = Id<StructuredDimensionCallout_<'a>>;
impl<'a> FromEntity<'a> for StructuredDimensionCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StructuredDimensionCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StructuredDimensionCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("STRUCTURED_DIMENSION_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StructuredDimensionCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct StyleContextSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type StyleContextSelect<'a> = Id<StyleContextSelect_<'a>>;

#[derive(Debug)]
pub struct StyledItem_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type StyledItem<'a> = Id<StyledItem_<'a>>;
impl<'a> FromEntity<'a> for StyledItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::StyledItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for StyledItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("STYLED_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for StyledItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Subedge_<'a> { // entity
    pub name: Label<'a>,
    pub edge_start: Vertex<'a>,
    pub edge_end: Vertex<'a>,
    pub parent_edge: Edge<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Subedge<'a> = Id<Subedge_<'a>>;
impl<'a> FromEntity<'a> for Subedge_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Subedge(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Subedge_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SUBEDGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, edge_start) = param_from_chunks::<Vertex<'a>>(false, s, &mut i, strs)?;
        let (s, edge_end) = param_from_chunks::<Vertex<'a>>(false, s, &mut i, strs)?;
        let (s, parent_edge) = param_from_chunks::<Edge<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            edge_start,
            edge_end,
            parent_edge,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Subedge_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.edge_start.append_ids(_v);
        self.edge_end.append_ids(_v);
        self.parent_edge.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Subface_<'a> { // entity
    pub name: Label<'a>,
    pub bounds: Vec<FaceBound<'a>>,
    pub parent_face: Face<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Subface<'a> = Id<Subface_<'a>>;
impl<'a> FromEntity<'a> for Subface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Subface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Subface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SUBFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, bounds) = param_from_chunks::<Vec<FaceBound<'a>>>(false, s, &mut i, strs)?;
        let (s, parent_face) = param_from_chunks::<Face<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            bounds,
            parent_face,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Subface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.bounds.append_ids(_v);
        self.parent_face.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SubstringExpression_<'a> { // entity
    pub operands: Vec<GenericExpression<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SubstringExpression<'a> = Id<SubstringExpression_<'a>>;
impl<'a> FromEntity<'a> for SubstringExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SubstringExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SubstringExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SUBSTRING_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<Vec<GenericExpression<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SubstringExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SupportedItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SupportedItem<'a> = Id<SupportedItem_<'a>>;

#[derive(Debug)]
pub struct Surface_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Surface<'a> = Id<Surface_<'a>>;
impl<'a> FromEntity<'a> for Surface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Surface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Surface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Surface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceConditionCallout_<'a> { // entity
    pub name: Label<'a>,
    pub contents: Vec<DraughtingCalloutElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceConditionCallout<'a> = Id<SurfaceConditionCallout_<'a>>;
impl<'a> FromEntity<'a> for SurfaceConditionCallout_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceConditionCallout(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceConditionCallout_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_CONDITION_CALLOUT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, contents) = param_from_chunks::<Vec<DraughtingCalloutElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            contents,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceConditionCallout_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.contents.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceCurve_<'a> { // entity
    pub name: Label<'a>,
    pub curve_3d: Curve<'a>,
    pub associated_geometry: ArrayVec::<PcurveOrSurface<'a>, 2>,
    pub master_representation: PreferredSurfaceCurveRepresentation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceCurve<'a> = Id<SurfaceCurve_<'a>>;
impl<'a> FromEntity<'a> for SurfaceCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, curve_3d) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, associated_geometry) = param_from_chunks::<ArrayVec::<PcurveOrSurface<'a>, 2>>(false, s, &mut i, strs)?;
        let (s, master_representation) = param_from_chunks::<PreferredSurfaceCurveRepresentation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            curve_3d,
            associated_geometry,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.curve_3d.append_ids(_v);
        self.associated_geometry.append_ids(_v);
        self.master_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceCurveSweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    pub directrix: Curve<'a>,
    pub start_param: f64,
    pub end_param: f64,
    pub reference_surface: Surface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceCurveSweptAreaSolid<'a> = Id<SurfaceCurveSweptAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for SurfaceCurveSweptAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceCurveSweptAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceCurveSweptAreaSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_CURVE_SWEPT_AREA_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_area) = param_from_chunks::<CurveBoundedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, directrix) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, start_param) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, end_param) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, reference_surface) = param_from_chunks::<Surface<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_area,
            directrix,
            start_param,
            end_param,
            reference_surface,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceCurveSweptAreaSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_area.append_ids(_v);
        self.directrix.append_ids(_v);
        self.start_param.append_ids(_v);
        self.end_param.append_ids(_v);
        self.reference_surface.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceOfLinearExtrusion_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    pub extrusion_axis: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceOfLinearExtrusion<'a> = Id<SurfaceOfLinearExtrusion_<'a>>;
impl<'a> FromEntity<'a> for SurfaceOfLinearExtrusion_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceOfLinearExtrusion(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceOfLinearExtrusion_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_OF_LINEAR_EXTRUSION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, extrusion_axis) = param_from_chunks::<Vector<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_curve,
            extrusion_axis,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceOfLinearExtrusion_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_curve.append_ids(_v);
        self.extrusion_axis.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceOfRevolution_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    pub axis_position: Axis1Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceOfRevolution<'a> = Id<SurfaceOfRevolution_<'a>>;
impl<'a> FromEntity<'a> for SurfaceOfRevolution_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceOfRevolution(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceOfRevolution_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_OF_REVOLUTION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, axis_position) = param_from_chunks::<Axis1Placement<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_curve,
            axis_position,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceOfRevolution_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_curve.append_ids(_v);
        self.axis_position.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfacePair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub surface_1: Surface<'a>,
    pub surface_2: Surface<'a>,
    pub orientation: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePair<'a> = Id<SurfacePair_<'a>>;
impl<'a> FromEntity<'a> for SurfacePair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfacePair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfacePair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, surface_1) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, surface_2) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            surface_1,
            surface_2,
            orientation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfacePair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.surface_1.append_ids(_v);
        self.surface_2.append_ids(_v);
        self.orientation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfacePairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub range_on_surface_1: RectangularTrimmedSurface<'a>,
    pub range_on_surface_2: RectangularTrimmedSurface<'a>,
    pub lower_limit_actual_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_actual_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePairRange<'a> = Id<SurfacePairRange_<'a>>;
impl<'a> FromEntity<'a> for SurfacePairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfacePairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfacePairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, range_on_surface_1) = param_from_chunks::<RectangularTrimmedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, range_on_surface_2) = param_from_chunks::<RectangularTrimmedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_actual_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            range_on_surface_1,
            range_on_surface_2,
            lower_limit_actual_rotation,
            upper_limit_actual_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfacePairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.range_on_surface_1.append_ids(_v);
        self.range_on_surface_2.append_ids(_v);
        self.lower_limit_actual_rotation.append_ids(_v);
        self.upper_limit_actual_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfacePatch_<'a> { // entity
    pub parent_surface: BoundedSurface<'a>,
    pub u_transition: TransitionCode<'a>,
    pub v_transition: TransitionCode<'a>,
    pub u_sense: bool,
    pub v_sense: bool,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfacePatch<'a> = Id<SurfacePatch_<'a>>;
impl<'a> FromEntity<'a> for SurfacePatch_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfacePatch(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfacePatch_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_PATCH(")(strs[0])?;
        let (s, parent_surface) = param_from_chunks::<BoundedSurface<'a>>(false, s, &mut i, strs)?;
        let (s, u_transition) = param_from_chunks::<TransitionCode<'a>>(false, s, &mut i, strs)?;
        let (s, v_transition) = param_from_chunks::<TransitionCode<'a>>(false, s, &mut i, strs)?;
        let (s, u_sense) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, v_sense) = param_from_chunks::<bool>(true, s, &mut i, strs)?;
        Ok((s, Self {
            parent_surface,
            u_transition,
            v_transition,
            u_sense,
            v_sense,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfacePatch_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.parent_surface.append_ids(_v);
        self.u_transition.append_ids(_v);
        self.v_transition.append_ids(_v);
        self.u_sense.append_ids(_v);
        self.v_sense.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceProfileTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceProfileTolerance<'a> = Id<SurfaceProfileTolerance_<'a>>;
impl<'a> FromEntity<'a> for SurfaceProfileTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceProfileTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceProfileTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_PROFILE_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceProfileTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceRenderingProperties_<'a> { // entity
    pub rendered_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceRenderingProperties<'a> = Id<SurfaceRenderingProperties_<'a>>;
impl<'a> FromEntity<'a> for SurfaceRenderingProperties_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceRenderingProperties(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceRenderingProperties_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_RENDERING_PROPERTIES(")(strs[0])?;
        let (s, rendered_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            rendered_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceRenderingProperties_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.rendered_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceReplica_<'a> { // entity
    pub name: Label<'a>,
    pub parent_surface: Surface<'a>,
    pub transformation: CartesianTransformationOperator3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceReplica<'a> = Id<SurfaceReplica_<'a>>;
impl<'a> FromEntity<'a> for SurfaceReplica_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceReplica(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceReplica_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_REPLICA(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, parent_surface) = param_from_chunks::<Surface<'a>>(false, s, &mut i, strs)?;
        let (s, transformation) = param_from_chunks::<CartesianTransformationOperator3d<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            parent_surface,
            transformation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceReplica_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.parent_surface.append_ids(_v);
        self.transformation.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum SurfaceSide<'a> { // enum
    Positive,
    Negative,
    Both,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for SurfaceSide<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use SurfaceSide::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "POSITIVE" => Positive,
            "NEGATIVE" => Negative,
            "BOTH" => Both,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for SurfaceSide<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct SurfaceSideStyle_<'a> { // entity
    pub name: Label<'a>,
    pub styles: ArrayVec::<SurfaceStyleElementSelect<'a>, 7>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceSideStyle<'a> = Id<SurfaceSideStyle_<'a>>;
impl<'a> FromEntity<'a> for SurfaceSideStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceSideStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceSideStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_SIDE_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<ArrayVec::<SurfaceStyleElementSelect<'a>, 7>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceSideStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceSideStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SurfaceSideStyleSelect<'a> = Id<SurfaceSideStyleSelect_<'a>>;

#[derive(Debug)]
pub struct SurfaceStyleBoundary_<'a> { // entity
    pub style_of_boundary: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleBoundary<'a> = Id<SurfaceStyleBoundary_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleBoundary_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleBoundary(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleBoundary_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_BOUNDARY(")(strs[0])?;
        let (s, style_of_boundary) = param_from_chunks::<CurveOrRender<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            style_of_boundary,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleBoundary_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.style_of_boundary.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleControlGrid_<'a> { // entity
    pub style_of_control_grid: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleControlGrid<'a> = Id<SurfaceStyleControlGrid_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleControlGrid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleControlGrid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleControlGrid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_CONTROL_GRID(")(strs[0])?;
        let (s, style_of_control_grid) = param_from_chunks::<CurveOrRender<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            style_of_control_grid,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleControlGrid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.style_of_control_grid.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleElementSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SurfaceStyleElementSelect<'a> = Id<SurfaceStyleElementSelect_<'a>>;

#[derive(Debug)]
pub struct SurfaceStyleFillArea_<'a> { // entity
    pub fill_area: FillAreaStyle<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleFillArea<'a> = Id<SurfaceStyleFillArea_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleFillArea_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleFillArea(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleFillArea_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_FILL_AREA(")(strs[0])?;
        let (s, fill_area) = param_from_chunks::<FillAreaStyle<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            fill_area,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleFillArea_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.fill_area.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleParameterLine_<'a> { // entity
    pub style_of_parameter_lines: CurveOrRender<'a>,
    pub direction_counts: ArrayVec::<DirectionCountSelect<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleParameterLine<'a> = Id<SurfaceStyleParameterLine_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleParameterLine_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleParameterLine(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleParameterLine_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_PARAMETER_LINE(")(strs[0])?;
        let (s, style_of_parameter_lines) = param_from_chunks::<CurveOrRender<'a>>(false, s, &mut i, strs)?;
        let (s, direction_counts) = param_from_chunks::<ArrayVec::<DirectionCountSelect<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            style_of_parameter_lines,
            direction_counts,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleParameterLine_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.style_of_parameter_lines.append_ids(_v);
        self.direction_counts.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleReflectanceAmbient_<'a> { // entity
    pub ambient_reflectance: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbient<'a> = Id<SurfaceStyleReflectanceAmbient_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleReflectanceAmbient_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleReflectanceAmbient(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleReflectanceAmbient_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_REFLECTANCE_AMBIENT(")(strs[0])?;
        let (s, ambient_reflectance) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            ambient_reflectance,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleReflectanceAmbient_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.ambient_reflectance.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuse_<'a> { // entity
    pub ambient_reflectance: f64,
    pub diffuse_reflectance: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbientDiffuse<'a> = Id<SurfaceStyleReflectanceAmbientDiffuse_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleReflectanceAmbientDiffuse_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleReflectanceAmbientDiffuse(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleReflectanceAmbientDiffuse_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE(")(strs[0])?;
        let (s, ambient_reflectance) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, diffuse_reflectance) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            ambient_reflectance,
            diffuse_reflectance,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleReflectanceAmbientDiffuse_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.ambient_reflectance.append_ids(_v);
        self.diffuse_reflectance.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> { // entity
    pub ambient_reflectance: f64,
    pub diffuse_reflectance: f64,
    pub specular_reflectance: f64,
    pub specular_exponent: f64,
    pub specular_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleReflectanceAmbientDiffuseSpecular<'a> = Id<SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleReflectanceAmbientDiffuseSpecular(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR(")(strs[0])?;
        let (s, ambient_reflectance) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, diffuse_reflectance) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, specular_reflectance) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, specular_exponent) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, specular_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            ambient_reflectance,
            diffuse_reflectance,
            specular_reflectance,
            specular_exponent,
            specular_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.ambient_reflectance.append_ids(_v);
        self.diffuse_reflectance.append_ids(_v);
        self.specular_reflectance.append_ids(_v);
        self.specular_exponent.append_ids(_v);
        self.specular_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleRendering_<'a> { // entity
    pub rendering_method: ShadingSurfaceMethod<'a>,
    pub surface_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleRendering<'a> = Id<SurfaceStyleRendering_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleRendering_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleRendering(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleRendering_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_RENDERING(")(strs[0])?;
        let (s, rendering_method) = param_from_chunks::<ShadingSurfaceMethod<'a>>(false, s, &mut i, strs)?;
        let (s, surface_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            rendering_method,
            surface_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleRendering_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.rendering_method.append_ids(_v);
        self.surface_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleRenderingWithProperties_<'a> { // entity
    pub rendering_method: ShadingSurfaceMethod<'a>,
    pub surface_colour: Colour<'a>,
    pub properties: ArrayVec::<RenderingPropertiesSelect<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleRenderingWithProperties<'a> = Id<SurfaceStyleRenderingWithProperties_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleRenderingWithProperties_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleRenderingWithProperties(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleRenderingWithProperties_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_RENDERING_WITH_PROPERTIES(")(strs[0])?;
        let (s, rendering_method) = param_from_chunks::<ShadingSurfaceMethod<'a>>(false, s, &mut i, strs)?;
        let (s, surface_colour) = param_from_chunks::<Colour<'a>>(false, s, &mut i, strs)?;
        let (s, properties) = param_from_chunks::<ArrayVec::<RenderingPropertiesSelect<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            rendering_method,
            surface_colour,
            properties,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleRenderingWithProperties_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.rendering_method.append_ids(_v);
        self.surface_colour.append_ids(_v);
        self.properties.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleSegmentationCurve_<'a> { // entity
    pub style_of_segmentation_curve: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleSegmentationCurve<'a> = Id<SurfaceStyleSegmentationCurve_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleSegmentationCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleSegmentationCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleSegmentationCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_SEGMENTATION_CURVE(")(strs[0])?;
        let (s, style_of_segmentation_curve) = param_from_chunks::<CurveOrRender<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            style_of_segmentation_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleSegmentationCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.style_of_segmentation_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleSilhouette_<'a> { // entity
    pub style_of_silhouette: CurveOrRender<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleSilhouette<'a> = Id<SurfaceStyleSilhouette_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleSilhouette_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleSilhouette(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleSilhouette_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_SILHOUETTE(")(strs[0])?;
        let (s, style_of_silhouette) = param_from_chunks::<CurveOrRender<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            style_of_silhouette,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleSilhouette_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.style_of_silhouette.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleTransparent_<'a> { // entity
    pub transparency: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleTransparent<'a> = Id<SurfaceStyleTransparent_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleTransparent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleTransparent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleTransparent_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_TRANSPARENT(")(strs[0])?;
        let (s, transparency) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            transparency,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleTransparent_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.transparency.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceStyleUsage_<'a> { // entity
    pub side: SurfaceSide<'a>,
    pub style: SurfaceSideStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceStyleUsage<'a> = Id<SurfaceStyleUsage_<'a>>;
impl<'a> FromEntity<'a> for SurfaceStyleUsage_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceStyleUsage(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceStyleUsage_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_STYLE_USAGE(")(strs[0])?;
        let (s, side) = param_from_chunks::<SurfaceSide<'a>>(false, s, &mut i, strs)?;
        let (s, style) = param_from_chunks::<SurfaceSideStyleSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            side,
            style,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceStyleUsage_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.side.append_ids(_v);
        self.style.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SurfaceTextureRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SurfaceTextureRepresentation<'a> = Id<SurfaceTextureRepresentation_<'a>>;
impl<'a> FromEntity<'a> for SurfaceTextureRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SurfaceTextureRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SurfaceTextureRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SURFACE_TEXTURE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SurfaceTextureRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}

#[derive(Debug)]
pub struct SurfaceToleranceDeviation<'a>(pub PositiveLengthMeasure<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for SurfaceToleranceDeviation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(PositiveLengthMeasure::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for SurfaceToleranceDeviation<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}

#[derive(Debug)]
pub struct SurfaceToleranceParameter<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for SurfaceToleranceParameter<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for SurfaceToleranceParameter<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct SweptAreaSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_area: CurveBoundedSurface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptAreaSolid<'a> = Id<SweptAreaSolid_<'a>>;
impl<'a> FromEntity<'a> for SweptAreaSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptAreaSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SweptAreaSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SWEPT_AREA_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_area) = param_from_chunks::<CurveBoundedSurface<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_area,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SweptAreaSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_area.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SweptDiskSolid_<'a> { // entity
    pub name: Label<'a>,
    pub directrix: Curve<'a>,
    pub radius: PositiveLengthMeasure<'a>,
    pub inner_radius: Option<PositiveLengthMeasure<'a>>,
    pub start_param: f64,
    pub end_param: f64,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptDiskSolid<'a> = Id<SweptDiskSolid_<'a>>;
impl<'a> FromEntity<'a> for SweptDiskSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptDiskSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SweptDiskSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SWEPT_DISK_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, directrix) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, inner_radius) = param_from_chunks::<Option<PositiveLengthMeasure<'a>>>(false, s, &mut i, strs)?;
        let (s, start_param) = param_from_chunks::<f64>(false, s, &mut i, strs)?;
        let (s, end_param) = param_from_chunks::<f64>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            directrix,
            radius,
            inner_radius,
            start_param,
            end_param,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SweptDiskSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.directrix.append_ids(_v);
        self.radius.append_ids(_v);
        self.inner_radius.append_ids(_v);
        self.start_param.append_ids(_v);
        self.end_param.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SweptFaceSolid_<'a> { // entity
    pub name: Label<'a>,
    pub swept_face: FaceSurface<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptFaceSolid<'a> = Id<SweptFaceSolid_<'a>>;
impl<'a> FromEntity<'a> for SweptFaceSolid_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptFaceSolid(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SweptFaceSolid_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SWEPT_FACE_SOLID(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_face) = param_from_chunks::<FaceSurface<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_face,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SweptFaceSolid_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_face.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SweptSurface_<'a> { // entity
    pub name: Label<'a>,
    pub swept_curve: Curve<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SweptSurface<'a> = Id<SweptSurface_<'a>>;
impl<'a> FromEntity<'a> for SweptSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SweptSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SweptSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SWEPT_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, swept_curve) = param_from_chunks::<Curve<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            swept_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SweptSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.swept_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SymbolColour_<'a> { // entity
    pub colour_of_symbol: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolColour<'a> = Id<SymbolColour_<'a>>;
impl<'a> FromEntity<'a> for SymbolColour_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolColour(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SymbolColour_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SYMBOL_COLOUR(")(strs[0])?;
        let (s, colour_of_symbol) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            colour_of_symbol,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SymbolColour_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.colour_of_symbol.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SymbolRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolRepresentation<'a> = Id<SymbolRepresentation_<'a>>;
impl<'a> FromEntity<'a> for SymbolRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SymbolRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SYMBOL_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SymbolRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SymbolRepresentationMap_<'a> { // entity
    pub mapping_origin: RepresentationItem<'a>,
    pub mapped_representation: Representation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolRepresentationMap<'a> = Id<SymbolRepresentationMap_<'a>>;
impl<'a> FromEntity<'a> for SymbolRepresentationMap_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolRepresentationMap(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SymbolRepresentationMap_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SYMBOL_REPRESENTATION_MAP(")(strs[0])?;
        let (s, mapping_origin) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, mapped_representation) = param_from_chunks::<Representation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            mapping_origin,
            mapped_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SymbolRepresentationMap_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.mapping_origin.append_ids(_v);
        self.mapped_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SymbolStyle_<'a> { // entity
    pub name: Label<'a>,
    pub style_of_symbol: SymbolStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolStyle<'a> = Id<SymbolStyle_<'a>>;
impl<'a> FromEntity<'a> for SymbolStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SymbolStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SYMBOL_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, style_of_symbol) = param_from_chunks::<SymbolStyleSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            style_of_symbol,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SymbolStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.style_of_symbol.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SymbolStyleSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type SymbolStyleSelect<'a> = Id<SymbolStyleSelect_<'a>>;

#[derive(Debug)]
pub struct SymbolTarget_<'a> { // entity
    pub name: Label<'a>,
    pub placement: Axis2Placement<'a>,
    pub x_scale: PositiveRatioMeasure<'a>,
    pub y_scale: PositiveRatioMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymbolTarget<'a> = Id<SymbolTarget_<'a>>;
impl<'a> FromEntity<'a> for SymbolTarget_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymbolTarget(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SymbolTarget_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SYMBOL_TARGET(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, x_scale) = param_from_chunks::<PositiveRatioMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, y_scale) = param_from_chunks::<PositiveRatioMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            placement,
            x_scale,
            y_scale,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SymbolTarget_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.placement.append_ids(_v);
        self.x_scale.append_ids(_v);
        self.y_scale.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SymmetricShapeAspect_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymmetricShapeAspect<'a> = Id<SymmetricShapeAspect_<'a>>;
impl<'a> FromEntity<'a> for SymmetricShapeAspect_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymmetricShapeAspect(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SymmetricShapeAspect_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SYMMETRIC_SHAPE_ASPECT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SymmetricShapeAspect_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct SymmetryTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type SymmetryTolerance<'a> = Id<SymmetryTolerance_<'a>>;
impl<'a> FromEntity<'a> for SymmetryTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::SymmetryTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for SymmetryTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("SYMMETRY_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for SymmetryTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TactileAppearanceRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TactileAppearanceRepresentation<'a> = Id<TactileAppearanceRepresentation_<'a>>;
impl<'a> FromEntity<'a> for TactileAppearanceRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TactileAppearanceRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TactileAppearanceRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TACTILE_APPEARANCE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TactileAppearanceRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TanFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TanFunction<'a> = Id<TanFunction_<'a>>;
impl<'a> FromEntity<'a> for TanFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TanFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TanFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TAN_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TanFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Tangent_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Tangent<'a> = Id<Tangent_<'a>>;
impl<'a> FromEntity<'a> for Tangent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Tangent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Tangent_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TANGENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Tangent_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Taper_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Taper<'a> = Id<Taper_<'a>>;
impl<'a> FromEntity<'a> for Taper_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Taper(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Taper_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TAPER(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Taper_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TeeProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TeeProfile<'a> = Id<TeeProfile_<'a>>;
impl<'a> FromEntity<'a> for TeeProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TeeProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TeeProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEE_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TeeProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TerminatorSymbol_<'a> { // entity
    pub name: Label<'a>,
    pub styles: Vec<PresentationStyleAssignment<'a>>,
    pub item: RepresentationItem<'a>,
    pub annotated_curve: AnnotationCurveOccurrence<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TerminatorSymbol<'a> = Id<TerminatorSymbol_<'a>>;
impl<'a> FromEntity<'a> for TerminatorSymbol_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TerminatorSymbol(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TerminatorSymbol_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TERMINATOR_SYMBOL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, styles) = param_from_chunks::<Vec<PresentationStyleAssignment<'a>>>(false, s, &mut i, strs)?;
        let (s, item) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, annotated_curve) = param_from_chunks::<AnnotationCurveOccurrence<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            styles,
            item,
            annotated_curve,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TerminatorSymbol_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.styles.append_ids(_v);
        self.item.append_ids(_v);
        self.annotated_curve.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Text<'a>(pub &'a str, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for Text<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<&str>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for Text<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}


#[derive(Debug)]
pub struct TextAlignment<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextAlignment<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for TextAlignment<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}


#[derive(Debug)]
pub struct TextDelineation<'a>(pub Label<'a>, std::marker::PhantomData<&'a ()>); // redeclared
impl<'a> Parse<'a> for TextDelineation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(Label::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for TextDelineation<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        self.0.append_ids(v);
    }
}

#[derive(Debug)]
pub struct TextLiteral_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteral<'a> = Id<TextLiteral_<'a>>;
impl<'a> FromEntity<'a> for TextLiteral_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteral(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextLiteral_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_LITERAL(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, literal) = param_from_chunks::<PresentableText<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<TextPath<'a>>(false, s, &mut i, strs)?;
        let (s, font) = param_from_chunks::<FontSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextLiteral_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.literal.append_ids(_v);
        self.placement.append_ids(_v);
        self.alignment.append_ids(_v);
        self.path.append_ids(_v);
        self.font.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextLiteralWithAssociatedCurves_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub associated_curves: Vec<Curve<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithAssociatedCurves<'a> = Id<TextLiteralWithAssociatedCurves_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithAssociatedCurves_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithAssociatedCurves(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextLiteralWithAssociatedCurves_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_LITERAL_WITH_ASSOCIATED_CURVES(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, literal) = param_from_chunks::<PresentableText<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<TextPath<'a>>(false, s, &mut i, strs)?;
        let (s, font) = param_from_chunks::<FontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, associated_curves) = param_from_chunks::<Vec<Curve<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            associated_curves,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextLiteralWithAssociatedCurves_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.literal.append_ids(_v);
        self.placement.append_ids(_v);
        self.alignment.append_ids(_v);
        self.path.append_ids(_v);
        self.font.append_ids(_v);
        self.associated_curves.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextLiteralWithBlankingBox_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub blanking: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithBlankingBox<'a> = Id<TextLiteralWithBlankingBox_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithBlankingBox_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithBlankingBox(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextLiteralWithBlankingBox_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_LITERAL_WITH_BLANKING_BOX(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, literal) = param_from_chunks::<PresentableText<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<TextPath<'a>>(false, s, &mut i, strs)?;
        let (s, font) = param_from_chunks::<FontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, blanking) = param_from_chunks::<PlanarBox<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            blanking,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextLiteralWithBlankingBox_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.literal.append_ids(_v);
        self.placement.append_ids(_v);
        self.alignment.append_ids(_v);
        self.path.append_ids(_v);
        self.font.append_ids(_v);
        self.blanking.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextLiteralWithDelineation_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub delineation: TextDelineation<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithDelineation<'a> = Id<TextLiteralWithDelineation_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithDelineation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithDelineation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextLiteralWithDelineation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_LITERAL_WITH_DELINEATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, literal) = param_from_chunks::<PresentableText<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<TextPath<'a>>(false, s, &mut i, strs)?;
        let (s, font) = param_from_chunks::<FontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, delineation) = param_from_chunks::<TextDelineation<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            delineation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextLiteralWithDelineation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.literal.append_ids(_v);
        self.placement.append_ids(_v);
        self.alignment.append_ids(_v);
        self.path.append_ids(_v);
        self.font.append_ids(_v);
        self.delineation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextLiteralWithExtent_<'a> { // entity
    pub name: Label<'a>,
    pub literal: PresentableText<'a>,
    pub placement: Axis2Placement<'a>,
    pub alignment: TextAlignment<'a>,
    pub path: TextPath<'a>,
    pub font: FontSelect<'a>,
    pub extent: PlanarExtent<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextLiteralWithExtent<'a> = Id<TextLiteralWithExtent_<'a>>;
impl<'a> FromEntity<'a> for TextLiteralWithExtent_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextLiteralWithExtent(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextLiteralWithExtent_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_LITERAL_WITH_EXTENT(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, literal) = param_from_chunks::<PresentableText<'a>>(false, s, &mut i, strs)?;
        let (s, placement) = param_from_chunks::<Axis2Placement<'a>>(false, s, &mut i, strs)?;
        let (s, alignment) = param_from_chunks::<TextAlignment<'a>>(false, s, &mut i, strs)?;
        let (s, path) = param_from_chunks::<TextPath<'a>>(false, s, &mut i, strs)?;
        let (s, font) = param_from_chunks::<FontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, extent) = param_from_chunks::<PlanarExtent<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            literal,
            placement,
            alignment,
            path,
            font,
            extent,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextLiteralWithExtent_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.literal.append_ids(_v);
        self.placement.append_ids(_v);
        self.alignment.append_ids(_v);
        self.path.append_ids(_v);
        self.font.append_ids(_v);
        self.extent.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextOrCharacter_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TextOrCharacter<'a> = Id<TextOrCharacter_<'a>>;

#[derive(Debug)]
pub enum TextPath<'a> { // enum
    Left,
    Right,
    Up,
    Down,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TextPath<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TextPath::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "LEFT" => Left,
            "RIGHT" => Right,
            "UP" => Up,
            "DOWN" => Down,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for TextPath<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct TextStringRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStringRepresentation<'a> = Id<TextStringRepresentation_<'a>>;
impl<'a> FromEntity<'a> for TextStringRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStringRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextStringRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_STRING_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextStringRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextStringRepresentationItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TextStringRepresentationItem<'a> = Id<TextStringRepresentationItem_<'a>>;

#[derive(Debug)]
pub struct TextStyle_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyle<'a> = Id<TextStyle_<'a>>;
impl<'a> FromEntity<'a> for TextStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_STYLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, character_appearance) = param_from_chunks::<CharacterStyleSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            character_appearance,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.character_appearance.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextStyleForDefinedFont_<'a> { // entity
    pub text_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleForDefinedFont<'a> = Id<TextStyleForDefinedFont_<'a>>;
impl<'a> FromEntity<'a> for TextStyleForDefinedFont_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleForDefinedFont(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextStyleForDefinedFont_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_STYLE_FOR_DEFINED_FONT(")(strs[0])?;
        let (s, text_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            text_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextStyleForDefinedFont_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.text_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextStyleWithBoxCharacteristics_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub characteristics: ArrayVec::<BoxCharacteristicSelect<'a>, 4>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithBoxCharacteristics<'a> = Id<TextStyleWithBoxCharacteristics_<'a>>;
impl<'a> FromEntity<'a> for TextStyleWithBoxCharacteristics_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleWithBoxCharacteristics(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextStyleWithBoxCharacteristics_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_STYLE_WITH_BOX_CHARACTERISTICS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, character_appearance) = param_from_chunks::<CharacterStyleSelect<'a>>(false, s, &mut i, strs)?;
        let (s, characteristics) = param_from_chunks::<ArrayVec::<BoxCharacteristicSelect<'a>, 4>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            character_appearance,
            characteristics,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextStyleWithBoxCharacteristics_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.character_appearance.append_ids(_v);
        self.characteristics.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextStyleWithMirror_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub mirror_placement: Axis2Placement<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithMirror<'a> = Id<TextStyleWithMirror_<'a>>;
impl<'a> FromEntity<'a> for TextStyleWithMirror_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleWithMirror(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextStyleWithMirror_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_STYLE_WITH_MIRROR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, character_appearance) = param_from_chunks::<CharacterStyleSelect<'a>>(false, s, &mut i, strs)?;
        let (s, mirror_placement) = param_from_chunks::<Axis2Placement<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            character_appearance,
            mirror_placement,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextStyleWithMirror_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.character_appearance.append_ids(_v);
        self.mirror_placement.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TextStyleWithSpacing_<'a> { // entity
    pub name: Label<'a>,
    pub character_appearance: CharacterStyleSelect<'a>,
    pub character_spacing: CharacterSpacingSelect<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TextStyleWithSpacing<'a> = Id<TextStyleWithSpacing_<'a>>;
impl<'a> FromEntity<'a> for TextStyleWithSpacing_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TextStyleWithSpacing(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TextStyleWithSpacing_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TEXT_STYLE_WITH_SPACING(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, character_appearance) = param_from_chunks::<CharacterStyleSelect<'a>>(false, s, &mut i, strs)?;
        let (s, character_spacing) = param_from_chunks::<CharacterSpacingSelect<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            character_appearance,
            character_spacing,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TextStyleWithSpacing_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.character_appearance.append_ids(_v);
        self.character_spacing.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ThermodynamicTemperatureMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for ThermodynamicTemperatureMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for ThermodynamicTemperatureMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct ThermodynamicTemperatureMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ThermodynamicTemperatureMeasureWithUnit<'a> = Id<ThermodynamicTemperatureMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for ThermodynamicTemperatureMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ThermodynamicTemperatureMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ThermodynamicTemperatureMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ThermodynamicTemperatureMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ThermodynamicTemperatureUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ThermodynamicTemperatureUnit<'a> = Id<ThermodynamicTemperatureUnit_<'a>>;
impl<'a> FromEntity<'a> for ThermodynamicTemperatureUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ThermodynamicTemperatureUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ThermodynamicTemperatureUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("THERMODYNAMIC_TEMPERATURE_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ThermodynamicTemperatureUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Thread_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Thread<'a> = Id<Thread_<'a>>;
impl<'a> FromEntity<'a> for Thread_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Thread(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Thread_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("THREAD(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Thread_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TimeInterval_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeInterval<'a> = Id<TimeInterval_<'a>>;
impl<'a> FromEntity<'a> for TimeInterval_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeInterval(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TimeInterval_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TIME_INTERVAL(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TimeInterval_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TimeIntervalAssignment_<'a> { // entity
    pub assigned_time_interval: TimeInterval<'a>,
    pub role: TimeIntervalRole<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalAssignment<'a> = Id<TimeIntervalAssignment_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalAssignment_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalAssignment(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TimeIntervalAssignment_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TIME_INTERVAL_ASSIGNMENT(")(strs[0])?;
        let (s, assigned_time_interval) = param_from_chunks::<TimeInterval<'a>>(false, s, &mut i, strs)?;
        let (s, role) = param_from_chunks::<TimeIntervalRole<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            assigned_time_interval,
            role,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TimeIntervalAssignment_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.assigned_time_interval.append_ids(_v);
        self.role.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TimeIntervalBasedEffectivity_<'a> { // entity
    pub id: Identifier<'a>,
    pub effectivity_period: TimeInterval<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalBasedEffectivity<'a> = Id<TimeIntervalBasedEffectivity_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalBasedEffectivity_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalBasedEffectivity(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TimeIntervalBasedEffectivity_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TIME_INTERVAL_BASED_EFFECTIVITY(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, effectivity_period) = param_from_chunks::<TimeInterval<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            effectivity_period,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TimeIntervalBasedEffectivity_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.effectivity_period.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TimeIntervalItem_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type TimeIntervalItem<'a> = Id<TimeIntervalItem_<'a>>;

#[derive(Debug)]
pub struct TimeIntervalRole_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalRole<'a> = Id<TimeIntervalRole_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalRole_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalRole(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TimeIntervalRole_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TIME_INTERVAL_ROLE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TimeIntervalRole_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TimeIntervalWithBounds_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub primary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    pub secondary_bound: Option<DateTimeOrEventOccurrence<'a>>,
    pub duration: Option<TimeMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeIntervalWithBounds<'a> = Id<TimeIntervalWithBounds_<'a>>;
impl<'a> FromEntity<'a> for TimeIntervalWithBounds_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeIntervalWithBounds(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TimeIntervalWithBounds_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TIME_INTERVAL_WITH_BOUNDS(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, primary_bound) = param_from_chunks::<Option<DateTimeOrEventOccurrence<'a>>>(false, s, &mut i, strs)?;
        let (s, secondary_bound) = param_from_chunks::<Option<DateTimeOrEventOccurrence<'a>>>(false, s, &mut i, strs)?;
        let (s, duration) = param_from_chunks::<Option<TimeMeasureWithUnit<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            primary_bound,
            secondary_bound,
            duration,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TimeIntervalWithBounds_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.primary_bound.append_ids(_v);
        self.secondary_bound.append_ids(_v);
        self.duration.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TimeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for TimeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for TimeMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct TimeMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeMeasureWithUnit<'a> = Id<TimeMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for TimeMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TimeMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TIME_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TimeMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TimeUnit_<'a> { // entity
    pub dimensions: DimensionalExponents<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TimeUnit<'a> = Id<TimeUnit_<'a>>;
impl<'a> FromEntity<'a> for TimeUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TimeUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TimeUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TIME_UNIT(")(strs[0])?;
        let (s, dimensions) = param_from_chunks::<DimensionalExponents<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            dimensions,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TimeUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.dimensions.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum ToleranceDeviationSelect<'a> { // select
    CurveToleranceDeviation(CurveToleranceDeviation<'a>),
    SurfaceToleranceDeviation(SurfaceToleranceDeviation<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceDeviationSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("CURVE_TOLERANCE_DEVIATION("), <CurveToleranceDeviation<'a>>::parse, char(')')), ToleranceDeviationSelect::CurveToleranceDeviation),
            map(delimited(tag("SURFACE_TOLERANCE_DEVIATION("), <SurfaceToleranceDeviation<'a>>::parse, char(')')), ToleranceDeviationSelect::SurfaceToleranceDeviation),
        ))(s)
    }
}
impl<'a> HasId for ToleranceDeviationSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            ToleranceDeviationSelect::CurveToleranceDeviation(c) => c.append_ids(_v),
            ToleranceDeviationSelect::SurfaceToleranceDeviation(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct ToleranceMethodDefinition_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ToleranceMethodDefinition<'a> = Id<ToleranceMethodDefinition_<'a>>;

#[derive(Debug)]
pub enum ToleranceParameterSelect<'a> { // select
    CurveToleranceParameter(CurveToleranceParameter<'a>),
    SurfaceToleranceParameter(SurfaceToleranceParameter<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for ToleranceParameterSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("CURVE_TOLERANCE_PARAMETER("), <CurveToleranceParameter<'a>>::parse, char(')')), ToleranceParameterSelect::CurveToleranceParameter),
            map(delimited(tag("SURFACE_TOLERANCE_PARAMETER("), <SurfaceToleranceParameter<'a>>::parse, char(')')), ToleranceParameterSelect::SurfaceToleranceParameter),
        ))(s)
    }
}
impl<'a> HasId for ToleranceParameterSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            ToleranceParameterSelect::CurveToleranceParameter(c) => c.append_ids(_v),
            ToleranceParameterSelect::SurfaceToleranceParameter(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct ToleranceSelect_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ToleranceSelect<'a> = Id<ToleranceSelect_<'a>>;

#[derive(Debug)]
pub struct ToleranceValue_<'a> { // entity
    pub lower_bound: MeasureWithUnit<'a>,
    pub upper_bound: MeasureWithUnit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceValue<'a> = Id<ToleranceValue_<'a>>;
impl<'a> FromEntity<'a> for ToleranceValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ToleranceValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TOLERANCE_VALUE(")(strs[0])?;
        let (s, lower_bound) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, upper_bound) = param_from_chunks::<MeasureWithUnit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            lower_bound,
            upper_bound,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ToleranceValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.lower_bound.append_ids(_v);
        self.upper_bound.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ToleranceZone_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    pub defining_tolerance: Vec<GeometricTolerance<'a>>,
    pub form: ToleranceZoneForm<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZone<'a> = Id<ToleranceZone_<'a>>;
impl<'a> FromEntity<'a> for ToleranceZone_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceZone(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ToleranceZone_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TOLERANCE_ZONE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, defining_tolerance) = param_from_chunks::<Vec<GeometricTolerance<'a>>>(false, s, &mut i, strs)?;
        let (s, form) = param_from_chunks::<ToleranceZoneForm<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            defining_tolerance,
            form,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ToleranceZone_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
        self.defining_tolerance.append_ids(_v);
        self.form.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ToleranceZoneDefinition_<'a> { // entity
    pub zone: ToleranceZone<'a>,
    pub boundaries: Vec<ShapeAspect<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZoneDefinition<'a> = Id<ToleranceZoneDefinition_<'a>>;
impl<'a> FromEntity<'a> for ToleranceZoneDefinition_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceZoneDefinition(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ToleranceZoneDefinition_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TOLERANCE_ZONE_DEFINITION(")(strs[0])?;
        let (s, zone) = param_from_chunks::<ToleranceZone<'a>>(false, s, &mut i, strs)?;
        let (s, boundaries) = param_from_chunks::<Vec<ShapeAspect<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            zone,
            boundaries,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ToleranceZoneDefinition_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.zone.append_ids(_v);
        self.boundaries.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ToleranceZoneForm_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToleranceZoneForm<'a> = Id<ToleranceZoneForm_<'a>>;
impl<'a> FromEntity<'a> for ToleranceZoneForm_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToleranceZoneForm(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ToleranceZoneForm_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TOLERANCE_ZONE_FORM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ToleranceZoneForm_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TopologicalRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TopologicalRepresentationItem<'a> = Id<TopologicalRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for TopologicalRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TopologicalRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TopologicalRepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TOPOLOGICAL_REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TopologicalRepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ToroidalSurface_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis2Placement3d<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ToroidalSurface<'a> = Id<ToroidalSurface_<'a>>;
impl<'a> FromEntity<'a> for ToroidalSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ToroidalSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ToroidalSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TOROIDAL_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis2Placement3d<'a>>(false, s, &mut i, strs)?;
        let (s, major_radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, minor_radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            major_radius,
            minor_radius,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ToroidalSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.major_radius.append_ids(_v);
        self.minor_radius.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Torus_<'a> { // entity
    pub name: Label<'a>,
    pub position: Axis1Placement<'a>,
    pub major_radius: PositiveLengthMeasure<'a>,
    pub minor_radius: PositiveLengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Torus<'a> = Id<Torus_<'a>>;
impl<'a> FromEntity<'a> for Torus_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Torus(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Torus_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TORUS(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, position) = param_from_chunks::<Axis1Placement<'a>>(false, s, &mut i, strs)?;
        let (s, major_radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, minor_radius) = param_from_chunks::<PositiveLengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            position,
            major_radius,
            minor_radius,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Torus_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.position.append_ids(_v);
        self.major_radius.append_ids(_v);
        self.minor_radius.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TotalRunoutTolerance_<'a> { // entity
    pub name: Label<'a>,
    pub description: Text<'a>,
    pub magnitude: MeasureWithUnit<'a>,
    pub toleranced_shape_aspect: ShapeAspect<'a>,
    pub datum_system: Vec<DatumReference<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TotalRunoutTolerance<'a> = Id<TotalRunoutTolerance_<'a>>;
impl<'a> FromEntity<'a> for TotalRunoutTolerance_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TotalRunoutTolerance(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TotalRunoutTolerance_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TOTAL_RUNOUT_TOLERANCE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<MeasureWithUnit<'a>>(false, s, &mut i, strs)?;
        let (s, toleranced_shape_aspect) = param_from_chunks::<ShapeAspect<'a>>(false, s, &mut i, strs)?;
        let (s, datum_system) = param_from_chunks::<Vec<DatumReference<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            magnitude,
            toleranced_shape_aspect,
            datum_system,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TotalRunoutTolerance_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.magnitude.append_ids(_v);
        self.toleranced_shape_aspect.append_ids(_v);
        self.datum_system.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Transformation_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Transformation<'a> = Id<Transformation_<'a>>;

#[derive(Debug)]
pub enum TransitionCode<'a> { // enum
    Discontinuous,
    Continuous,
    ContSameGradient,
    ContSameGradientSameCurvature,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TransitionCode<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TransitionCode::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "DISCONTINUOUS" => Discontinuous,
            "CONTINUOUS" => Continuous,
            "CONT_SAME_GRADIENT" => ContSameGradient,
            "CONT_SAME_GRADIENT_SAME_CURVATURE" => ContSameGradientSameCurvature,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for TransitionCode<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct TransitionFeature_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TransitionFeature<'a> = Id<TransitionFeature_<'a>>;
impl<'a> FromEntity<'a> for TransitionFeature_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TransitionFeature(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TransitionFeature_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TRANSITION_FEATURE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TransitionFeature_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum TranslationalRangeMeasure<'a> { // select
    LengthMeasure(LengthMeasure<'a>),
    UnlimitedRange(UnlimitedRange<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TranslationalRangeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(delimited(tag("LENGTH_MEASURE("), <LengthMeasure<'a>>::parse, char(')')), TranslationalRangeMeasure::LengthMeasure),
            map(delimited(tag("UNLIMITED_RANGE("), <UnlimitedRange<'a>>::parse, char(')')), TranslationalRangeMeasure::UnlimitedRange),
        ))(s)
    }
}
impl<'a> HasId for TranslationalRangeMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            TranslationalRangeMeasure::LengthMeasure(c) => c.append_ids(_v),
            TranslationalRangeMeasure::UnlimitedRange(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct TrimmedCurve_<'a> { // entity
    pub name: Label<'a>,
    pub basis_curve: Curve<'a>,
    pub trim_1: ArrayVec::<TrimmingSelect<'a>, 2>,
    pub trim_2: ArrayVec::<TrimmingSelect<'a>, 2>,
    pub sense_agreement: bool,
    pub master_representation: TrimmingPreference<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TrimmedCurve<'a> = Id<TrimmedCurve_<'a>>;
impl<'a> FromEntity<'a> for TrimmedCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TrimmedCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TrimmedCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TRIMMED_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, basis_curve) = param_from_chunks::<Curve<'a>>(false, s, &mut i, strs)?;
        let (s, trim_1) = param_from_chunks::<ArrayVec::<TrimmingSelect<'a>, 2>>(false, s, &mut i, strs)?;
        let (s, trim_2) = param_from_chunks::<ArrayVec::<TrimmingSelect<'a>, 2>>(false, s, &mut i, strs)?;
        let (s, sense_agreement) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, master_representation) = param_from_chunks::<TrimmingPreference<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            basis_curve,
            trim_1,
            trim_2,
            sense_agreement,
            master_representation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TrimmedCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.basis_curve.append_ids(_v);
        self.trim_1.append_ids(_v);
        self.trim_2.append_ids(_v);
        self.sense_agreement.append_ids(_v);
        self.master_representation.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum TrimmingPreference<'a> { // enum
    Cartesian,
    Parameter,
    Unspecified,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for TrimmingPreference<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use TrimmingPreference::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "CARTESIAN" => Cartesian,
            "PARAMETER" => Parameter,
            "UNSPECIFIED" => Unspecified,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for TrimmingPreference<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub enum TrimmingSelect<'a> { // select
    CartesianPoint(CartesianPoint<'a>),
    ParameterValue(ParameterValue<'a>),
    _Unused(std::marker::PhantomData<&'a ()>)
}
impl<'a> Parse<'a> for TrimmingSelect<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        alt((
            map(<CartesianPoint<'a>>::parse, TrimmingSelect::CartesianPoint),
            map(delimited(tag("PARAMETER_VALUE("), <ParameterValue<'a>>::parse, char(')')), TrimmingSelect::ParameterValue),
        ))(s)
    }
}
impl<'a> HasId for TrimmingSelect<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        match self {
            TrimmingSelect::CartesianPoint(c) => c.append_ids(_v),
            TrimmingSelect::ParameterValue(c) => c.append_ids(_v),
            _ => (),
        }
    }
}
#[derive(Debug)]
pub struct TwoDirectionRepeatFactor_<'a> { // entity
    pub name: Label<'a>,
    pub repeat_factor: Vector<'a>,
    pub second_repeat_factor: Vector<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TwoDirectionRepeatFactor<'a> = Id<TwoDirectionRepeatFactor_<'a>>;
impl<'a> FromEntity<'a> for TwoDirectionRepeatFactor_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TwoDirectionRepeatFactor(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TwoDirectionRepeatFactor_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TWO_DIRECTION_REPEAT_FACTOR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, repeat_factor) = param_from_chunks::<Vector<'a>>(false, s, &mut i, strs)?;
        let (s, second_repeat_factor) = param_from_chunks::<Vector<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            repeat_factor,
            second_repeat_factor,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TwoDirectionRepeatFactor_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.repeat_factor.append_ids(_v);
        self.second_repeat_factor.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct TypeQualifier_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type TypeQualifier<'a> = Id<TypeQualifier_<'a>>;
impl<'a> FromEntity<'a> for TypeQualifier_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::TypeQualifier(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for TypeQualifier_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("TYPE_QUALIFIER(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for TypeQualifier_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for UDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for UDirectionCount<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct UnaryBooleanExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryBooleanExpression<'a> = Id<UnaryBooleanExpression_<'a>>;
impl<'a> FromEntity<'a> for UnaryBooleanExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryBooleanExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UnaryBooleanExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNARY_BOOLEAN_EXPRESSION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UnaryBooleanExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UnaryFunctionCall_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryFunctionCall<'a> = Id<UnaryFunctionCall_<'a>>;
impl<'a> FromEntity<'a> for UnaryFunctionCall_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryFunctionCall(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UnaryFunctionCall_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNARY_FUNCTION_CALL(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UnaryFunctionCall_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UnaryGenericExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryGenericExpression<'a> = Id<UnaryGenericExpression_<'a>>;
impl<'a> FromEntity<'a> for UnaryGenericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryGenericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UnaryGenericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNARY_GENERIC_EXPRESSION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UnaryGenericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UnaryNumericExpression_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnaryNumericExpression<'a> = Id<UnaryNumericExpression_<'a>>;
impl<'a> FromEntity<'a> for UnaryNumericExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnaryNumericExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UnaryNumericExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNARY_NUMERIC_EXPRESSION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UnaryNumericExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UncertaintyAssignedRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    pub uncertainty: Vec<UncertaintyMeasureWithUnit<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyAssignedRepresentation<'a> = Id<UncertaintyAssignedRepresentation_<'a>>;
impl<'a> FromEntity<'a> for UncertaintyAssignedRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UncertaintyAssignedRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UncertaintyAssignedRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNCERTAINTY_ASSIGNED_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(false, s, &mut i, strs)?;
        let (s, uncertainty) = param_from_chunks::<Vec<UncertaintyMeasureWithUnit<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            uncertainty,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UncertaintyAssignedRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
        self.uncertainty.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UncertaintyMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyMeasureWithUnit<'a> = Id<UncertaintyMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for UncertaintyMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UncertaintyMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UncertaintyMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNCERTAINTY_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UncertaintyMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UncertaintyQualifier_<'a> { // entity
    pub measure_name: Label<'a>,
    pub description: Text<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UncertaintyQualifier<'a> = Id<UncertaintyQualifier_<'a>>;
impl<'a> FromEntity<'a> for UncertaintyQualifier_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UncertaintyQualifier(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UncertaintyQualifier_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNCERTAINTY_QUALIFIER(")(strs[0])?;
        let (s, measure_name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Text<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            measure_name,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UncertaintyQualifier_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.measure_name.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UnconstrainedPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnconstrainedPair<'a> = Id<UnconstrainedPair_<'a>>;
impl<'a> FromEntity<'a> for UnconstrainedPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnconstrainedPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UnconstrainedPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNCONSTRAINED_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UnconstrainedPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UnconstrainedPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub actual_placement: Axis2Placement3d<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UnconstrainedPairValue<'a> = Id<UnconstrainedPairValue_<'a>>;
impl<'a> FromEntity<'a> for UnconstrainedPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UnconstrainedPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UnconstrainedPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNCONSTRAINED_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, actual_placement) = param_from_chunks::<Axis2Placement3d<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            actual_placement,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UnconstrainedPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.actual_placement.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UniformCurve_<'a> { // entity
    pub name: Label<'a>,
    pub degree: i64,
    pub control_points_list: Vec<CartesianPoint<'a>>,
    pub curve_form: BSplineCurveForm<'a>,
    pub closed_curve: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniformCurve<'a> = Id<UniformCurve_<'a>>;
impl<'a> FromEntity<'a> for UniformCurve_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniformCurve(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UniformCurve_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNIFORM_CURVE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<CartesianPoint<'a>>>(false, s, &mut i, strs)?;
        let (s, curve_form) = param_from_chunks::<BSplineCurveForm<'a>>(false, s, &mut i, strs)?;
        let (s, closed_curve) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            degree,
            control_points_list,
            curve_form,
            closed_curve,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UniformCurve_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.curve_form.append_ids(_v);
        self.closed_curve.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UniformSurface_<'a> { // entity
    pub name: Label<'a>,
    pub u_degree: i64,
    pub v_degree: i64,
    pub control_points_list: Vec<Vec<CartesianPoint<'a>>>,
    pub surface_form: BSplineSurfaceForm<'a>,
    pub u_closed: Logical,
    pub v_closed: Logical,
    pub self_intersect: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniformSurface<'a> = Id<UniformSurface_<'a>>;
impl<'a> FromEntity<'a> for UniformSurface_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniformSurface(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UniformSurface_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNIFORM_SURFACE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, u_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, v_degree) = param_from_chunks::<i64>(false, s, &mut i, strs)?;
        let (s, control_points_list) = param_from_chunks::<Vec<Vec<CartesianPoint<'a>>>>(false, s, &mut i, strs)?;
        let (s, surface_form) = param_from_chunks::<BSplineSurfaceForm<'a>>(false, s, &mut i, strs)?;
        let (s, u_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, v_closed) = param_from_chunks::<Logical>(false, s, &mut i, strs)?;
        let (s, self_intersect) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            u_degree,
            v_degree,
            control_points_list,
            surface_form,
            u_closed,
            v_closed,
            self_intersect,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UniformSurface_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.u_degree.append_ids(_v);
        self.v_degree.append_ids(_v);
        self.control_points_list.append_ids(_v);
        self.surface_form.append_ids(_v);
        self.u_closed.append_ids(_v);
        self.v_closed.append_ids(_v);
        self.self_intersect.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Unit_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type Unit<'a> = Id<Unit_<'a>>;

#[derive(Debug)]
pub struct UniversalPair_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub transform_item_1: RepresentationItem<'a>,
    pub transform_item_2: RepresentationItem<'a>,
    pub joint: KinematicJoint<'a>,
    pub input_skew_angle: Option<PlaneAngleMeasure<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPair<'a> = Id<UniversalPair_<'a>>;
impl<'a> FromEntity<'a> for UniversalPair_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniversalPair(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UniversalPair_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNIVERSAL_PAIR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, transform_item_1) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, transform_item_2) = param_from_chunks::<RepresentationItem<'a>>(false, s, &mut i, strs)?;
        let (s, joint) = param_from_chunks::<KinematicJoint<'a>>(false, s, &mut i, strs)?;
        let (s, input_skew_angle) = param_from_chunks::<Option<PlaneAngleMeasure<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            transform_item_1,
            transform_item_2,
            joint,
            input_skew_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UniversalPair_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.transform_item_1.append_ids(_v);
        self.transform_item_2.append_ids(_v);
        self.joint.append_ids(_v);
        self.input_skew_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UniversalPairRange_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub lower_limit_first_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_first_rotation: RotationalRangeMeasure<'a>,
    pub lower_limit_second_rotation: RotationalRangeMeasure<'a>,
    pub upper_limit_second_rotation: RotationalRangeMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPairRange<'a> = Id<UniversalPairRange_<'a>>;
impl<'a> FromEntity<'a> for UniversalPairRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniversalPairRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UniversalPairRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNIVERSAL_PAIR_RANGE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_first_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_first_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, lower_limit_second_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, upper_limit_second_rotation) = param_from_chunks::<RotationalRangeMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            lower_limit_first_rotation,
            upper_limit_first_rotation,
            lower_limit_second_rotation,
            upper_limit_second_rotation,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UniversalPairRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.lower_limit_first_rotation.append_ids(_v);
        self.upper_limit_first_rotation.append_ids(_v);
        self.lower_limit_second_rotation.append_ids(_v);
        self.upper_limit_second_rotation.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct UniversalPairValue_<'a> { // entity
    pub applies_to_pair: KinematicPair<'a>,
    pub first_rotation_angle: PlaneAngleMeasure<'a>,
    pub second_rotation_angle: PlaneAngleMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type UniversalPairValue<'a> = Id<UniversalPairValue_<'a>>;
impl<'a> FromEntity<'a> for UniversalPairValue_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::UniversalPairValue(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for UniversalPairValue_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("UNIVERSAL_PAIR_VALUE(")(strs[0])?;
        let (s, applies_to_pair) = param_from_chunks::<KinematicPair<'a>>(false, s, &mut i, strs)?;
        let (s, first_rotation_angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, second_rotation_angle) = param_from_chunks::<PlaneAngleMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            applies_to_pair,
            first_rotation_angle,
            second_rotation_angle,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for UniversalPairValue_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.applies_to_pair.append_ids(_v);
        self.first_rotation_angle.append_ids(_v);
        self.second_rotation_angle.append_ids(_v);
    }
}
#[derive(Debug)]
pub enum UnlimitedRange<'a> { // enum
    Unlimited,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for UnlimitedRange<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use UnlimitedRange::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "UNLIMITED" => Unlimited,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for UnlimitedRange<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct VDirectionCount<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VDirectionCount<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for VDirectionCount<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct ValueFunction_<'a> { // entity
    pub operand: GenericExpression<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueFunction<'a> = Id<ValueFunction_<'a>>;
impl<'a> FromEntity<'a> for ValueFunction_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ValueFunction(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ValueFunction_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VALUE_FUNCTION(")(strs[0])?;
        let (s, operand) = param_from_chunks::<GenericExpression<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operand,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ValueFunction_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operand.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ValueQualifier_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type ValueQualifier<'a> = Id<ValueQualifier_<'a>>;

#[derive(Debug)]
pub struct ValueRange_<'a> { // entity
    pub name: Label<'a>,
    pub item_element: CompoundItemDefinition<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueRange<'a> = Id<ValueRange_<'a>>;
impl<'a> FromEntity<'a> for ValueRange_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ValueRange(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ValueRange_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VALUE_RANGE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, item_element) = param_from_chunks::<CompoundItemDefinition<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            item_element,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ValueRange_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.item_element.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ValueRepresentationItem_<'a> { // entity
    pub name: Label<'a>,
    pub value_component: MeasureValue<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ValueRepresentationItem<'a> = Id<ValueRepresentationItem_<'a>>;
impl<'a> FromEntity<'a> for ValueRepresentationItem_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ValueRepresentationItem(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ValueRepresentationItem_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VALUE_REPRESENTATION_ITEM(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            value_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ValueRepresentationItem_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.value_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Variable_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Variable<'a> = Id<Variable_<'a>>;
impl<'a> FromEntity<'a> for Variable_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Variable(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Variable_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("VARIABLE(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Variable_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct VariableSemantics_<'a> { // entity
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VariableSemantics<'a> = Id<VariableSemantics_<'a>>;
impl<'a> FromEntity<'a> for VariableSemantics_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VariableSemantics(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VariableSemantics_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (s, _) = tag("VARIABLE_SEMANTICS(")(strs[0])?;
        Ok((s, Self {
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VariableSemantics_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
    }
}
#[derive(Debug)]
pub struct Vector_<'a> { // entity
    pub name: Label<'a>,
    pub orientation: Direction<'a>,
    pub magnitude: LengthMeasure<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Vector<'a> = Id<Vector_<'a>>;
impl<'a> FromEntity<'a> for Vector_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Vector(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Vector_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VECTOR(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, orientation) = param_from_chunks::<Direction<'a>>(false, s, &mut i, strs)?;
        let (s, magnitude) = param_from_chunks::<LengthMeasure<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            orientation,
            magnitude,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Vector_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.orientation.append_ids(_v);
        self.magnitude.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VectorOrDirection_<'a>(std::marker::PhantomData<&'a ()>); // ambiguous select
pub type VectorOrDirection<'a> = Id<VectorOrDirection_<'a>>;

#[allow(non_snake_case)]
#[derive(Debug)]
pub struct VectorStyle_<'a> { // entity
    pub pre_defined_item__name: Label<'a>,
    pub curve_style__name: Label<'a>,
    pub curve_font: CurveFontOrScaledCurveFontSelect<'a>,
    pub curve_width: SizeSelect<'a>,
    pub curve_colour: Colour<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VectorStyle<'a> = Id<VectorStyle_<'a>>;
impl<'a> FromEntity<'a> for VectorStyle_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VectorStyle(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VectorStyle_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VECTOR_STYLE(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, pre_defined_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        #[allow(non_snake_case)]
        let (s, curve_style__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, curve_font) = param_from_chunks::<CurveFontOrScaledCurveFontSelect<'a>>(false, s, &mut i, strs)?;
        let (s, curve_width) = param_from_chunks::<SizeSelect<'a>>(false, s, &mut i, strs)?;
        let (s, curve_colour) = param_from_chunks::<Colour<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            pre_defined_item__name,
            curve_style__name,
            curve_font,
            curve_width,
            curve_colour,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VectorStyle_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.pre_defined_item__name.append_ids(_v);
        self.curve_style__name.append_ids(_v);
        self.curve_font.append_ids(_v);
        self.curve_width.append_ids(_v);
        self.curve_colour.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VeeProfile_<'a> { // entity
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub of_shape: ProductDefinitionShape<'a>,
    pub product_definitional: Logical,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VeeProfile<'a> = Id<VeeProfile_<'a>>;
impl<'a> FromEntity<'a> for VeeProfile_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VeeProfile(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VeeProfile_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VEE_PROFILE(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, of_shape) = param_from_chunks::<ProductDefinitionShape<'a>>(false, s, &mut i, strs)?;
        let (s, product_definitional) = param_from_chunks::<Logical>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            description,
            of_shape,
            product_definitional,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VeeProfile_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.of_shape.append_ids(_v);
        self.product_definitional.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VersionedActionRequest_<'a> { // entity
    pub id: Identifier<'a>,
    pub version: Label<'a>,
    pub purpose: Text<'a>,
    pub description: Option<Text<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VersionedActionRequest<'a> = Id<VersionedActionRequest_<'a>>;
impl<'a> FromEntity<'a> for VersionedActionRequest_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VersionedActionRequest(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VersionedActionRequest_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VERSIONED_ACTION_REQUEST(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, version) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, purpose) = param_from_chunks::<Text<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            version,
            purpose,
            description,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VersionedActionRequest_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.version.append_ids(_v);
        self.purpose.append_ids(_v);
        self.description.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VersionedActionRequestRelationship_<'a> { // entity
    pub id: Identifier<'a>,
    pub name: Label<'a>,
    pub description: Option<Text<'a>>,
    pub relating_versioned_action_request: VersionedActionRequest<'a>,
    pub related_versioned_action_request: VersionedActionRequest<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VersionedActionRequestRelationship<'a> = Id<VersionedActionRequestRelationship_<'a>>;
impl<'a> FromEntity<'a> for VersionedActionRequestRelationship_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VersionedActionRequestRelationship(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VersionedActionRequestRelationship_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VERSIONED_ACTION_REQUEST_RELATIONSHIP(")(strs[0])?;
        let (s, id) = param_from_chunks::<Identifier<'a>>(false, s, &mut i, strs)?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, description) = param_from_chunks::<Option<Text<'a>>>(false, s, &mut i, strs)?;
        let (s, relating_versioned_action_request) = param_from_chunks::<VersionedActionRequest<'a>>(false, s, &mut i, strs)?;
        let (s, related_versioned_action_request) = param_from_chunks::<VersionedActionRequest<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            id,
            name,
            description,
            relating_versioned_action_request,
            related_versioned_action_request,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VersionedActionRequestRelationship_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.id.append_ids(_v);
        self.name.append_ids(_v);
        self.description.append_ids(_v);
        self.relating_versioned_action_request.append_ids(_v);
        self.related_versioned_action_request.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct Vertex_<'a> { // entity
    pub name: Label<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type Vertex<'a> = Id<Vertex_<'a>>;
impl<'a> FromEntity<'a> for Vertex_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::Vertex(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for Vertex_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VERTEX(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for Vertex_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VertexLoop_<'a> { // entity
    pub name: Label<'a>,
    pub loop_vertex: Vertex<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VertexLoop<'a> = Id<VertexLoop_<'a>>;
impl<'a> FromEntity<'a> for VertexLoop_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VertexLoop(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VertexLoop_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VERTEX_LOOP(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, loop_vertex) = param_from_chunks::<Vertex<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            loop_vertex,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VertexLoop_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.loop_vertex.append_ids(_v);
    }
}
#[allow(non_snake_case)]
#[derive(Debug)]
pub struct VertexPoint_<'a> { // entity
    pub representation_item__name: Label<'a>,
    pub vertex_geometry: Point<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VertexPoint<'a> = Id<VertexPoint_<'a>>;
impl<'a> FromEntity<'a> for VertexPoint_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VertexPoint(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VertexPoint_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VERTEX_POINT(")(strs[0])?;
        #[allow(non_snake_case)]
        let (s, representation_item__name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, vertex_geometry) = param_from_chunks::<Point<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            representation_item__name,
            vertex_geometry,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VertexPoint_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.representation_item__name.append_ids(_v);
        self.vertex_geometry.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct ViewVolume_<'a> { // entity
    pub projection_type: CentralOrParallel<'a>,
    pub projection_point: CartesianPoint<'a>,
    pub view_plane_distance: LengthMeasure<'a>,
    pub front_plane_distance: LengthMeasure<'a>,
    pub front_plane_clipping: bool,
    pub back_plane_distance: LengthMeasure<'a>,
    pub back_plane_clipping: bool,
    pub view_volume_sides_clipping: bool,
    pub view_window: PlanarBox<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type ViewVolume<'a> = Id<ViewVolume_<'a>>;
impl<'a> FromEntity<'a> for ViewVolume_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::ViewVolume(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for ViewVolume_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VIEW_VOLUME(")(strs[0])?;
        let (s, projection_type) = param_from_chunks::<CentralOrParallel<'a>>(false, s, &mut i, strs)?;
        let (s, projection_point) = param_from_chunks::<CartesianPoint<'a>>(false, s, &mut i, strs)?;
        let (s, view_plane_distance) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, front_plane_distance) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, front_plane_clipping) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, back_plane_distance) = param_from_chunks::<LengthMeasure<'a>>(false, s, &mut i, strs)?;
        let (s, back_plane_clipping) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, view_volume_sides_clipping) = param_from_chunks::<bool>(false, s, &mut i, strs)?;
        let (s, view_window) = param_from_chunks::<PlanarBox<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            projection_type,
            projection_point,
            view_plane_distance,
            front_plane_distance,
            front_plane_clipping,
            back_plane_distance,
            back_plane_clipping,
            view_volume_sides_clipping,
            view_window,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for ViewVolume_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.projection_type.append_ids(_v);
        self.projection_point.append_ids(_v);
        self.view_plane_distance.append_ids(_v);
        self.front_plane_distance.append_ids(_v);
        self.front_plane_clipping.append_ids(_v);
        self.back_plane_distance.append_ids(_v);
        self.back_plane_clipping.append_ids(_v);
        self.view_volume_sides_clipping.append_ids(_v);
        self.view_window.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VisualAppearanceRepresentation_<'a> { // entity
    pub name: Label<'a>,
    pub items: Vec<RepresentationItem<'a>>,
    pub context_of_items: RepresentationContext<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VisualAppearanceRepresentation<'a> = Id<VisualAppearanceRepresentation_<'a>>;
impl<'a> FromEntity<'a> for VisualAppearanceRepresentation_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VisualAppearanceRepresentation(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VisualAppearanceRepresentation_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VISUAL_APPEARANCE_REPRESENTATION(")(strs[0])?;
        let (s, name) = param_from_chunks::<Label<'a>>(false, s, &mut i, strs)?;
        let (s, items) = param_from_chunks::<Vec<RepresentationItem<'a>>>(false, s, &mut i, strs)?;
        let (s, context_of_items) = param_from_chunks::<RepresentationContext<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            name,
            items,
            context_of_items,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VisualAppearanceRepresentation_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.name.append_ids(_v);
        self.items.append_ids(_v);
        self.context_of_items.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VolumeMeasure<'a>(pub f64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for VolumeMeasure<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<f64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for VolumeMeasure<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub struct VolumeMeasureWithUnit_<'a> { // entity
    pub value_component: MeasureValue<'a>,
    pub unit_component: Unit<'a>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VolumeMeasureWithUnit<'a> = Id<VolumeMeasureWithUnit_<'a>>;
impl<'a> FromEntity<'a> for VolumeMeasureWithUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VolumeMeasureWithUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VolumeMeasureWithUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VOLUME_MEASURE_WITH_UNIT(")(strs[0])?;
        let (s, value_component) = param_from_chunks::<MeasureValue<'a>>(false, s, &mut i, strs)?;
        let (s, unit_component) = param_from_chunks::<Unit<'a>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            value_component,
            unit_component,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VolumeMeasureWithUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.value_component.append_ids(_v);
        self.unit_component.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct VolumeUnit_<'a> { // entity
    pub elements: Vec<DerivedUnitElement<'a>>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type VolumeUnit<'a> = Id<VolumeUnit_<'a>>;
impl<'a> FromEntity<'a> for VolumeUnit_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::VolumeUnit(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for VolumeUnit_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("VOLUME_UNIT(")(strs[0])?;
        let (s, elements) = param_from_chunks::<Vec<DerivedUnitElement<'a>>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            elements,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for VolumeUnit_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.elements.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct XorExpression_<'a> { // entity
    pub operands: ArrayVec::<GenericExpression<'a>, 2>,
    _marker: std::marker::PhantomData<&'a ()>,
}
pub type XorExpression<'a> = Id<XorExpression_<'a>>;
impl<'a> FromEntity<'a> for XorExpression_<'a> {
    fn try_from_entity(e: &'a Entity<'a>) -> Option<&'a Self> {
        match e {
            Entity::XorExpression(v) => Some(v),
            _ => None,
        }
    }
}
impl<'a> ParseFromChunks<'a> for XorExpression_<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let mut i = 0;
        let (s, _) = tag("XOR_EXPRESSION(")(strs[0])?;
        let (s, operands) = param_from_chunks::<ArrayVec::<GenericExpression<'a>, 2>>(true, s, &mut i, strs)?;
        Ok((s, Self {
            operands,
            _marker: std::marker::PhantomData}))
    }
}
impl<'a> HasId for XorExpression_<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) {
        self.operands.append_ids(_v);
    }
}
#[derive(Debug)]
pub struct YearNumber<'a>(pub i64, std::marker::PhantomData<&'a ()>); // primitive
impl<'a> Parse<'a> for YearNumber<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(<i64>::parse, |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for YearNumber<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* Nothing to do here */ }
}

#[derive(Debug)]
pub enum YprEnumeration<'a> { // enum
    Yaw,
    Pitch,
    Roll,
    _Unused(std::marker::PhantomData<&'a ()>),
}
impl<'a> Parse<'a> for YprEnumeration<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        use YprEnumeration::*;
        let (s, tag) = parse_enum_tag(s)?;
        let e = match tag {
            "YAW" => Yaw,
            "PITCH" => Pitch,
            "ROLL" => Roll,
            _ => return nom_alt_err(s),
        };
        Ok((s, e))
    }
}
impl<'a> HasId for YprEnumeration<'a> {
    fn append_ids(&self, _v: &mut Vec<usize>) { /* nothing to do here */ }
}

#[derive(Debug)]
pub struct YprRotation<'a>(pub Vec<PlaneAngleMeasure<'a>>, std::marker::PhantomData<&'a ()>); // aggregation
impl<'a> Parse<'a> for YprRotation<'a> {
    fn parse(s: &'a str) -> IResult<'a, Self> {
        map(many0(<PlaneAngleMeasure<'a>>::parse), |r| Self(r, std::marker::PhantomData))(s)
    }
}
impl<'a> HasId for YprRotation<'a> {
    fn append_ids(&self, v: &mut Vec<usize>) {
        for i in &self.0 {
            i.append_ids(v);
        }
    }
}

#[derive(Debug)]
pub enum Entity<'a> {
    AbsFunction(AbsFunction_<'a>),
    AcosFunction(AcosFunction_<'a>),
    Action(Action_<'a>),
    ActionAssignment(ActionAssignment_<'a>),
    ActionDirective(ActionDirective_<'a>),
    ActionMethod(ActionMethod_<'a>),
    ActionMethodRelationship(ActionMethodRelationship_<'a>),
    ActionProperty(ActionProperty_<'a>),
    ActionPropertyRepresentation(ActionPropertyRepresentation_<'a>),
    ActionRelationship(ActionRelationship_<'a>),
    ActionRequestAssignment(ActionRequestAssignment_<'a>),
    ActionRequestSolution(ActionRequestSolution_<'a>),
    ActionRequestStatus(ActionRequestStatus_<'a>),
    ActionResource(ActionResource_<'a>),
    ActionResourceRequirement(ActionResourceRequirement_<'a>),
    ActionResourceType(ActionResourceType_<'a>),
    ActionStatus(ActionStatus_<'a>),
    Address(Address_<'a>),
    AdvancedBrepShapeRepresentation(AdvancedBrepShapeRepresentation_<'a>),
    AdvancedFace(AdvancedFace_<'a>),
    AlternateProductRelationship(AlternateProductRelationship_<'a>),
    AmountOfSubstanceMeasureWithUnit(AmountOfSubstanceMeasureWithUnit_<'a>),
    AmountOfSubstanceUnit(AmountOfSubstanceUnit_<'a>),
    AndExpression(AndExpression_<'a>),
    AngularDimension(AngularDimension_<'a>),
    AngularLocation(AngularLocation_<'a>),
    AngularSize(AngularSize_<'a>),
    AngularityTolerance(AngularityTolerance_<'a>),
    AnnotationCurveOccurrence(AnnotationCurveOccurrence_<'a>),
    AnnotationFillArea(AnnotationFillArea_<'a>),
    AnnotationFillAreaOccurrence(AnnotationFillAreaOccurrence_<'a>),
    AnnotationOccurrence(AnnotationOccurrence_<'a>),
    AnnotationOccurrenceAssociativity(AnnotationOccurrenceAssociativity_<'a>),
    AnnotationOccurrenceRelationship(AnnotationOccurrenceRelationship_<'a>),
    AnnotationPlane(AnnotationPlane_<'a>),
    AnnotationSubfigureOccurrence(AnnotationSubfigureOccurrence_<'a>),
    AnnotationSymbol(AnnotationSymbol_<'a>),
    AnnotationSymbolOccurrence(AnnotationSymbolOccurrence_<'a>),
    AnnotationText(AnnotationText_<'a>),
    AnnotationTextCharacter(AnnotationTextCharacter_<'a>),
    AnnotationTextOccurrence(AnnotationTextOccurrence_<'a>),
    Apex(Apex_<'a>),
    ApplicationContext(ApplicationContext_<'a>),
    ApplicationContextElement(ApplicationContextElement_<'a>),
    ApplicationContextRelationship(ApplicationContextRelationship_<'a>),
    ApplicationProtocolDefinition(ApplicationProtocolDefinition_<'a>),
    AppliedActionAssignment(AppliedActionAssignment_<'a>),
    AppliedActionRequestAssignment(AppliedActionRequestAssignment_<'a>),
    AppliedApprovalAssignment(AppliedApprovalAssignment_<'a>),
    AppliedArea(AppliedArea_<'a>),
    AppliedCertificationAssignment(AppliedCertificationAssignment_<'a>),
    AppliedClassificationAssignment(AppliedClassificationAssignment_<'a>),
    AppliedContractAssignment(AppliedContractAssignment_<'a>),
    AppliedDateAndTimeAssignment(AppliedDateAndTimeAssignment_<'a>),
    AppliedDateAssignment(AppliedDateAssignment_<'a>),
    AppliedDocumentReference(AppliedDocumentReference_<'a>),
    AppliedDocumentUsageConstraintAssignment(AppliedDocumentUsageConstraintAssignment_<'a>),
    AppliedEffectivityAssignment(AppliedEffectivityAssignment_<'a>),
    AppliedEventOccurrenceAssignment(AppliedEventOccurrenceAssignment_<'a>),
    AppliedExternalIdentificationAssignment(AppliedExternalIdentificationAssignment_<'a>),
    AppliedGroupAssignment(AppliedGroupAssignment_<'a>),
    AppliedIdentificationAssignment(AppliedIdentificationAssignment_<'a>),
    AppliedIneffectivityAssignment(AppliedIneffectivityAssignment_<'a>),
    AppliedNameAssignment(AppliedNameAssignment_<'a>),
    AppliedOrganizationAssignment(AppliedOrganizationAssignment_<'a>),
    AppliedOrganizationalProjectAssignment(AppliedOrganizationalProjectAssignment_<'a>),
    AppliedPersonAndOrganizationAssignment(AppliedPersonAndOrganizationAssignment_<'a>),
    AppliedPresentedItem(AppliedPresentedItem_<'a>),
    AppliedSecurityClassificationAssignment(AppliedSecurityClassificationAssignment_<'a>),
    AppliedTimeIntervalAssignment(AppliedTimeIntervalAssignment_<'a>),
    Approval(Approval_<'a>),
    ApprovalAssignment(ApprovalAssignment_<'a>),
    ApprovalDateTime(ApprovalDateTime_<'a>),
    ApprovalPersonOrganization(ApprovalPersonOrganization_<'a>),
    ApprovalRelationship(ApprovalRelationship_<'a>),
    ApprovalRole(ApprovalRole_<'a>),
    ApprovalStatus(ApprovalStatus_<'a>),
    ApproximationTolerance(ApproximationTolerance_<'a>),
    ApproximationToleranceDeviation(ApproximationToleranceDeviation_<'a>),
    ApproximationToleranceParameter(ApproximationToleranceParameter_<'a>),
    AreaInSet(AreaInSet_<'a>),
    AreaMeasureWithUnit(AreaMeasureWithUnit_<'a>),
    AreaUnit(AreaUnit_<'a>),
    AsinFunction(AsinFunction_<'a>),
    AssemblyComponentUsage(AssemblyComponentUsage_<'a>),
    AssemblyComponentUsageSubstitute(AssemblyComponentUsageSubstitute_<'a>),
    AtanFunction(AtanFunction_<'a>),
    AttributeClassificationAssignment(AttributeClassificationAssignment_<'a>),
    AttributeLanguageAssignment(AttributeLanguageAssignment_<'a>),
    AttributeValueAssignment(AttributeValueAssignment_<'a>),
    AttributeValueRole(AttributeValueRole_<'a>),
    Axis1Placement(Axis1Placement_<'a>),
    Axis2Placement2d(Axis2Placement2d_<'a>),
    Axis2Placement3d(Axis2Placement3d_<'a>),
    BSplineCurve(BSplineCurve_<'a>),
    BSplineCurveWithKnots(BSplineCurveWithKnots_<'a>),
    BSplineSurface(BSplineSurface_<'a>),
    BSplineSurfaceWithKnots(BSplineSurfaceWithKnots_<'a>),
    BackgroundColour(BackgroundColour_<'a>),
    BarringHole(BarringHole_<'a>),
    Bead(Bead_<'a>),
    BeadEnd(BeadEnd_<'a>),
    BezierCurve(BezierCurve_<'a>),
    BezierSurface(BezierSurface_<'a>),
    BinaryBooleanExpression(BinaryBooleanExpression_<'a>),
    BinaryFunctionCall(BinaryFunctionCall_<'a>),
    BinaryGenericExpression(BinaryGenericExpression_<'a>),
    BinaryNumericExpression(BinaryNumericExpression_<'a>),
    Block(Block_<'a>),
    BooleanDefinedFunction(BooleanDefinedFunction_<'a>),
    BooleanExpression(BooleanExpression_<'a>),
    BooleanLiteral(BooleanLiteral_<'a>),
    BooleanResult(BooleanResult_<'a>),
    BooleanVariable(BooleanVariable_<'a>),
    Boss(Boss_<'a>),
    BossTop(BossTop_<'a>),
    BoundaryCurve(BoundaryCurve_<'a>),
    BoundedCurve(BoundedCurve_<'a>),
    BoundedPcurve(BoundedPcurve_<'a>),
    BoundedSurface(BoundedSurface_<'a>),
    BoundedSurfaceCurve(BoundedSurfaceCurve_<'a>),
    BoxDomain(BoxDomain_<'a>),
    BoxedHalfSpace(BoxedHalfSpace_<'a>),
    BrepWithVoids(BrepWithVoids_<'a>),
    CalendarDate(CalendarDate_<'a>),
    CameraImage(CameraImage_<'a>),
    CameraImage2dWithScale(CameraImage2dWithScale_<'a>),
    CameraImage3dWithScale(CameraImage3dWithScale_<'a>),
    CameraModel(CameraModel_<'a>),
    CameraModelD2(CameraModelD2_<'a>),
    CameraModelD3(CameraModelD3_<'a>),
    CameraModelD3WithHlhsr(CameraModelD3WithHlhsr_<'a>),
    CameraUsage(CameraUsage_<'a>),
    CartesianPoint(CartesianPoint_<'a>),
    CartesianTransformationOperator(CartesianTransformationOperator_<'a>),
    CartesianTransformationOperator2d(CartesianTransformationOperator2d_<'a>),
    CartesianTransformationOperator3d(CartesianTransformationOperator3d_<'a>),
    CelsiusTemperatureMeasureWithUnit(CelsiusTemperatureMeasureWithUnit_<'a>),
    CentreOfSymmetry(CentreOfSymmetry_<'a>),
    Certification(Certification_<'a>),
    CertificationAssignment(CertificationAssignment_<'a>),
    CertificationType(CertificationType_<'a>),
    Chamfer(Chamfer_<'a>),
    ChamferOffset(ChamferOffset_<'a>),
    CharacterGlyphSymbol(CharacterGlyphSymbol_<'a>),
    CharacterizedClass(CharacterizedClass_<'a>),
    CharacterizedObject(CharacterizedObject_<'a>),
    Circle(Circle_<'a>),
    CircularClosedProfile(CircularClosedProfile_<'a>),
    CircularPattern(CircularPattern_<'a>),
    CircularRunoutTolerance(CircularRunoutTolerance_<'a>),
    Class(Class_<'a>),
    ClassSystem(ClassSystem_<'a>),
    ClassUsageEffectivityContextAssignment(ClassUsageEffectivityContextAssignment_<'a>),
    ClassificationAssignment(ClassificationAssignment_<'a>),
    ClassificationRole(ClassificationRole_<'a>),
    ClosedPathProfile(ClosedPathProfile_<'a>),
    ClosedShell(ClosedShell_<'a>),
    CoaxialityTolerance(CoaxialityTolerance_<'a>),
    Colour(Colour_<'a>),
    ColourRgb(ColourRgb_<'a>),
    ColourSpecification(ColourSpecification_<'a>),
    CommonDatum(CommonDatum_<'a>),
    ComparisonEqual(ComparisonEqual_<'a>),
    ComparisonExpression(ComparisonExpression_<'a>),
    ComparisonGreater(ComparisonGreater_<'a>),
    ComparisonGreaterEqual(ComparisonGreaterEqual_<'a>),
    ComparisonLess(ComparisonLess_<'a>),
    ComparisonLessEqual(ComparisonLessEqual_<'a>),
    ComparisonNotEqual(ComparisonNotEqual_<'a>),
    CompositeCurve(CompositeCurve_<'a>),
    CompositeCurveOnSurface(CompositeCurveOnSurface_<'a>),
    CompositeCurveSegment(CompositeCurveSegment_<'a>),
    CompositeHole(CompositeHole_<'a>),
    CompositeShapeAspect(CompositeShapeAspect_<'a>),
    CompositeText(CompositeText_<'a>),
    CompositeTextWithAssociatedCurves(CompositeTextWithAssociatedCurves_<'a>),
    CompositeTextWithBlankingBox(CompositeTextWithBlankingBox_<'a>),
    CompositeTextWithExtent(CompositeTextWithExtent_<'a>),
    CompoundFeature(CompoundFeature_<'a>),
    CompoundRepresentationItem(CompoundRepresentationItem_<'a>),
    CompoundShapeRepresentation(CompoundShapeRepresentation_<'a>),
    ConcatExpression(ConcatExpression_<'a>),
    ConcentricityTolerance(ConcentricityTolerance_<'a>),
    ConceptFeatureOperator(ConceptFeatureOperator_<'a>),
    ConceptFeatureRelationship(ConceptFeatureRelationship_<'a>),
    ConceptFeatureRelationshipWithCondition(ConceptFeatureRelationshipWithCondition_<'a>),
    ConditionalConceptFeature(ConditionalConceptFeature_<'a>),
    ConfigurableItem(ConfigurableItem_<'a>),
    ConfigurationDefinition(ConfigurationDefinition_<'a>),
    ConfigurationDesign(ConfigurationDesign_<'a>),
    ConfigurationEffectivity(ConfigurationEffectivity_<'a>),
    ConfigurationInterpolation(ConfigurationInterpolation_<'a>),
    ConfigurationItem(ConfigurationItem_<'a>),
    ConfiguredEffectivityAssignment(ConfiguredEffectivityAssignment_<'a>),
    ConfiguredEffectivityContextAssignment(ConfiguredEffectivityContextAssignment_<'a>),
    Conic(Conic_<'a>),
    ConicalSurface(ConicalSurface_<'a>),
    ConnectedEdgeSet(ConnectedEdgeSet_<'a>),
    ConnectedFaceSet(ConnectedFaceSet_<'a>),
    ConnectedFaceSubSet(ConnectedFaceSubSet_<'a>),
    ConstructiveGeometryRepresentation(ConstructiveGeometryRepresentation_<'a>),
    ConstructiveGeometryRepresentationRelationship(ConstructiveGeometryRepresentationRelationship_<'a>),
    ContactRatioRepresentation(ContactRatioRepresentation_<'a>),
    ContextDependentInvisibility(ContextDependentInvisibility_<'a>),
    ContextDependentOverRidingStyledItem(ContextDependentOverRidingStyledItem_<'a>),
    ContextDependentShapeRepresentation(ContextDependentShapeRepresentation_<'a>),
    ContextDependentUnit(ContextDependentUnit_<'a>),
    Contract(Contract_<'a>),
    ContractAssignment(ContractAssignment_<'a>),
    ContractType(ContractType_<'a>),
    ConversionBasedUnit(ConversionBasedUnit_<'a>),
    CoordinatedUniversalTimeOffset(CoordinatedUniversalTimeOffset_<'a>),
    CosFunction(CosFunction_<'a>),
    CsgShapeRepresentation(CsgShapeRepresentation_<'a>),
    CsgSolid(CsgSolid_<'a>),
    Curve(Curve_<'a>),
    CurveBoundedSurface(CurveBoundedSurface_<'a>),
    CurveDimension(CurveDimension_<'a>),
    CurveReplica(CurveReplica_<'a>),
    CurveStyle(CurveStyle_<'a>),
    CurveStyleFont(CurveStyleFont_<'a>),
    CurveStyleFontPattern(CurveStyleFontPattern_<'a>),
    CurveStyleRendering(CurveStyleRendering_<'a>),
    CurveSweptSolidShapeRepresentation(CurveSweptSolidShapeRepresentation_<'a>),
    CylindricalPair(CylindricalPair_<'a>),
    CylindricalPairRange(CylindricalPairRange_<'a>),
    CylindricalPairValue(CylindricalPairValue_<'a>),
    CylindricalSurface(CylindricalSurface_<'a>),
    CylindricityTolerance(CylindricityTolerance_<'a>),
    DataEnvironment(DataEnvironment_<'a>),
    Date(Date_<'a>),
    DateAndTime(DateAndTime_<'a>),
    DateAndTimeAssignment(DateAndTimeAssignment_<'a>),
    DateAssignment(DateAssignment_<'a>),
    DateRole(DateRole_<'a>),
    DateTimeRole(DateTimeRole_<'a>),
    DatedEffectivity(DatedEffectivity_<'a>),
    Datum(Datum_<'a>),
    DatumFeature(DatumFeature_<'a>),
    DatumFeatureCallout(DatumFeatureCallout_<'a>),
    DatumReference(DatumReference_<'a>),
    DatumTarget(DatumTarget_<'a>),
    DatumTargetCallout(DatumTargetCallout_<'a>),
    DefaultToleranceTable(DefaultToleranceTable_<'a>),
    DefaultToleranceTableCell(DefaultToleranceTableCell_<'a>),
    DefinedCharacterGlyph(DefinedCharacterGlyph_<'a>),
    DefinedFunction(DefinedFunction_<'a>),
    DefinedSymbol(DefinedSymbol_<'a>),
    DefinitionalRepresentation(DefinitionalRepresentation_<'a>),
    DegeneratePcurve(DegeneratePcurve_<'a>),
    DegenerateToroidalSurface(DegenerateToroidalSurface_<'a>),
    DerivedShapeAspect(DerivedShapeAspect_<'a>),
    DerivedUnit(DerivedUnit_<'a>),
    DerivedUnitElement(DerivedUnitElement_<'a>),
    DerivedUnitVariable(DerivedUnitVariable_<'a>),
    DescriptionAttribute(DescriptionAttribute_<'a>),
    DescriptiveRepresentationItem(DescriptiveRepresentationItem_<'a>),
    DiameterDimension(DiameterDimension_<'a>),
    DimensionCallout(DimensionCallout_<'a>),
    DimensionCalloutComponentRelationship(DimensionCalloutComponentRelationship_<'a>),
    DimensionCalloutRelationship(DimensionCalloutRelationship_<'a>),
    DimensionCurve(DimensionCurve_<'a>),
    DimensionCurveDirectedCallout(DimensionCurveDirectedCallout_<'a>),
    DimensionCurveTerminator(DimensionCurveTerminator_<'a>),
    DimensionPair(DimensionPair_<'a>),
    DimensionRelatedToleranceZoneElement(DimensionRelatedToleranceZoneElement_<'a>),
    DimensionTextAssociativity(DimensionTextAssociativity_<'a>),
    DimensionalCharacteristicRepresentation(DimensionalCharacteristicRepresentation_<'a>),
    DimensionalExponents(DimensionalExponents_<'a>),
    DimensionalLocation(DimensionalLocation_<'a>),
    DimensionalLocationWithPath(DimensionalLocationWithPath_<'a>),
    DimensionalSize(DimensionalSize_<'a>),
    DimensionalSizeWithPath(DimensionalSizeWithPath_<'a>),
    DirectedAction(DirectedAction_<'a>),
    DirectedAngle(DirectedAngle_<'a>),
    DirectedDimensionalLocation(DirectedDimensionalLocation_<'a>),
    Direction(Direction_<'a>),
    DirectionShapeRepresentation(DirectionShapeRepresentation_<'a>),
    DivExpression(DivExpression_<'a>),
    Document(Document_<'a>),
    DocumentFile(DocumentFile_<'a>),
    DocumentProductAssociation(DocumentProductAssociation_<'a>),
    DocumentProductEquivalence(DocumentProductEquivalence_<'a>),
    DocumentReference(DocumentReference_<'a>),
    DocumentRelationship(DocumentRelationship_<'a>),
    DocumentRepresentationType(DocumentRepresentationType_<'a>),
    DocumentType(DocumentType_<'a>),
    DocumentUsageConstraint(DocumentUsageConstraint_<'a>),
    DocumentUsageConstraintAssignment(DocumentUsageConstraintAssignment_<'a>),
    DocumentUsageRole(DocumentUsageRole_<'a>),
    DraughtingAnnotationOccurrence(DraughtingAnnotationOccurrence_<'a>),
    DraughtingCallout(DraughtingCallout_<'a>),
    DraughtingCalloutRelationship(DraughtingCalloutRelationship_<'a>),
    DraughtingElements(DraughtingElements_<'a>),
    DraughtingModel(DraughtingModel_<'a>),
    DraughtingModelItemAssociation(DraughtingModelItemAssociation_<'a>),
    DraughtingPreDefinedColour(DraughtingPreDefinedColour_<'a>),
    DraughtingPreDefinedCurveFont(DraughtingPreDefinedCurveFont_<'a>),
    DraughtingPreDefinedTextFont(DraughtingPreDefinedTextFont_<'a>),
    DraughtingSpecificationReference(DraughtingSpecificationReference_<'a>),
    DraughtingSubfigureRepresentation(DraughtingSubfigureRepresentation_<'a>),
    DraughtingSymbolRepresentation(DraughtingSymbolRepresentation_<'a>),
    DraughtingTextLiteralWithDelineation(DraughtingTextLiteralWithDelineation_<'a>),
    DraughtingTitle(DraughtingTitle_<'a>),
    DrawingDefinition(DrawingDefinition_<'a>),
    DrawingRevision(DrawingRevision_<'a>),
    DrawingRevisionSequence(DrawingRevisionSequence_<'a>),
    DrawingSheetLayout(DrawingSheetLayout_<'a>),
    DrawingSheetRevision(DrawingSheetRevision_<'a>),
    DrawingSheetRevisionUsage(DrawingSheetRevisionUsage_<'a>),
    Edge(Edge_<'a>),
    EdgeBasedWireframeModel(EdgeBasedWireframeModel_<'a>),
    EdgeBasedWireframeShapeRepresentation(EdgeBasedWireframeShapeRepresentation_<'a>),
    EdgeCurve(EdgeCurve_<'a>),
    EdgeLoop(EdgeLoop_<'a>),
    EdgeRound(EdgeRound_<'a>),
    Effectivity(Effectivity_<'a>),
    EffectivityAssignment(EffectivityAssignment_<'a>),
    EffectivityContextAssignment(EffectivityContextAssignment_<'a>),
    EffectivityContextRole(EffectivityContextRole_<'a>),
    EffectivityRelationship(EffectivityRelationship_<'a>),
    ElectricCurrentMeasureWithUnit(ElectricCurrentMeasureWithUnit_<'a>),
    ElectricCurrentUnit(ElectricCurrentUnit_<'a>),
    ElementDelivery(ElementDelivery_<'a>),
    ElementarySurface(ElementarySurface_<'a>),
    Ellipse(Ellipse_<'a>),
    Environment(Environment_<'a>),
    EqualsExpression(EqualsExpression_<'a>),
    EvaluatedDegeneratePcurve(EvaluatedDegeneratePcurve_<'a>),
    EventOccurrence(EventOccurrence_<'a>),
    EventOccurrenceAssignment(EventOccurrenceAssignment_<'a>),
    EventOccurrenceContextAssignment(EventOccurrenceContextAssignment_<'a>),
    EventOccurrenceContextRole(EventOccurrenceContextRole_<'a>),
    EventOccurrenceRole(EventOccurrenceRole_<'a>),
    ExclusiveProductConceptFeatureCategory(ExclusiveProductConceptFeatureCategory_<'a>),
    ExecutedAction(ExecutedAction_<'a>),
    ExpFunction(ExpFunction_<'a>),
    Expression(Expression_<'a>),
    ExpressionConversionBasedUnit(ExpressionConversionBasedUnit_<'a>),
    Extension(Extension_<'a>),
    ExternalIdentificationAssignment(ExternalIdentificationAssignment_<'a>),
    ExternalSource(ExternalSource_<'a>),
    ExternallyDefinedCharacterGlyph(ExternallyDefinedCharacterGlyph_<'a>),
    ExternallyDefinedClass(ExternallyDefinedClass_<'a>),
    ExternallyDefinedCurveFont(ExternallyDefinedCurveFont_<'a>),
    ExternallyDefinedDimensionDefinition(ExternallyDefinedDimensionDefinition_<'a>),
    ExternallyDefinedFeatureDefinition(ExternallyDefinedFeatureDefinition_<'a>),
    ExternallyDefinedGeneralProperty(ExternallyDefinedGeneralProperty_<'a>),
    ExternallyDefinedHatchStyle(ExternallyDefinedHatchStyle_<'a>),
    ExternallyDefinedItem(ExternallyDefinedItem_<'a>),
    ExternallyDefinedItemRelationship(ExternallyDefinedItemRelationship_<'a>),
    ExternallyDefinedStyle(ExternallyDefinedStyle_<'a>),
    ExternallyDefinedSymbol(ExternallyDefinedSymbol_<'a>),
    ExternallyDefinedTextFont(ExternallyDefinedTextFont_<'a>),
    ExternallyDefinedTileStyle(ExternallyDefinedTileStyle_<'a>),
    ExtrudedAreaSolid(ExtrudedAreaSolid_<'a>),
    ExtrudedFaceSolid(ExtrudedFaceSolid_<'a>),
    Face(Face_<'a>),
    FaceBasedSurfaceModel(FaceBasedSurfaceModel_<'a>),
    FaceBound(FaceBound_<'a>),
    FaceOuterBound(FaceOuterBound_<'a>),
    FaceShapeRepresentation(FaceShapeRepresentation_<'a>),
    FaceSurface(FaceSurface_<'a>),
    FacetedBrep(FacetedBrep_<'a>),
    FacetedBrepShapeRepresentation(FacetedBrepShapeRepresentation_<'a>),
    FeatureComponentDefinition(FeatureComponentDefinition_<'a>),
    FeatureComponentRelationship(FeatureComponentRelationship_<'a>),
    FeatureDefinition(FeatureDefinition_<'a>),
    FeatureInPanel(FeatureInPanel_<'a>),
    FeaturePattern(FeaturePattern_<'a>),
    FeaturedShape(FeaturedShape_<'a>),
    FillAreaStyle(FillAreaStyle_<'a>),
    FillAreaStyleColour(FillAreaStyleColour_<'a>),
    FillAreaStyleHatching(FillAreaStyleHatching_<'a>),
    FillAreaStyleTileSymbolWithStyle(FillAreaStyleTileSymbolWithStyle_<'a>),
    FillAreaStyleTiles(FillAreaStyleTiles_<'a>),
    Fillet(Fillet_<'a>),
    FlatnessTolerance(FlatnessTolerance_<'a>),
    FormatFunction(FormatFunction_<'a>),
    FoundedItem(FoundedItem_<'a>),
    FoundedKinematicPath(FoundedKinematicPath_<'a>),
    FullyConstrainedPair(FullyConstrainedPair_<'a>),
    FunctionallyDefinedTransformation(FunctionallyDefinedTransformation_<'a>),
    GearPair(GearPair_<'a>),
    GearPairRange(GearPairRange_<'a>),
    GearPairValue(GearPairValue_<'a>),
    GeneralFeature(GeneralFeature_<'a>),
    GeneralMaterialProperty(GeneralMaterialProperty_<'a>),
    GeneralProperty(GeneralProperty_<'a>),
    GeneralPropertyAssociation(GeneralPropertyAssociation_<'a>),
    GeneralPropertyRelationship(GeneralPropertyRelationship_<'a>),
    GenericCharacterGlyphSymbol(GenericCharacterGlyphSymbol_<'a>),
    GenericExpression(GenericExpression_<'a>),
    GenericLiteral(GenericLiteral_<'a>),
    GenericVariable(GenericVariable_<'a>),
    GeometricAlignment(GeometricAlignment_<'a>),
    GeometricCurveSet(GeometricCurveSet_<'a>),
    GeometricIntersection(GeometricIntersection_<'a>),
    GeometricItemSpecificUsage(GeometricItemSpecificUsage_<'a>),
    GeometricRepresentationContext(GeometricRepresentationContext_<'a>),
    GeometricRepresentationItem(GeometricRepresentationItem_<'a>),
    GeometricSet(GeometricSet_<'a>),
    GeometricTolerance(GeometricTolerance_<'a>),
    GeometricToleranceRelationship(GeometricToleranceRelationship_<'a>),
    GeometricToleranceWithDatumReference(GeometricToleranceWithDatumReference_<'a>),
    GeometricToleranceWithDefinedUnit(GeometricToleranceWithDefinedUnit_<'a>),
    GeometricalToleranceCallout(GeometricalToleranceCallout_<'a>),
    GeometricallyBounded2dWireframeRepresentation(GeometricallyBounded2dWireframeRepresentation_<'a>),
    GeometricallyBoundedSurfaceShapeRepresentation(GeometricallyBoundedSurfaceShapeRepresentation_<'a>),
    GeometricallyBoundedWireframeShapeRepresentation(GeometricallyBoundedWireframeShapeRepresentation_<'a>),
    GlobalUncertaintyAssignedContext(GlobalUncertaintyAssignedContext_<'a>),
    GlobalUnitAssignedContext(GlobalUnitAssignedContext_<'a>),
    Group(Group_<'a>),
    GroupAssignment(GroupAssignment_<'a>),
    GroupRelationship(GroupRelationship_<'a>),
    HalfSpaceSolid(HalfSpaceSolid_<'a>),
    HardnessRepresentation(HardnessRepresentation_<'a>),
    HiddenElementOverRidingStyledItem(HiddenElementOverRidingStyledItem_<'a>),
    HoleBottom(HoleBottom_<'a>),
    HoleInPanel(HoleInPanel_<'a>),
    HomokineticPair(HomokineticPair_<'a>),
    Hyperbola(Hyperbola_<'a>),
    IdAttribute(IdAttribute_<'a>),
    IdentificationAssignment(IdentificationAssignment_<'a>),
    IdentificationRole(IdentificationRole_<'a>),
    InclusionProductConceptFeature(InclusionProductConceptFeature_<'a>),
    IndexExpression(IndexExpression_<'a>),
    InitialState(InitialState_<'a>),
    InstancedFeature(InstancedFeature_<'a>),
    IntLiteral(IntLiteral_<'a>),
    IntNumericVariable(IntNumericVariable_<'a>),
    IntValueFunction(IntValueFunction_<'a>),
    IntegerDefinedFunction(IntegerDefinedFunction_<'a>),
    InterpolatedConfigurationSequence(InterpolatedConfigurationSequence_<'a>),
    IntersectionCurve(IntersectionCurve_<'a>),
    IntervalExpression(IntervalExpression_<'a>),
    Invisibility(Invisibility_<'a>),
    ItemDefinedTransformation(ItemDefinedTransformation_<'a>),
    ItemIdentifiedRepresentationUsage(ItemIdentifiedRepresentationUsage_<'a>),
    Joggle(Joggle_<'a>),
    JoggleTermination(JoggleTermination_<'a>),
    KinematicAnalysisConsistency(KinematicAnalysisConsistency_<'a>),
    KinematicAnalysisResult(KinematicAnalysisResult_<'a>),
    KinematicControl(KinematicControl_<'a>),
    KinematicFrameBackgroundRepresentation(KinematicFrameBackgroundRepresentation_<'a>),
    KinematicFrameBackgroundRepresentationAssociation(KinematicFrameBackgroundRepresentationAssociation_<'a>),
    KinematicFrameBasedTransformation(KinematicFrameBasedTransformation_<'a>),
    KinematicGroundRepresentation(KinematicGroundRepresentation_<'a>),
    KinematicJoint(KinematicJoint_<'a>),
    KinematicLink(KinematicLink_<'a>),
    KinematicLinkRepresentation(KinematicLinkRepresentation_<'a>),
    KinematicLinkRepresentationAssociation(KinematicLinkRepresentationAssociation_<'a>),
    KinematicLinkRepresentationRelation(KinematicLinkRepresentationRelation_<'a>),
    KinematicPair(KinematicPair_<'a>),
    KinematicPath(KinematicPath_<'a>),
    KinematicPropertyDefinition(KinematicPropertyDefinition_<'a>),
    KinematicPropertyRepresentationRelation(KinematicPropertyRepresentationRelation_<'a>),
    KinematicStructure(KinematicStructure_<'a>),
    KnownSource(KnownSource_<'a>),
    Language(Language_<'a>),
    LanguageAssignment(LanguageAssignment_<'a>),
    LeaderCurve(LeaderCurve_<'a>),
    LeaderDirectedCallout(LeaderDirectedCallout_<'a>),
    LeaderDirectedDimension(LeaderDirectedDimension_<'a>),
    LeaderTerminator(LeaderTerminator_<'a>),
    LengthFunction(LengthFunction_<'a>),
    LengthMeasureWithUnit(LengthMeasureWithUnit_<'a>),
    LengthUnit(LengthUnit_<'a>),
    LightSource(LightSource_<'a>),
    LightSourceAmbient(LightSourceAmbient_<'a>),
    LightSourceDirectional(LightSourceDirectional_<'a>),
    LightSourcePositional(LightSourcePositional_<'a>),
    LightSourceSpot(LightSourceSpot_<'a>),
    LikeExpression(LikeExpression_<'a>),
    LimitsAndFits(LimitsAndFits_<'a>),
    Line(Line_<'a>),
    LineProfileTolerance(LineProfileTolerance_<'a>),
    LinearDimension(LinearDimension_<'a>),
    LiteralNumber(LiteralNumber_<'a>),
    LocalTime(LocalTime_<'a>),
    LocationShapeRepresentation(LocationShapeRepresentation_<'a>),
    Locator(Locator_<'a>),
    Log10Function(Log10Function_<'a>),
    Log2Function(Log2Function_<'a>),
    LogFunction(LogFunction_<'a>),
    Loop(Loop_<'a>),
    LotEffectivity(LotEffectivity_<'a>),
    LuminousIntensityMeasureWithUnit(LuminousIntensityMeasureWithUnit_<'a>),
    LuminousIntensityUnit(LuminousIntensityUnit_<'a>),
    MakeFromUsageOption(MakeFromUsageOption_<'a>),
    ManifoldSolidBrep(ManifoldSolidBrep_<'a>),
    ManifoldSubsurfaceShapeRepresentation(ManifoldSubsurfaceShapeRepresentation_<'a>),
    ManifoldSurfaceShapeRepresentation(ManifoldSurfaceShapeRepresentation_<'a>),
    MappedItem(MappedItem_<'a>),
    MassMeasureWithUnit(MassMeasureWithUnit_<'a>),
    MassUnit(MassUnit_<'a>),
    MaterialDesignation(MaterialDesignation_<'a>),
    MaterialDesignationCharacterization(MaterialDesignationCharacterization_<'a>),
    MaterialProperty(MaterialProperty_<'a>),
    MaterialPropertyRepresentation(MaterialPropertyRepresentation_<'a>),
    MaximumFunction(MaximumFunction_<'a>),
    MeasureQualification(MeasureQualification_<'a>),
    MeasureRepresentationItem(MeasureRepresentationItem_<'a>),
    MeasureWithUnit(MeasureWithUnit_<'a>),
    MechanicalDesignGeometricPresentationArea(MechanicalDesignGeometricPresentationArea_<'a>),
    MechanicalDesignGeometricPresentationRepresentation(MechanicalDesignGeometricPresentationRepresentation_<'a>),
    Mechanism(Mechanism_<'a>),
    MechanismBasePlacement(MechanismBasePlacement_<'a>),
    MinimumFunction(MinimumFunction_<'a>),
    MinusExpression(MinusExpression_<'a>),
    MinusFunction(MinusFunction_<'a>),
    ModExpression(ModExpression_<'a>),
    ModifiedGeometricTolerance(ModifiedGeometricTolerance_<'a>),
    ModifiedPattern(ModifiedPattern_<'a>),
    MomentsOfInertiaRepresentation(MomentsOfInertiaRepresentation_<'a>),
    MotionLinkRelationship(MotionLinkRelationship_<'a>),
    MultExpression(MultExpression_<'a>),
    MultiLanguageAttributeAssignment(MultiLanguageAttributeAssignment_<'a>),
    MultipleArityBooleanExpression(MultipleArityBooleanExpression_<'a>),
    MultipleArityFunctionCall(MultipleArityFunctionCall_<'a>),
    MultipleArityGenericExpression(MultipleArityGenericExpression_<'a>),
    MultipleArityNumericExpression(MultipleArityNumericExpression_<'a>),
    NameAssignment(NameAssignment_<'a>),
    NameAttribute(NameAttribute_<'a>),
    NamedUnit(NamedUnit_<'a>),
    NamedUnitVariable(NamedUnitVariable_<'a>),
    NextAssemblyUsageOccurrence(NextAssemblyUsageOccurrence_<'a>),
    NgonClosedProfile(NgonClosedProfile_<'a>),
    NonManifoldSurfaceShapeRepresentation(NonManifoldSurfaceShapeRepresentation_<'a>),
    NotExpression(NotExpression_<'a>),
    NumericDefinedFunction(NumericDefinedFunction_<'a>),
    NumericExpression(NumericExpression_<'a>),
    NumericVariable(NumericVariable_<'a>),
    ObjectRole(ObjectRole_<'a>),
    OddFunction(OddFunction_<'a>),
    OffsetCurve2d(OffsetCurve2d_<'a>),
    OffsetCurve3d(OffsetCurve3d_<'a>),
    OffsetSurface(OffsetSurface_<'a>),
    OneDirectionRepeatFactor(OneDirectionRepeatFactor_<'a>),
    OpenPathProfile(OpenPathProfile_<'a>),
    OpenShell(OpenShell_<'a>),
    OrExpression(OrExpression_<'a>),
    OrdinateDimension(OrdinateDimension_<'a>),
    Organization(Organization_<'a>),
    OrganizationAssignment(OrganizationAssignment_<'a>),
    OrganizationRelationship(OrganizationRelationship_<'a>),
    OrganizationRole(OrganizationRole_<'a>),
    OrganizationalAddress(OrganizationalAddress_<'a>),
    OrganizationalProject(OrganizationalProject_<'a>),
    OrganizationalProjectAssignment(OrganizationalProjectAssignment_<'a>),
    OrganizationalProjectRelationship(OrganizationalProjectRelationship_<'a>),
    OrganizationalProjectRole(OrganizationalProjectRole_<'a>),
    OrientedClosedShell(OrientedClosedShell_<'a>),
    OrientedEdge(OrientedEdge_<'a>),
    OrientedFace(OrientedFace_<'a>),
    OrientedOpenShell(OrientedOpenShell_<'a>),
    OrientedPath(OrientedPath_<'a>),
    OrientedSurface(OrientedSurface_<'a>),
    OuterBoundaryCurve(OuterBoundaryCurve_<'a>),
    OverRidingStyledItem(OverRidingStyledItem_<'a>),
    PackageProductConceptFeature(PackageProductConceptFeature_<'a>),
    PairActuator(PairActuator_<'a>),
    PairValue(PairValue_<'a>),
    Parabola(Parabola_<'a>),
    ParallelOffset(ParallelOffset_<'a>),
    ParallelismTolerance(ParallelismTolerance_<'a>),
    ParametricRepresentationContext(ParametricRepresentationContext_<'a>),
    PartialCircularProfile(PartialCircularProfile_<'a>),
    Path(Path_<'a>),
    PathFeatureComponent(PathFeatureComponent_<'a>),
    PathShapeRepresentation(PathShapeRepresentation_<'a>),
    PatternOffsetMembership(PatternOffsetMembership_<'a>),
    PatternOmitMembership(PatternOmitMembership_<'a>),
    Pcurve(Pcurve_<'a>),
    PerpendicularTo(PerpendicularTo_<'a>),
    PerpendicularityTolerance(PerpendicularityTolerance_<'a>),
    Person(Person_<'a>),
    PersonAndOrganization(PersonAndOrganization_<'a>),
    PersonAndOrganizationAddress(PersonAndOrganizationAddress_<'a>),
    PersonAndOrganizationAssignment(PersonAndOrganizationAssignment_<'a>),
    PersonAndOrganizationRole(PersonAndOrganizationRole_<'a>),
    PersonalAddress(PersonalAddress_<'a>),
    PhysicallyModelledProductDefinition(PhysicallyModelledProductDefinition_<'a>),
    PlacedDatumTargetFeature(PlacedDatumTargetFeature_<'a>),
    PlacedFeature(PlacedFeature_<'a>),
    Placement(Placement_<'a>),
    PlanarBox(PlanarBox_<'a>),
    PlanarCurvePair(PlanarCurvePair_<'a>),
    PlanarCurvePairRange(PlanarCurvePairRange_<'a>),
    PlanarExtent(PlanarExtent_<'a>),
    PlanarPair(PlanarPair_<'a>),
    PlanarPairRange(PlanarPairRange_<'a>),
    PlanarPairValue(PlanarPairValue_<'a>),
    PlanarShapeRepresentation(PlanarShapeRepresentation_<'a>),
    Plane(Plane_<'a>),
    PlaneAngleMeasureWithUnit(PlaneAngleMeasureWithUnit_<'a>),
    PlaneAngleUnit(PlaneAngleUnit_<'a>),
    PlusExpression(PlusExpression_<'a>),
    PlusMinusTolerance(PlusMinusTolerance_<'a>),
    Pocket(Pocket_<'a>),
    PocketBottom(PocketBottom_<'a>),
    Point(Point_<'a>),
    PointOnCurve(PointOnCurve_<'a>),
    PointOnPlanarCurvePair(PointOnPlanarCurvePair_<'a>),
    PointOnPlanarCurvePairRange(PointOnPlanarCurvePairRange_<'a>),
    PointOnPlanarCurvePairValue(PointOnPlanarCurvePairValue_<'a>),
    PointOnSurface(PointOnSurface_<'a>),
    PointOnSurfacePair(PointOnSurfacePair_<'a>),
    PointOnSurfacePairRange(PointOnSurfacePairRange_<'a>),
    PointOnSurfacePairValue(PointOnSurfacePairValue_<'a>),
    PointPlacementShapeRepresentation(PointPlacementShapeRepresentation_<'a>),
    PointReplica(PointReplica_<'a>),
    PointStyle(PointStyle_<'a>),
    PolyLoop(PolyLoop_<'a>),
    Polyline(Polyline_<'a>),
    PositionTolerance(PositionTolerance_<'a>),
    PowerExpression(PowerExpression_<'a>),
    PreDefinedColour(PreDefinedColour_<'a>),
    PreDefinedCurveFont(PreDefinedCurveFont_<'a>),
    PreDefinedDimensionSymbol(PreDefinedDimensionSymbol_<'a>),
    PreDefinedGeometricalToleranceSymbol(PreDefinedGeometricalToleranceSymbol_<'a>),
    PreDefinedItem(PreDefinedItem_<'a>),
    PreDefinedMarker(PreDefinedMarker_<'a>),
    PreDefinedPointMarkerSymbol(PreDefinedPointMarkerSymbol_<'a>),
    PreDefinedPresentationStyle(PreDefinedPresentationStyle_<'a>),
    PreDefinedSurfaceConditionSymbol(PreDefinedSurfaceConditionSymbol_<'a>),
    PreDefinedSymbol(PreDefinedSymbol_<'a>),
    PreDefinedTerminatorSymbol(PreDefinedTerminatorSymbol_<'a>),
    PreDefinedTextFont(PreDefinedTextFont_<'a>),
    PrecisionQualifier(PrecisionQualifier_<'a>),
    PresentationArea(PresentationArea_<'a>),
    PresentationLayerAssignment(PresentationLayerAssignment_<'a>),
    PresentationRepresentation(PresentationRepresentation_<'a>),
    PresentationSet(PresentationSet_<'a>),
    PresentationSize(PresentationSize_<'a>),
    PresentationStyleAssignment(PresentationStyleAssignment_<'a>),
    PresentationStyleByContext(PresentationStyleByContext_<'a>),
    PresentationView(PresentationView_<'a>),
    PresentedItem(PresentedItem_<'a>),
    PresentedItemRepresentation(PresentedItemRepresentation_<'a>),
    PrismaticPair(PrismaticPair_<'a>),
    PrismaticPairRange(PrismaticPairRange_<'a>),
    PrismaticPairValue(PrismaticPairValue_<'a>),
    ProcessOperation(ProcessOperation_<'a>),
    ProcessPlan(ProcessPlan_<'a>),
    ProcessProductAssociation(ProcessProductAssociation_<'a>),
    ProcessPropertyAssociation(ProcessPropertyAssociation_<'a>),
    Product(Product_<'a>),
    ProductCategory(ProductCategory_<'a>),
    ProductCategoryRelationship(ProductCategoryRelationship_<'a>),
    ProductClass(ProductClass_<'a>),
    ProductConcept(ProductConcept_<'a>),
    ProductConceptContext(ProductConceptContext_<'a>),
    ProductConceptFeature(ProductConceptFeature_<'a>),
    ProductConceptFeatureAssociation(ProductConceptFeatureAssociation_<'a>),
    ProductConceptFeatureCategory(ProductConceptFeatureCategory_<'a>),
    ProductConceptFeatureCategoryUsage(ProductConceptFeatureCategoryUsage_<'a>),
    ProductConceptRelationship(ProductConceptRelationship_<'a>),
    ProductContext(ProductContext_<'a>),
    ProductDefinition(ProductDefinition_<'a>),
    ProductDefinitionContext(ProductDefinitionContext_<'a>),
    ProductDefinitionContextAssociation(ProductDefinitionContextAssociation_<'a>),
    ProductDefinitionContextRole(ProductDefinitionContextRole_<'a>),
    ProductDefinitionEffectivity(ProductDefinitionEffectivity_<'a>),
    ProductDefinitionFormation(ProductDefinitionFormation_<'a>),
    ProductDefinitionFormationRelationship(ProductDefinitionFormationRelationship_<'a>),
    ProductDefinitionFormationWithSpecifiedSource(ProductDefinitionFormationWithSpecifiedSource_<'a>),
    ProductDefinitionOccurrenceRelationship(ProductDefinitionOccurrenceRelationship_<'a>),
    ProductDefinitionProcess(ProductDefinitionProcess_<'a>),
    ProductDefinitionRelationship(ProductDefinitionRelationship_<'a>),
    ProductDefinitionResource(ProductDefinitionResource_<'a>),
    ProductDefinitionShape(ProductDefinitionShape_<'a>),
    ProductDefinitionSubstitute(ProductDefinitionSubstitute_<'a>),
    ProductDefinitionUsage(ProductDefinitionUsage_<'a>),
    ProductDefinitionWithAssociatedDocuments(ProductDefinitionWithAssociatedDocuments_<'a>),
    ProductIdentification(ProductIdentification_<'a>),
    ProductProcessPlan(ProductProcessPlan_<'a>),
    ProductRelatedProductCategory(ProductRelatedProductCategory_<'a>),
    ProductSpecification(ProductSpecification_<'a>),
    ProjectedZoneDefinition(ProjectedZoneDefinition_<'a>),
    ProjectionCurve(ProjectionCurve_<'a>),
    ProjectionDirectedCallout(ProjectionDirectedCallout_<'a>),
    PromissoryUsageOccurrence(PromissoryUsageOccurrence_<'a>),
    PropertyDefinition(PropertyDefinition_<'a>),
    PropertyDefinitionRelationship(PropertyDefinitionRelationship_<'a>),
    PropertyDefinitionRepresentation(PropertyDefinitionRepresentation_<'a>),
    PropertyProcess(PropertyProcess_<'a>),
    QualifiedRepresentationItem(QualifiedRepresentationItem_<'a>),
    QualitativeUncertainty(QualitativeUncertainty_<'a>),
    QuantifiedAssemblyComponentUsage(QuantifiedAssemblyComponentUsage_<'a>),
    QuasiUniformCurve(QuasiUniformCurve_<'a>),
    QuasiUniformSurface(QuasiUniformSurface_<'a>),
    RackAndPinionPair(RackAndPinionPair_<'a>),
    RackAndPinionPairRange(RackAndPinionPairRange_<'a>),
    RackAndPinionPairValue(RackAndPinionPairValue_<'a>),
    RadiusDimension(RadiusDimension_<'a>),
    RatioMeasureWithUnit(RatioMeasureWithUnit_<'a>),
    RatioUnit(RatioUnit_<'a>),
    RationalBSplineCurve(RationalBSplineCurve_<'a>),
    RationalBSplineSurface(RationalBSplineSurface_<'a>),
    RealDefinedFunction(RealDefinedFunction_<'a>),
    RealLiteral(RealLiteral_<'a>),
    RealNumericVariable(RealNumericVariable_<'a>),
    RectangularClosedProfile(RectangularClosedProfile_<'a>),
    RectangularCompositeSurface(RectangularCompositeSurface_<'a>),
    RectangularPattern(RectangularPattern_<'a>),
    RectangularTrimmedSurface(RectangularTrimmedSurface_<'a>),
    ReferencedModifiedDatum(ReferencedModifiedDatum_<'a>),
    RelativeEventOccurrence(RelativeEventOccurrence_<'a>),
    RepItemGroup(RepItemGroup_<'a>),
    ReparametrisedCompositeCurveSegment(ReparametrisedCompositeCurveSegment_<'a>),
    ReplicateFeature(ReplicateFeature_<'a>),
    Representation(Representation_<'a>),
    RepresentationContext(RepresentationContext_<'a>),
    RepresentationItem(RepresentationItem_<'a>),
    RepresentationMap(RepresentationMap_<'a>),
    RepresentationRelationship(RepresentationRelationship_<'a>),
    RepresentationRelationshipWithTransformation(RepresentationRelationshipWithTransformation_<'a>),
    RequirementForActionResource(RequirementForActionResource_<'a>),
    ResourceProperty(ResourceProperty_<'a>),
    ResourcePropertyRepresentation(ResourcePropertyRepresentation_<'a>),
    ResourceRequirementType(ResourceRequirementType_<'a>),
    ResultingPath(ResultingPath_<'a>),
    Retention(Retention_<'a>),
    RevolutePair(RevolutePair_<'a>),
    RevolutePairRange(RevolutePairRange_<'a>),
    RevolutePairValue(RevolutePairValue_<'a>),
    RevolvedAreaSolid(RevolvedAreaSolid_<'a>),
    RevolvedFaceSolid(RevolvedFaceSolid_<'a>),
    Rib(Rib_<'a>),
    RightAngularWedge(RightAngularWedge_<'a>),
    RightCircularCone(RightCircularCone_<'a>),
    RightCircularCylinder(RightCircularCylinder_<'a>),
    RoleAssociation(RoleAssociation_<'a>),
    RollingCurvePair(RollingCurvePair_<'a>),
    RollingCurvePairValue(RollingCurvePairValue_<'a>),
    RollingSurfacePair(RollingSurfacePair_<'a>),
    RollingSurfacePairValue(RollingSurfacePairValue_<'a>),
    RotationAboutDirection(RotationAboutDirection_<'a>),
    RoundHole(RoundHole_<'a>),
    RoundedUProfile(RoundedUProfile_<'a>),
    RoundnessTolerance(RoundnessTolerance_<'a>),
    RuledSurfaceSweptAreaSolid(RuledSurfaceSweptAreaSolid_<'a>),
    RunoutZoneDefinition(RunoutZoneDefinition_<'a>),
    RunoutZoneOrientation(RunoutZoneOrientation_<'a>),
    RunoutZoneOrientationReferenceDirection(RunoutZoneOrientationReferenceDirection_<'a>),
    ScrewPair(ScrewPair_<'a>),
    ScrewPairRange(ScrewPairRange_<'a>),
    ScrewPairValue(ScrewPairValue_<'a>),
    SeamCurve(SeamCurve_<'a>),
    SeamEdge(SeamEdge_<'a>),
    SecurityClassification(SecurityClassification_<'a>),
    SecurityClassificationAssignment(SecurityClassificationAssignment_<'a>),
    SecurityClassificationLevel(SecurityClassificationLevel_<'a>),
    SerialNumberedEffectivity(SerialNumberedEffectivity_<'a>),
    ShapeAspect(ShapeAspect_<'a>),
    ShapeAspectAssociativity(ShapeAspectAssociativity_<'a>),
    ShapeAspectDerivingRelationship(ShapeAspectDerivingRelationship_<'a>),
    ShapeAspectRelationship(ShapeAspectRelationship_<'a>),
    ShapeAspectTransition(ShapeAspectTransition_<'a>),
    ShapeDefiningRelationship(ShapeDefiningRelationship_<'a>),
    ShapeDefinitionRepresentation(ShapeDefinitionRepresentation_<'a>),
    ShapeDimensionRepresentation(ShapeDimensionRepresentation_<'a>),
    ShapeRepresentation(ShapeRepresentation_<'a>),
    ShapeRepresentationRelationship(ShapeRepresentationRelationship_<'a>),
    ShapeRepresentationWithParameters(ShapeRepresentationWithParameters_<'a>),
    ShellBasedSurfaceModel(ShellBasedSurfaceModel_<'a>),
    SiUnit(SiUnit_<'a>),
    SimpleBooleanExpression(SimpleBooleanExpression_<'a>),
    SimpleGenericExpression(SimpleGenericExpression_<'a>),
    SimpleNumericExpression(SimpleNumericExpression_<'a>),
    SimplePairRange(SimplePairRange_<'a>),
    SimpleStringExpression(SimpleStringExpression_<'a>),
    SinFunction(SinFunction_<'a>),
    SlashExpression(SlashExpression_<'a>),
    SlidingCurvePair(SlidingCurvePair_<'a>),
    SlidingCurvePairValue(SlidingCurvePairValue_<'a>),
    SlidingSurfacePair(SlidingSurfacePair_<'a>),
    SlidingSurfacePairValue(SlidingSurfacePairValue_<'a>),
    Slot(Slot_<'a>),
    SlotEnd(SlotEnd_<'a>),
    SolidAngleMeasureWithUnit(SolidAngleMeasureWithUnit_<'a>),
    SolidAngleUnit(SolidAngleUnit_<'a>),
    SolidModel(SolidModel_<'a>),
    SolidReplica(SolidReplica_<'a>),
    SpecifiedHigherUsageOccurrence(SpecifiedHigherUsageOccurrence_<'a>),
    Sphere(Sphere_<'a>),
    SphericalPair(SphericalPair_<'a>),
    SphericalPairRange(SphericalPairRange_<'a>),
    SphericalPairValue(SphericalPairValue_<'a>),
    SphericalSurface(SphericalSurface_<'a>),
    SqlMappableDefinedFunction(SqlMappableDefinedFunction_<'a>),
    SquareRootFunction(SquareRootFunction_<'a>),
    SquareUProfile(SquareUProfile_<'a>),
    StandardUncertainty(StandardUncertainty_<'a>),
    StraightnessTolerance(StraightnessTolerance_<'a>),
    StringDefinedFunction(StringDefinedFunction_<'a>),
    StringExpression(StringExpression_<'a>),
    StringLiteral(StringLiteral_<'a>),
    StringVariable(StringVariable_<'a>),
    StructuredDimensionCallout(StructuredDimensionCallout_<'a>),
    StyledItem(StyledItem_<'a>),
    Subedge(Subedge_<'a>),
    Subface(Subface_<'a>),
    SubstringExpression(SubstringExpression_<'a>),
    Surface(Surface_<'a>),
    SurfaceConditionCallout(SurfaceConditionCallout_<'a>),
    SurfaceCurve(SurfaceCurve_<'a>),
    SurfaceCurveSweptAreaSolid(SurfaceCurveSweptAreaSolid_<'a>),
    SurfaceOfLinearExtrusion(SurfaceOfLinearExtrusion_<'a>),
    SurfaceOfRevolution(SurfaceOfRevolution_<'a>),
    SurfacePair(SurfacePair_<'a>),
    SurfacePairRange(SurfacePairRange_<'a>),
    SurfacePatch(SurfacePatch_<'a>),
    SurfaceProfileTolerance(SurfaceProfileTolerance_<'a>),
    SurfaceRenderingProperties(SurfaceRenderingProperties_<'a>),
    SurfaceReplica(SurfaceReplica_<'a>),
    SurfaceSideStyle(SurfaceSideStyle_<'a>),
    SurfaceStyleBoundary(SurfaceStyleBoundary_<'a>),
    SurfaceStyleControlGrid(SurfaceStyleControlGrid_<'a>),
    SurfaceStyleFillArea(SurfaceStyleFillArea_<'a>),
    SurfaceStyleParameterLine(SurfaceStyleParameterLine_<'a>),
    SurfaceStyleReflectanceAmbient(SurfaceStyleReflectanceAmbient_<'a>),
    SurfaceStyleReflectanceAmbientDiffuse(SurfaceStyleReflectanceAmbientDiffuse_<'a>),
    SurfaceStyleReflectanceAmbientDiffuseSpecular(SurfaceStyleReflectanceAmbientDiffuseSpecular_<'a>),
    SurfaceStyleRendering(SurfaceStyleRendering_<'a>),
    SurfaceStyleRenderingWithProperties(SurfaceStyleRenderingWithProperties_<'a>),
    SurfaceStyleSegmentationCurve(SurfaceStyleSegmentationCurve_<'a>),
    SurfaceStyleSilhouette(SurfaceStyleSilhouette_<'a>),
    SurfaceStyleTransparent(SurfaceStyleTransparent_<'a>),
    SurfaceStyleUsage(SurfaceStyleUsage_<'a>),
    SurfaceTextureRepresentation(SurfaceTextureRepresentation_<'a>),
    SweptAreaSolid(SweptAreaSolid_<'a>),
    SweptDiskSolid(SweptDiskSolid_<'a>),
    SweptFaceSolid(SweptFaceSolid_<'a>),
    SweptSurface(SweptSurface_<'a>),
    SymbolColour(SymbolColour_<'a>),
    SymbolRepresentation(SymbolRepresentation_<'a>),
    SymbolRepresentationMap(SymbolRepresentationMap_<'a>),
    SymbolStyle(SymbolStyle_<'a>),
    SymbolTarget(SymbolTarget_<'a>),
    SymmetricShapeAspect(SymmetricShapeAspect_<'a>),
    SymmetryTolerance(SymmetryTolerance_<'a>),
    TactileAppearanceRepresentation(TactileAppearanceRepresentation_<'a>),
    TanFunction(TanFunction_<'a>),
    Tangent(Tangent_<'a>),
    Taper(Taper_<'a>),
    TeeProfile(TeeProfile_<'a>),
    TerminatorSymbol(TerminatorSymbol_<'a>),
    TextLiteral(TextLiteral_<'a>),
    TextLiteralWithAssociatedCurves(TextLiteralWithAssociatedCurves_<'a>),
    TextLiteralWithBlankingBox(TextLiteralWithBlankingBox_<'a>),
    TextLiteralWithDelineation(TextLiteralWithDelineation_<'a>),
    TextLiteralWithExtent(TextLiteralWithExtent_<'a>),
    TextStringRepresentation(TextStringRepresentation_<'a>),
    TextStyle(TextStyle_<'a>),
    TextStyleForDefinedFont(TextStyleForDefinedFont_<'a>),
    TextStyleWithBoxCharacteristics(TextStyleWithBoxCharacteristics_<'a>),
    TextStyleWithMirror(TextStyleWithMirror_<'a>),
    TextStyleWithSpacing(TextStyleWithSpacing_<'a>),
    ThermodynamicTemperatureMeasureWithUnit(ThermodynamicTemperatureMeasureWithUnit_<'a>),
    ThermodynamicTemperatureUnit(ThermodynamicTemperatureUnit_<'a>),
    Thread(Thread_<'a>),
    TimeInterval(TimeInterval_<'a>),
    TimeIntervalAssignment(TimeIntervalAssignment_<'a>),
    TimeIntervalBasedEffectivity(TimeIntervalBasedEffectivity_<'a>),
    TimeIntervalRole(TimeIntervalRole_<'a>),
    TimeIntervalWithBounds(TimeIntervalWithBounds_<'a>),
    TimeMeasureWithUnit(TimeMeasureWithUnit_<'a>),
    TimeUnit(TimeUnit_<'a>),
    ToleranceValue(ToleranceValue_<'a>),
    ToleranceZone(ToleranceZone_<'a>),
    ToleranceZoneDefinition(ToleranceZoneDefinition_<'a>),
    ToleranceZoneForm(ToleranceZoneForm_<'a>),
    TopologicalRepresentationItem(TopologicalRepresentationItem_<'a>),
    ToroidalSurface(ToroidalSurface_<'a>),
    Torus(Torus_<'a>),
    TotalRunoutTolerance(TotalRunoutTolerance_<'a>),
    TransitionFeature(TransitionFeature_<'a>),
    TrimmedCurve(TrimmedCurve_<'a>),
    TwoDirectionRepeatFactor(TwoDirectionRepeatFactor_<'a>),
    TypeQualifier(TypeQualifier_<'a>),
    UnaryBooleanExpression(UnaryBooleanExpression_<'a>),
    UnaryFunctionCall(UnaryFunctionCall_<'a>),
    UnaryGenericExpression(UnaryGenericExpression_<'a>),
    UnaryNumericExpression(UnaryNumericExpression_<'a>),
    UncertaintyAssignedRepresentation(UncertaintyAssignedRepresentation_<'a>),
    UncertaintyMeasureWithUnit(UncertaintyMeasureWithUnit_<'a>),
    UncertaintyQualifier(UncertaintyQualifier_<'a>),
    UnconstrainedPair(UnconstrainedPair_<'a>),
    UnconstrainedPairValue(UnconstrainedPairValue_<'a>),
    UniformCurve(UniformCurve_<'a>),
    UniformSurface(UniformSurface_<'a>),
    UniversalPair(UniversalPair_<'a>),
    UniversalPairRange(UniversalPairRange_<'a>),
    UniversalPairValue(UniversalPairValue_<'a>),
    ValueFunction(ValueFunction_<'a>),
    ValueRange(ValueRange_<'a>),
    ValueRepresentationItem(ValueRepresentationItem_<'a>),
    Variable(Variable_<'a>),
    VariableSemantics(VariableSemantics_<'a>),
    Vector(Vector_<'a>),
    VectorStyle(VectorStyle_<'a>),
    VeeProfile(VeeProfile_<'a>),
    VersionedActionRequest(VersionedActionRequest_<'a>),
    VersionedActionRequestRelationship(VersionedActionRequestRelationship_<'a>),
    Vertex(Vertex_<'a>),
    VertexLoop(VertexLoop_<'a>),
    VertexPoint(VertexPoint_<'a>),
    ViewVolume(ViewVolume_<'a>),
    VisualAppearanceRepresentation(VisualAppearanceRepresentation_<'a>),
    VolumeMeasureWithUnit(VolumeMeasureWithUnit_<'a>),
    VolumeUnit(VolumeUnit_<'a>),
    XorExpression(XorExpression_<'a>),
    ComplexEntity(Vec<Entity<'a>>),
    _FailedToParse,
    _EmptySlot,
}
impl<'a> ParseFromChunks<'a> for Entity<'a> {
    fn parse_chunks(strs: &[&'a str]) -> IResult<'a, Self> {
        let (_, r) = recognize(pair(
            alt((alpha0, tag("_"))),
            many0(alt((alphanumeric1, tag("_")))),
        ))(strs[0])?;
        match r {
            "ABS_FUNCTION" => AbsFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AbsFunction(v))),
            "ACOS_FUNCTION" => AcosFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AcosFunction(v))),
            "ACTION" => Action_::parse_chunks(strs).map(|(s, v)| (s, Entity::Action(v))),
            "ACTION_ASSIGNMENT" => ActionAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionAssignment(v))),
            "ACTION_DIRECTIVE" => ActionDirective_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionDirective(v))),
            "ACTION_METHOD" => ActionMethod_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionMethod(v))),
            "ACTION_METHOD_RELATIONSHIP" => ActionMethodRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionMethodRelationship(v))),
            "ACTION_PROPERTY" => ActionProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionProperty(v))),
            "ACTION_PROPERTY_REPRESENTATION" => ActionPropertyRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionPropertyRepresentation(v))),
            "ACTION_RELATIONSHIP" => ActionRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRelationship(v))),
            "ACTION_REQUEST_ASSIGNMENT" => ActionRequestAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRequestAssignment(v))),
            "ACTION_REQUEST_SOLUTION" => ActionRequestSolution_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRequestSolution(v))),
            "ACTION_REQUEST_STATUS" => ActionRequestStatus_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionRequestStatus(v))),
            "ACTION_RESOURCE" => ActionResource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionResource(v))),
            "ACTION_RESOURCE_REQUIREMENT" => ActionResourceRequirement_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionResourceRequirement(v))),
            "ACTION_RESOURCE_TYPE" => ActionResourceType_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionResourceType(v))),
            "ACTION_STATUS" => ActionStatus_::parse_chunks(strs).map(|(s, v)| (s, Entity::ActionStatus(v))),
            "ADDRESS" => Address_::parse_chunks(strs).map(|(s, v)| (s, Entity::Address(v))),
            "ADVANCED_BREP_SHAPE_REPRESENTATION" => AdvancedBrepShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::AdvancedBrepShapeRepresentation(v))),
            "ADVANCED_FACE" => AdvancedFace_::parse_chunks(strs).map(|(s, v)| (s, Entity::AdvancedFace(v))),
            "ALTERNATE_PRODUCT_RELATIONSHIP" => AlternateProductRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::AlternateProductRelationship(v))),
            "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => AmountOfSubstanceMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AmountOfSubstanceMeasureWithUnit(v))),
            "AMOUNT_OF_SUBSTANCE_UNIT" => AmountOfSubstanceUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AmountOfSubstanceUnit(v))),
            "AND_EXPRESSION" => AndExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::AndExpression(v))),
            "ANGULAR_DIMENSION" => AngularDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularDimension(v))),
            "ANGULAR_LOCATION" => AngularLocation_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularLocation(v))),
            "ANGULAR_SIZE" => AngularSize_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularSize(v))),
            "ANGULARITY_TOLERANCE" => AngularityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::AngularityTolerance(v))),
            "ANNOTATION_CURVE_OCCURRENCE" => AnnotationCurveOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationCurveOccurrence(v))),
            "ANNOTATION_FILL_AREA" => AnnotationFillArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationFillArea(v))),
            "ANNOTATION_FILL_AREA_OCCURRENCE" => AnnotationFillAreaOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationFillAreaOccurrence(v))),
            "ANNOTATION_OCCURRENCE" => AnnotationOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationOccurrence(v))),
            "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => AnnotationOccurrenceAssociativity_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationOccurrenceAssociativity(v))),
            "ANNOTATION_OCCURRENCE_RELATIONSHIP" => AnnotationOccurrenceRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationOccurrenceRelationship(v))),
            "ANNOTATION_PLANE" => AnnotationPlane_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationPlane(v))),
            "ANNOTATION_SUBFIGURE_OCCURRENCE" => AnnotationSubfigureOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationSubfigureOccurrence(v))),
            "ANNOTATION_SYMBOL" => AnnotationSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationSymbol(v))),
            "ANNOTATION_SYMBOL_OCCURRENCE" => AnnotationSymbolOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationSymbolOccurrence(v))),
            "ANNOTATION_TEXT" => AnnotationText_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationText(v))),
            "ANNOTATION_TEXT_CHARACTER" => AnnotationTextCharacter_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationTextCharacter(v))),
            "ANNOTATION_TEXT_OCCURRENCE" => AnnotationTextOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::AnnotationTextOccurrence(v))),
            "APEX" => Apex_::parse_chunks(strs).map(|(s, v)| (s, Entity::Apex(v))),
            "APPLICATION_CONTEXT" => ApplicationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationContext(v))),
            "APPLICATION_CONTEXT_ELEMENT" => ApplicationContextElement_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationContextElement(v))),
            "APPLICATION_CONTEXT_RELATIONSHIP" => ApplicationContextRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationContextRelationship(v))),
            "APPLICATION_PROTOCOL_DEFINITION" => ApplicationProtocolDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApplicationProtocolDefinition(v))),
            "APPLIED_ACTION_ASSIGNMENT" => AppliedActionAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedActionAssignment(v))),
            "APPLIED_ACTION_REQUEST_ASSIGNMENT" => AppliedActionRequestAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedActionRequestAssignment(v))),
            "APPLIED_APPROVAL_ASSIGNMENT" => AppliedApprovalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedApprovalAssignment(v))),
            "APPLIED_AREA" => AppliedArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedArea(v))),
            "APPLIED_CERTIFICATION_ASSIGNMENT" => AppliedCertificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedCertificationAssignment(v))),
            "APPLIED_CLASSIFICATION_ASSIGNMENT" => AppliedClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedClassificationAssignment(v))),
            "APPLIED_CONTRACT_ASSIGNMENT" => AppliedContractAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedContractAssignment(v))),
            "APPLIED_DATE_AND_TIME_ASSIGNMENT" => AppliedDateAndTimeAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDateAndTimeAssignment(v))),
            "APPLIED_DATE_ASSIGNMENT" => AppliedDateAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDateAssignment(v))),
            "APPLIED_DOCUMENT_REFERENCE" => AppliedDocumentReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDocumentReference(v))),
            "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => AppliedDocumentUsageConstraintAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedDocumentUsageConstraintAssignment(v))),
            "APPLIED_EFFECTIVITY_ASSIGNMENT" => AppliedEffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedEffectivityAssignment(v))),
            "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => AppliedEventOccurrenceAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedEventOccurrenceAssignment(v))),
            "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => AppliedExternalIdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedExternalIdentificationAssignment(v))),
            "APPLIED_GROUP_ASSIGNMENT" => AppliedGroupAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedGroupAssignment(v))),
            "APPLIED_IDENTIFICATION_ASSIGNMENT" => AppliedIdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedIdentificationAssignment(v))),
            "APPLIED_INEFFECTIVITY_ASSIGNMENT" => AppliedIneffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedIneffectivityAssignment(v))),
            "APPLIED_NAME_ASSIGNMENT" => AppliedNameAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedNameAssignment(v))),
            "APPLIED_ORGANIZATION_ASSIGNMENT" => AppliedOrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedOrganizationAssignment(v))),
            "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => AppliedOrganizationalProjectAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedOrganizationalProjectAssignment(v))),
            "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => AppliedPersonAndOrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedPersonAndOrganizationAssignment(v))),
            "APPLIED_PRESENTED_ITEM" => AppliedPresentedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedPresentedItem(v))),
            "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => AppliedSecurityClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedSecurityClassificationAssignment(v))),
            "APPLIED_TIME_INTERVAL_ASSIGNMENT" => AppliedTimeIntervalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AppliedTimeIntervalAssignment(v))),
            "APPROVAL" => Approval_::parse_chunks(strs).map(|(s, v)| (s, Entity::Approval(v))),
            "APPROVAL_ASSIGNMENT" => ApprovalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalAssignment(v))),
            "APPROVAL_DATE_TIME" => ApprovalDateTime_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalDateTime(v))),
            "APPROVAL_PERSON_ORGANIZATION" => ApprovalPersonOrganization_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalPersonOrganization(v))),
            "APPROVAL_RELATIONSHIP" => ApprovalRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalRelationship(v))),
            "APPROVAL_ROLE" => ApprovalRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalRole(v))),
            "APPROVAL_STATUS" => ApprovalStatus_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApprovalStatus(v))),
            "APPROXIMATION_TOLERANCE" => ApproximationTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApproximationTolerance(v))),
            "APPROXIMATION_TOLERANCE_DEVIATION" => ApproximationToleranceDeviation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApproximationToleranceDeviation(v))),
            "APPROXIMATION_TOLERANCE_PARAMETER" => ApproximationToleranceParameter_::parse_chunks(strs).map(|(s, v)| (s, Entity::ApproximationToleranceParameter(v))),
            "AREA_IN_SET" => AreaInSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::AreaInSet(v))),
            "AREA_MEASURE_WITH_UNIT" => AreaMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AreaMeasureWithUnit(v))),
            "AREA_UNIT" => AreaUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::AreaUnit(v))),
            "ASIN_FUNCTION" => AsinFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AsinFunction(v))),
            "ASSEMBLY_COMPONENT_USAGE" => AssemblyComponentUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::AssemblyComponentUsage(v))),
            "ASSEMBLY_COMPONENT_USAGE_SUBSTITUTE" => AssemblyComponentUsageSubstitute_::parse_chunks(strs).map(|(s, v)| (s, Entity::AssemblyComponentUsageSubstitute(v))),
            "ATAN_FUNCTION" => AtanFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::AtanFunction(v))),
            "ATTRIBUTE_CLASSIFICATION_ASSIGNMENT" => AttributeClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeClassificationAssignment(v))),
            "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => AttributeLanguageAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeLanguageAssignment(v))),
            "ATTRIBUTE_VALUE_ASSIGNMENT" => AttributeValueAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeValueAssignment(v))),
            "ATTRIBUTE_VALUE_ROLE" => AttributeValueRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::AttributeValueRole(v))),
            "AXIS1_PLACEMENT" => Axis1Placement_::parse_chunks(strs).map(|(s, v)| (s, Entity::Axis1Placement(v))),
            "AXIS2_PLACEMENT_2D" => Axis2Placement2d_::parse_chunks(strs).map(|(s, v)| (s, Entity::Axis2Placement2d(v))),
            "AXIS2_PLACEMENT_3D" => Axis2Placement3d_::parse_chunks(strs).map(|(s, v)| (s, Entity::Axis2Placement3d(v))),
            "B_SPLINE_CURVE" => BSplineCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineCurve(v))),
            "B_SPLINE_CURVE_WITH_KNOTS" => BSplineCurveWithKnots_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineCurveWithKnots(v))),
            "B_SPLINE_SURFACE" => BSplineSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineSurface(v))),
            "B_SPLINE_SURFACE_WITH_KNOTS" => BSplineSurfaceWithKnots_::parse_chunks(strs).map(|(s, v)| (s, Entity::BSplineSurfaceWithKnots(v))),
            "BACKGROUND_COLOUR" => BackgroundColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::BackgroundColour(v))),
            "BARRING_HOLE" => BarringHole_::parse_chunks(strs).map(|(s, v)| (s, Entity::BarringHole(v))),
            "BEAD" => Bead_::parse_chunks(strs).map(|(s, v)| (s, Entity::Bead(v))),
            "BEAD_END" => BeadEnd_::parse_chunks(strs).map(|(s, v)| (s, Entity::BeadEnd(v))),
            "BEZIER_CURVE" => BezierCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BezierCurve(v))),
            "BEZIER_SURFACE" => BezierSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::BezierSurface(v))),
            "BINARY_BOOLEAN_EXPRESSION" => BinaryBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryBooleanExpression(v))),
            "BINARY_FUNCTION_CALL" => BinaryFunctionCall_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryFunctionCall(v))),
            "BINARY_GENERIC_EXPRESSION" => BinaryGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryGenericExpression(v))),
            "BINARY_NUMERIC_EXPRESSION" => BinaryNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BinaryNumericExpression(v))),
            "BLOCK" => Block_::parse_chunks(strs).map(|(s, v)| (s, Entity::Block(v))),
            "BOOLEAN_DEFINED_FUNCTION" => BooleanDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanDefinedFunction(v))),
            "BOOLEAN_EXPRESSION" => BooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanExpression(v))),
            "BOOLEAN_LITERAL" => BooleanLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanLiteral(v))),
            "BOOLEAN_RESULT" => BooleanResult_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanResult(v))),
            "BOOLEAN_VARIABLE" => BooleanVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::BooleanVariable(v))),
            "BOSS" => Boss_::parse_chunks(strs).map(|(s, v)| (s, Entity::Boss(v))),
            "BOSS_TOP" => BossTop_::parse_chunks(strs).map(|(s, v)| (s, Entity::BossTop(v))),
            "BOUNDARY_CURVE" => BoundaryCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundaryCurve(v))),
            "BOUNDED_CURVE" => BoundedCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedCurve(v))),
            "BOUNDED_PCURVE" => BoundedPcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedPcurve(v))),
            "BOUNDED_SURFACE" => BoundedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedSurface(v))),
            "BOUNDED_SURFACE_CURVE" => BoundedSurfaceCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoundedSurfaceCurve(v))),
            "BOX_DOMAIN" => BoxDomain_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoxDomain(v))),
            "BOXED_HALF_SPACE" => BoxedHalfSpace_::parse_chunks(strs).map(|(s, v)| (s, Entity::BoxedHalfSpace(v))),
            "BREP_WITH_VOIDS" => BrepWithVoids_::parse_chunks(strs).map(|(s, v)| (s, Entity::BrepWithVoids(v))),
            "CALENDAR_DATE" => CalendarDate_::parse_chunks(strs).map(|(s, v)| (s, Entity::CalendarDate(v))),
            "CAMERA_IMAGE" => CameraImage_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraImage(v))),
            "CAMERA_IMAGE_2D_WITH_SCALE" => CameraImage2dWithScale_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraImage2dWithScale(v))),
            "CAMERA_IMAGE_3D_WITH_SCALE" => CameraImage3dWithScale_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraImage3dWithScale(v))),
            "CAMERA_MODEL" => CameraModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModel(v))),
            "CAMERA_MODEL_D2" => CameraModelD2_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModelD2(v))),
            "CAMERA_MODEL_D3" => CameraModelD3_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModelD3(v))),
            "CAMERA_MODEL_D3_WITH_HLHSR" => CameraModelD3WithHlhsr_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraModelD3WithHlhsr(v))),
            "CAMERA_USAGE" => CameraUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::CameraUsage(v))),
            "CARTESIAN_POINT" => CartesianPoint_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianPoint(v))),
            "CARTESIAN_TRANSFORMATION_OPERATOR" => CartesianTransformationOperator_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianTransformationOperator(v))),
            "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => CartesianTransformationOperator2d_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianTransformationOperator2d(v))),
            "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => CartesianTransformationOperator3d_::parse_chunks(strs).map(|(s, v)| (s, Entity::CartesianTransformationOperator3d(v))),
            "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => CelsiusTemperatureMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::CelsiusTemperatureMeasureWithUnit(v))),
            "CENTRE_OF_SYMMETRY" => CentreOfSymmetry_::parse_chunks(strs).map(|(s, v)| (s, Entity::CentreOfSymmetry(v))),
            "CERTIFICATION" => Certification_::parse_chunks(strs).map(|(s, v)| (s, Entity::Certification(v))),
            "CERTIFICATION_ASSIGNMENT" => CertificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::CertificationAssignment(v))),
            "CERTIFICATION_TYPE" => CertificationType_::parse_chunks(strs).map(|(s, v)| (s, Entity::CertificationType(v))),
            "CHAMFER" => Chamfer_::parse_chunks(strs).map(|(s, v)| (s, Entity::Chamfer(v))),
            "CHAMFER_OFFSET" => ChamferOffset_::parse_chunks(strs).map(|(s, v)| (s, Entity::ChamferOffset(v))),
            "CHARACTER_GLYPH_SYMBOL" => CharacterGlyphSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::CharacterGlyphSymbol(v))),
            "CHARACTERIZED_CLASS" => CharacterizedClass_::parse_chunks(strs).map(|(s, v)| (s, Entity::CharacterizedClass(v))),
            "CHARACTERIZED_OBJECT" => CharacterizedObject_::parse_chunks(strs).map(|(s, v)| (s, Entity::CharacterizedObject(v))),
            "CIRCLE" => Circle_::parse_chunks(strs).map(|(s, v)| (s, Entity::Circle(v))),
            "CIRCULAR_CLOSED_PROFILE" => CircularClosedProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::CircularClosedProfile(v))),
            "CIRCULAR_PATTERN" => CircularPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::CircularPattern(v))),
            "CIRCULAR_RUNOUT_TOLERANCE" => CircularRunoutTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::CircularRunoutTolerance(v))),
            "CLASS" => Class_::parse_chunks(strs).map(|(s, v)| (s, Entity::Class(v))),
            "CLASS_SYSTEM" => ClassSystem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassSystem(v))),
            "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => ClassUsageEffectivityContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassUsageEffectivityContextAssignment(v))),
            "CLASSIFICATION_ASSIGNMENT" => ClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassificationAssignment(v))),
            "CLASSIFICATION_ROLE" => ClassificationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClassificationRole(v))),
            "CLOSED_PATH_PROFILE" => ClosedPathProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClosedPathProfile(v))),
            "CLOSED_SHELL" => ClosedShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::ClosedShell(v))),
            "COAXIALITY_TOLERANCE" => CoaxialityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::CoaxialityTolerance(v))),
            "COLOUR" => Colour_::parse_chunks(strs).map(|(s, v)| (s, Entity::Colour(v))),
            "COLOUR_RGB" => ColourRgb_::parse_chunks(strs).map(|(s, v)| (s, Entity::ColourRgb(v))),
            "COLOUR_SPECIFICATION" => ColourSpecification_::parse_chunks(strs).map(|(s, v)| (s, Entity::ColourSpecification(v))),
            "COMMON_DATUM" => CommonDatum_::parse_chunks(strs).map(|(s, v)| (s, Entity::CommonDatum(v))),
            "COMPARISON_EQUAL" => ComparisonEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonEqual(v))),
            "COMPARISON_EXPRESSION" => ComparisonExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonExpression(v))),
            "COMPARISON_GREATER" => ComparisonGreater_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonGreater(v))),
            "COMPARISON_GREATER_EQUAL" => ComparisonGreaterEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonGreaterEqual(v))),
            "COMPARISON_LESS" => ComparisonLess_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonLess(v))),
            "COMPARISON_LESS_EQUAL" => ComparisonLessEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonLessEqual(v))),
            "COMPARISON_NOT_EQUAL" => ComparisonNotEqual_::parse_chunks(strs).map(|(s, v)| (s, Entity::ComparisonNotEqual(v))),
            "COMPOSITE_CURVE" => CompositeCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeCurve(v))),
            "COMPOSITE_CURVE_ON_SURFACE" => CompositeCurveOnSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeCurveOnSurface(v))),
            "COMPOSITE_CURVE_SEGMENT" => CompositeCurveSegment_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeCurveSegment(v))),
            "COMPOSITE_HOLE" => CompositeHole_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeHole(v))),
            "COMPOSITE_SHAPE_ASPECT" => CompositeShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeShapeAspect(v))),
            "COMPOSITE_TEXT" => CompositeText_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeText(v))),
            "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => CompositeTextWithAssociatedCurves_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeTextWithAssociatedCurves(v))),
            "COMPOSITE_TEXT_WITH_BLANKING_BOX" => CompositeTextWithBlankingBox_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeTextWithBlankingBox(v))),
            "COMPOSITE_TEXT_WITH_EXTENT" => CompositeTextWithExtent_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompositeTextWithExtent(v))),
            "COMPOUND_FEATURE" => CompoundFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompoundFeature(v))),
            "COMPOUND_REPRESENTATION_ITEM" => CompoundRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompoundRepresentationItem(v))),
            "COMPOUND_SHAPE_REPRESENTATION" => CompoundShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::CompoundShapeRepresentation(v))),
            "CONCAT_EXPRESSION" => ConcatExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConcatExpression(v))),
            "CONCENTRICITY_TOLERANCE" => ConcentricityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConcentricityTolerance(v))),
            "CONCEPT_FEATURE_OPERATOR" => ConceptFeatureOperator_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConceptFeatureOperator(v))),
            "CONCEPT_FEATURE_RELATIONSHIP" => ConceptFeatureRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConceptFeatureRelationship(v))),
            "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => ConceptFeatureRelationshipWithCondition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConceptFeatureRelationshipWithCondition(v))),
            "CONDITIONAL_CONCEPT_FEATURE" => ConditionalConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConditionalConceptFeature(v))),
            "CONFIGURABLE_ITEM" => ConfigurableItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurableItem(v))),
            "CONFIGURATION_DEFINITION" => ConfigurationDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationDefinition(v))),
            "CONFIGURATION_DESIGN" => ConfigurationDesign_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationDesign(v))),
            "CONFIGURATION_EFFECTIVITY" => ConfigurationEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationEffectivity(v))),
            "CONFIGURATION_INTERPOLATION" => ConfigurationInterpolation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationInterpolation(v))),
            "CONFIGURATION_ITEM" => ConfigurationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfigurationItem(v))),
            "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => ConfiguredEffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfiguredEffectivityAssignment(v))),
            "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => ConfiguredEffectivityContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConfiguredEffectivityContextAssignment(v))),
            "CONIC" => Conic_::parse_chunks(strs).map(|(s, v)| (s, Entity::Conic(v))),
            "CONICAL_SURFACE" => ConicalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConicalSurface(v))),
            "CONNECTED_EDGE_SET" => ConnectedEdgeSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConnectedEdgeSet(v))),
            "CONNECTED_FACE_SET" => ConnectedFaceSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConnectedFaceSet(v))),
            "CONNECTED_FACE_SUB_SET" => ConnectedFaceSubSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConnectedFaceSubSet(v))),
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => ConstructiveGeometryRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConstructiveGeometryRepresentation(v))),
            "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => ConstructiveGeometryRepresentationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConstructiveGeometryRepresentationRelationship(v))),
            "CONTACT_RATIO_REPRESENTATION" => ContactRatioRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContactRatioRepresentation(v))),
            "CONTEXT_DEPENDENT_INVISIBILITY" => ContextDependentInvisibility_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentInvisibility(v))),
            "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => ContextDependentOverRidingStyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentOverRidingStyledItem(v))),
            "CONTEXT_DEPENDENT_SHAPE_REPRESENTATION" => ContextDependentShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentShapeRepresentation(v))),
            "CONTEXT_DEPENDENT_UNIT" => ContextDependentUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContextDependentUnit(v))),
            "CONTRACT" => Contract_::parse_chunks(strs).map(|(s, v)| (s, Entity::Contract(v))),
            "CONTRACT_ASSIGNMENT" => ContractAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContractAssignment(v))),
            "CONTRACT_TYPE" => ContractType_::parse_chunks(strs).map(|(s, v)| (s, Entity::ContractType(v))),
            "CONVERSION_BASED_UNIT" => ConversionBasedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ConversionBasedUnit(v))),
            "COORDINATED_UNIVERSAL_TIME_OFFSET" => CoordinatedUniversalTimeOffset_::parse_chunks(strs).map(|(s, v)| (s, Entity::CoordinatedUniversalTimeOffset(v))),
            "COS_FUNCTION" => CosFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::CosFunction(v))),
            "CSG_SHAPE_REPRESENTATION" => CsgShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::CsgShapeRepresentation(v))),
            "CSG_SOLID" => CsgSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::CsgSolid(v))),
            "CURVE" => Curve_::parse_chunks(strs).map(|(s, v)| (s, Entity::Curve(v))),
            "CURVE_BOUNDED_SURFACE" => CurveBoundedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveBoundedSurface(v))),
            "CURVE_DIMENSION" => CurveDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveDimension(v))),
            "CURVE_REPLICA" => CurveReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveReplica(v))),
            "CURVE_STYLE" => CurveStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyle(v))),
            "CURVE_STYLE_FONT" => CurveStyleFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyleFont(v))),
            "CURVE_STYLE_FONT_PATTERN" => CurveStyleFontPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyleFontPattern(v))),
            "CURVE_STYLE_RENDERING" => CurveStyleRendering_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveStyleRendering(v))),
            "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => CurveSweptSolidShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::CurveSweptSolidShapeRepresentation(v))),
            "CYLINDRICAL_PAIR" => CylindricalPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalPair(v))),
            "CYLINDRICAL_PAIR_RANGE" => CylindricalPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalPairRange(v))),
            "CYLINDRICAL_PAIR_VALUE" => CylindricalPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalPairValue(v))),
            "CYLINDRICAL_SURFACE" => CylindricalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricalSurface(v))),
            "CYLINDRICITY_TOLERANCE" => CylindricityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::CylindricityTolerance(v))),
            "DATA_ENVIRONMENT" => DataEnvironment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DataEnvironment(v))),
            "DATE" => Date_::parse_chunks(strs).map(|(s, v)| (s, Entity::Date(v))),
            "DATE_AND_TIME" => DateAndTime_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateAndTime(v))),
            "DATE_AND_TIME_ASSIGNMENT" => DateAndTimeAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateAndTimeAssignment(v))),
            "DATE_ASSIGNMENT" => DateAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateAssignment(v))),
            "DATE_ROLE" => DateRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateRole(v))),
            "DATE_TIME_ROLE" => DateTimeRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::DateTimeRole(v))),
            "DATED_EFFECTIVITY" => DatedEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatedEffectivity(v))),
            "DATUM" => Datum_::parse_chunks(strs).map(|(s, v)| (s, Entity::Datum(v))),
            "DATUM_FEATURE" => DatumFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumFeature(v))),
            "DATUM_FEATURE_CALLOUT" => DatumFeatureCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumFeatureCallout(v))),
            "DATUM_REFERENCE" => DatumReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumReference(v))),
            "DATUM_TARGET" => DatumTarget_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumTarget(v))),
            "DATUM_TARGET_CALLOUT" => DatumTargetCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DatumTargetCallout(v))),
            "DEFAULT_TOLERANCE_TABLE" => DefaultToleranceTable_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefaultToleranceTable(v))),
            "DEFAULT_TOLERANCE_TABLE_CELL" => DefaultToleranceTableCell_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefaultToleranceTableCell(v))),
            "DEFINED_CHARACTER_GLYPH" => DefinedCharacterGlyph_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinedCharacterGlyph(v))),
            "DEFINED_FUNCTION" => DefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinedFunction(v))),
            "DEFINED_SYMBOL" => DefinedSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinedSymbol(v))),
            "DEFINITIONAL_REPRESENTATION" => DefinitionalRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DefinitionalRepresentation(v))),
            "DEGENERATE_PCURVE" => DegeneratePcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::DegeneratePcurve(v))),
            "DEGENERATE_TOROIDAL_SURFACE" => DegenerateToroidalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::DegenerateToroidalSurface(v))),
            "DERIVED_SHAPE_ASPECT" => DerivedShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedShapeAspect(v))),
            "DERIVED_UNIT" => DerivedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedUnit(v))),
            "DERIVED_UNIT_ELEMENT" => DerivedUnitElement_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedUnitElement(v))),
            "DERIVED_UNIT_VARIABLE" => DerivedUnitVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::DerivedUnitVariable(v))),
            "DESCRIPTION_ATTRIBUTE" => DescriptionAttribute_::parse_chunks(strs).map(|(s, v)| (s, Entity::DescriptionAttribute(v))),
            "DESCRIPTIVE_REPRESENTATION_ITEM" => DescriptiveRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::DescriptiveRepresentationItem(v))),
            "DIAMETER_DIMENSION" => DiameterDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::DiameterDimension(v))),
            "DIMENSION_CALLOUT" => DimensionCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCallout(v))),
            "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => DimensionCalloutComponentRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCalloutComponentRelationship(v))),
            "DIMENSION_CALLOUT_RELATIONSHIP" => DimensionCalloutRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCalloutRelationship(v))),
            "DIMENSION_CURVE" => DimensionCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCurve(v))),
            "DIMENSION_CURVE_DIRECTED_CALLOUT" => DimensionCurveDirectedCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCurveDirectedCallout(v))),
            "DIMENSION_CURVE_TERMINATOR" => DimensionCurveTerminator_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionCurveTerminator(v))),
            "DIMENSION_PAIR" => DimensionPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionPair(v))),
            "DIMENSION_RELATED_TOLERANCE_ZONE_ELEMENT" => DimensionRelatedToleranceZoneElement_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionRelatedToleranceZoneElement(v))),
            "DIMENSION_TEXT_ASSOCIATIVITY" => DimensionTextAssociativity_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionTextAssociativity(v))),
            "DIMENSIONAL_CHARACTERISTIC_REPRESENTATION" => DimensionalCharacteristicRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalCharacteristicRepresentation(v))),
            "DIMENSIONAL_EXPONENTS" => DimensionalExponents_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalExponents(v))),
            "DIMENSIONAL_LOCATION" => DimensionalLocation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalLocation(v))),
            "DIMENSIONAL_LOCATION_WITH_PATH" => DimensionalLocationWithPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalLocationWithPath(v))),
            "DIMENSIONAL_SIZE" => DimensionalSize_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalSize(v))),
            "DIMENSIONAL_SIZE_WITH_PATH" => DimensionalSizeWithPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::DimensionalSizeWithPath(v))),
            "DIRECTED_ACTION" => DirectedAction_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectedAction(v))),
            "DIRECTED_ANGLE" => DirectedAngle_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectedAngle(v))),
            "DIRECTED_DIMENSIONAL_LOCATION" => DirectedDimensionalLocation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectedDimensionalLocation(v))),
            "DIRECTION" => Direction_::parse_chunks(strs).map(|(s, v)| (s, Entity::Direction(v))),
            "DIRECTION_SHAPE_REPRESENTATION" => DirectionShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DirectionShapeRepresentation(v))),
            "DIV_EXPRESSION" => DivExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::DivExpression(v))),
            "DOCUMENT" => Document_::parse_chunks(strs).map(|(s, v)| (s, Entity::Document(v))),
            "DOCUMENT_FILE" => DocumentFile_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentFile(v))),
            "DOCUMENT_PRODUCT_ASSOCIATION" => DocumentProductAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentProductAssociation(v))),
            "DOCUMENT_PRODUCT_EQUIVALENCE" => DocumentProductEquivalence_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentProductEquivalence(v))),
            "DOCUMENT_REFERENCE" => DocumentReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentReference(v))),
            "DOCUMENT_RELATIONSHIP" => DocumentRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentRelationship(v))),
            "DOCUMENT_REPRESENTATION_TYPE" => DocumentRepresentationType_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentRepresentationType(v))),
            "DOCUMENT_TYPE" => DocumentType_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentType(v))),
            "DOCUMENT_USAGE_CONSTRAINT" => DocumentUsageConstraint_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentUsageConstraint(v))),
            "DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => DocumentUsageConstraintAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentUsageConstraintAssignment(v))),
            "DOCUMENT_USAGE_ROLE" => DocumentUsageRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::DocumentUsageRole(v))),
            "DRAUGHTING_ANNOTATION_OCCURRENCE" => DraughtingAnnotationOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingAnnotationOccurrence(v))),
            "DRAUGHTING_CALLOUT" => DraughtingCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingCallout(v))),
            "DRAUGHTING_CALLOUT_RELATIONSHIP" => DraughtingCalloutRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingCalloutRelationship(v))),
            "DRAUGHTING_ELEMENTS" => DraughtingElements_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingElements(v))),
            "DRAUGHTING_MODEL" => DraughtingModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingModel(v))),
            "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => DraughtingModelItemAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingModelItemAssociation(v))),
            "DRAUGHTING_PRE_DEFINED_COLOUR" => DraughtingPreDefinedColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingPreDefinedColour(v))),
            "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => DraughtingPreDefinedCurveFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingPreDefinedCurveFont(v))),
            "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => DraughtingPreDefinedTextFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingPreDefinedTextFont(v))),
            "DRAUGHTING_SPECIFICATION_REFERENCE" => DraughtingSpecificationReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingSpecificationReference(v))),
            "DRAUGHTING_SUBFIGURE_REPRESENTATION" => DraughtingSubfigureRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingSubfigureRepresentation(v))),
            "DRAUGHTING_SYMBOL_REPRESENTATION" => DraughtingSymbolRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingSymbolRepresentation(v))),
            "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => DraughtingTextLiteralWithDelineation_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingTextLiteralWithDelineation(v))),
            "DRAUGHTING_TITLE" => DraughtingTitle_::parse_chunks(strs).map(|(s, v)| (s, Entity::DraughtingTitle(v))),
            "DRAWING_DEFINITION" => DrawingDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingDefinition(v))),
            "DRAWING_REVISION" => DrawingRevision_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingRevision(v))),
            "DRAWING_REVISION_SEQUENCE" => DrawingRevisionSequence_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingRevisionSequence(v))),
            "DRAWING_SHEET_LAYOUT" => DrawingSheetLayout_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingSheetLayout(v))),
            "DRAWING_SHEET_REVISION" => DrawingSheetRevision_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingSheetRevision(v))),
            "DRAWING_SHEET_REVISION_USAGE" => DrawingSheetRevisionUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::DrawingSheetRevisionUsage(v))),
            "EDGE" => Edge_::parse_chunks(strs).map(|(s, v)| (s, Entity::Edge(v))),
            "EDGE_BASED_WIREFRAME_MODEL" => EdgeBasedWireframeModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeBasedWireframeModel(v))),
            "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => EdgeBasedWireframeShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeBasedWireframeShapeRepresentation(v))),
            "EDGE_CURVE" => EdgeCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeCurve(v))),
            "EDGE_LOOP" => EdgeLoop_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeLoop(v))),
            "EDGE_ROUND" => EdgeRound_::parse_chunks(strs).map(|(s, v)| (s, Entity::EdgeRound(v))),
            "EFFECTIVITY" => Effectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::Effectivity(v))),
            "EFFECTIVITY_ASSIGNMENT" => EffectivityAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityAssignment(v))),
            "EFFECTIVITY_CONTEXT_ASSIGNMENT" => EffectivityContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityContextAssignment(v))),
            "EFFECTIVITY_CONTEXT_ROLE" => EffectivityContextRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityContextRole(v))),
            "EFFECTIVITY_RELATIONSHIP" => EffectivityRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::EffectivityRelationship(v))),
            "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => ElectricCurrentMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElectricCurrentMeasureWithUnit(v))),
            "ELECTRIC_CURRENT_UNIT" => ElectricCurrentUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElectricCurrentUnit(v))),
            "ELEMENT_DELIVERY" => ElementDelivery_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElementDelivery(v))),
            "ELEMENTARY_SURFACE" => ElementarySurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::ElementarySurface(v))),
            "ELLIPSE" => Ellipse_::parse_chunks(strs).map(|(s, v)| (s, Entity::Ellipse(v))),
            "ENVIRONMENT" => Environment_::parse_chunks(strs).map(|(s, v)| (s, Entity::Environment(v))),
            "EQUALS_EXPRESSION" => EqualsExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::EqualsExpression(v))),
            "EVALUATED_DEGENERATE_PCURVE" => EvaluatedDegeneratePcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::EvaluatedDegeneratePcurve(v))),
            "EVENT_OCCURRENCE" => EventOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrence(v))),
            "EVENT_OCCURRENCE_ASSIGNMENT" => EventOccurrenceAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceAssignment(v))),
            "EVENT_OCCURRENCE_CONTEXT_ASSIGNMENT" => EventOccurrenceContextAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceContextAssignment(v))),
            "EVENT_OCCURRENCE_CONTEXT_ROLE" => EventOccurrenceContextRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceContextRole(v))),
            "EVENT_OCCURRENCE_ROLE" => EventOccurrenceRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::EventOccurrenceRole(v))),
            "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => ExclusiveProductConceptFeatureCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExclusiveProductConceptFeatureCategory(v))),
            "EXECUTED_ACTION" => ExecutedAction_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExecutedAction(v))),
            "EXP_FUNCTION" => ExpFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExpFunction(v))),
            "EXPRESSION" => Expression_::parse_chunks(strs).map(|(s, v)| (s, Entity::Expression(v))),
            "EXPRESSION_CONVERSION_BASED_UNIT" => ExpressionConversionBasedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExpressionConversionBasedUnit(v))),
            "EXTENSION" => Extension_::parse_chunks(strs).map(|(s, v)| (s, Entity::Extension(v))),
            "EXTERNAL_IDENTIFICATION_ASSIGNMENT" => ExternalIdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternalIdentificationAssignment(v))),
            "EXTERNAL_SOURCE" => ExternalSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternalSource(v))),
            "EXTERNALLY_DEFINED_CHARACTER_GLYPH" => ExternallyDefinedCharacterGlyph_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedCharacterGlyph(v))),
            "EXTERNALLY_DEFINED_CLASS" => ExternallyDefinedClass_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedClass(v))),
            "EXTERNALLY_DEFINED_CURVE_FONT" => ExternallyDefinedCurveFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedCurveFont(v))),
            "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => ExternallyDefinedDimensionDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedDimensionDefinition(v))),
            "EXTERNALLY_DEFINED_FEATURE_DEFINITION" => ExternallyDefinedFeatureDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedFeatureDefinition(v))),
            "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => ExternallyDefinedGeneralProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedGeneralProperty(v))),
            "EXTERNALLY_DEFINED_HATCH_STYLE" => ExternallyDefinedHatchStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedHatchStyle(v))),
            "EXTERNALLY_DEFINED_ITEM" => ExternallyDefinedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedItem(v))),
            "EXTERNALLY_DEFINED_ITEM_RELATIONSHIP" => ExternallyDefinedItemRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedItemRelationship(v))),
            "EXTERNALLY_DEFINED_STYLE" => ExternallyDefinedStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedStyle(v))),
            "EXTERNALLY_DEFINED_SYMBOL" => ExternallyDefinedSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedSymbol(v))),
            "EXTERNALLY_DEFINED_TEXT_FONT" => ExternallyDefinedTextFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedTextFont(v))),
            "EXTERNALLY_DEFINED_TILE_STYLE" => ExternallyDefinedTileStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExternallyDefinedTileStyle(v))),
            "EXTRUDED_AREA_SOLID" => ExtrudedAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExtrudedAreaSolid(v))),
            "EXTRUDED_FACE_SOLID" => ExtrudedFaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::ExtrudedFaceSolid(v))),
            "FACE" => Face_::parse_chunks(strs).map(|(s, v)| (s, Entity::Face(v))),
            "FACE_BASED_SURFACE_MODEL" => FaceBasedSurfaceModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceBasedSurfaceModel(v))),
            "FACE_BOUND" => FaceBound_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceBound(v))),
            "FACE_OUTER_BOUND" => FaceOuterBound_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceOuterBound(v))),
            "FACE_SHAPE_REPRESENTATION" => FaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceShapeRepresentation(v))),
            "FACE_SURFACE" => FaceSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::FaceSurface(v))),
            "FACETED_BREP" => FacetedBrep_::parse_chunks(strs).map(|(s, v)| (s, Entity::FacetedBrep(v))),
            "FACETED_BREP_SHAPE_REPRESENTATION" => FacetedBrepShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::FacetedBrepShapeRepresentation(v))),
            "FEATURE_COMPONENT_DEFINITION" => FeatureComponentDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureComponentDefinition(v))),
            "FEATURE_COMPONENT_RELATIONSHIP" => FeatureComponentRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureComponentRelationship(v))),
            "FEATURE_DEFINITION" => FeatureDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureDefinition(v))),
            "FEATURE_IN_PANEL" => FeatureInPanel_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeatureInPanel(v))),
            "FEATURE_PATTERN" => FeaturePattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeaturePattern(v))),
            "FEATURED_SHAPE" => FeaturedShape_::parse_chunks(strs).map(|(s, v)| (s, Entity::FeaturedShape(v))),
            "FILL_AREA_STYLE" => FillAreaStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyle(v))),
            "FILL_AREA_STYLE_COLOUR" => FillAreaStyleColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleColour(v))),
            "FILL_AREA_STYLE_HATCHING" => FillAreaStyleHatching_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleHatching(v))),
            "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => FillAreaStyleTileSymbolWithStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleTileSymbolWithStyle(v))),
            "FILL_AREA_STYLE_TILES" => FillAreaStyleTiles_::parse_chunks(strs).map(|(s, v)| (s, Entity::FillAreaStyleTiles(v))),
            "FILLET" => Fillet_::parse_chunks(strs).map(|(s, v)| (s, Entity::Fillet(v))),
            "FLATNESS_TOLERANCE" => FlatnessTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::FlatnessTolerance(v))),
            "FORMAT_FUNCTION" => FormatFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::FormatFunction(v))),
            "FOUNDED_ITEM" => FoundedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::FoundedItem(v))),
            "FOUNDED_KINEMATIC_PATH" => FoundedKinematicPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::FoundedKinematicPath(v))),
            "FULLY_CONSTRAINED_PAIR" => FullyConstrainedPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::FullyConstrainedPair(v))),
            "FUNCTIONALLY_DEFINED_TRANSFORMATION" => FunctionallyDefinedTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::FunctionallyDefinedTransformation(v))),
            "GEAR_PAIR" => GearPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::GearPair(v))),
            "GEAR_PAIR_RANGE" => GearPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::GearPairRange(v))),
            "GEAR_PAIR_VALUE" => GearPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::GearPairValue(v))),
            "GENERAL_FEATURE" => GeneralFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralFeature(v))),
            "GENERAL_MATERIAL_PROPERTY" => GeneralMaterialProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralMaterialProperty(v))),
            "GENERAL_PROPERTY" => GeneralProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralProperty(v))),
            "GENERAL_PROPERTY_ASSOCIATION" => GeneralPropertyAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralPropertyAssociation(v))),
            "GENERAL_PROPERTY_RELATIONSHIP" => GeneralPropertyRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeneralPropertyRelationship(v))),
            "GENERIC_CHARACTER_GLYPH_SYMBOL" => GenericCharacterGlyphSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericCharacterGlyphSymbol(v))),
            "GENERIC_EXPRESSION" => GenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericExpression(v))),
            "GENERIC_LITERAL" => GenericLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericLiteral(v))),
            "GENERIC_VARIABLE" => GenericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::GenericVariable(v))),
            "GEOMETRIC_ALIGNMENT" => GeometricAlignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricAlignment(v))),
            "GEOMETRIC_CURVE_SET" => GeometricCurveSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricCurveSet(v))),
            "GEOMETRIC_INTERSECTION" => GeometricIntersection_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricIntersection(v))),
            "GEOMETRIC_ITEM_SPECIFIC_USAGE" => GeometricItemSpecificUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricItemSpecificUsage(v))),
            "GEOMETRIC_REPRESENTATION_CONTEXT" => GeometricRepresentationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricRepresentationContext(v))),
            "GEOMETRIC_REPRESENTATION_ITEM" => GeometricRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricRepresentationItem(v))),
            "GEOMETRIC_SET" => GeometricSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricSet(v))),
            "GEOMETRIC_TOLERANCE" => GeometricTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricTolerance(v))),
            "GEOMETRIC_TOLERANCE_RELATIONSHIP" => GeometricToleranceRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricToleranceRelationship(v))),
            "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => GeometricToleranceWithDatumReference_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricToleranceWithDatumReference(v))),
            "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => GeometricToleranceWithDefinedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricToleranceWithDefinedUnit(v))),
            "GEOMETRICAL_TOLERANCE_CALLOUT" => GeometricalToleranceCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricalToleranceCallout(v))),
            "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => GeometricallyBounded2dWireframeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricallyBounded2dWireframeRepresentation(v))),
            "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => GeometricallyBoundedSurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricallyBoundedSurfaceShapeRepresentation(v))),
            "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => GeometricallyBoundedWireframeShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::GeometricallyBoundedWireframeShapeRepresentation(v))),
            "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => GlobalUncertaintyAssignedContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::GlobalUncertaintyAssignedContext(v))),
            "GLOBAL_UNIT_ASSIGNED_CONTEXT" => GlobalUnitAssignedContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::GlobalUnitAssignedContext(v))),
            "GROUP" => Group_::parse_chunks(strs).map(|(s, v)| (s, Entity::Group(v))),
            "GROUP_ASSIGNMENT" => GroupAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::GroupAssignment(v))),
            "GROUP_RELATIONSHIP" => GroupRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::GroupRelationship(v))),
            "HALF_SPACE_SOLID" => HalfSpaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::HalfSpaceSolid(v))),
            "HARDNESS_REPRESENTATION" => HardnessRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::HardnessRepresentation(v))),
            "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => HiddenElementOverRidingStyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::HiddenElementOverRidingStyledItem(v))),
            "HOLE_BOTTOM" => HoleBottom_::parse_chunks(strs).map(|(s, v)| (s, Entity::HoleBottom(v))),
            "HOLE_IN_PANEL" => HoleInPanel_::parse_chunks(strs).map(|(s, v)| (s, Entity::HoleInPanel(v))),
            "HOMOKINETIC_PAIR" => HomokineticPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::HomokineticPair(v))),
            "HYPERBOLA" => Hyperbola_::parse_chunks(strs).map(|(s, v)| (s, Entity::Hyperbola(v))),
            "ID_ATTRIBUTE" => IdAttribute_::parse_chunks(strs).map(|(s, v)| (s, Entity::IdAttribute(v))),
            "IDENTIFICATION_ASSIGNMENT" => IdentificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::IdentificationAssignment(v))),
            "IDENTIFICATION_ROLE" => IdentificationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::IdentificationRole(v))),
            "INCLUSION_PRODUCT_CONCEPT_FEATURE" => InclusionProductConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::InclusionProductConceptFeature(v))),
            "INDEX_EXPRESSION" => IndexExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::IndexExpression(v))),
            "INITIAL_STATE" => InitialState_::parse_chunks(strs).map(|(s, v)| (s, Entity::InitialState(v))),
            "INSTANCED_FEATURE" => InstancedFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::InstancedFeature(v))),
            "INT_LITERAL" => IntLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntLiteral(v))),
            "INT_NUMERIC_VARIABLE" => IntNumericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntNumericVariable(v))),
            "INT_VALUE_FUNCTION" => IntValueFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntValueFunction(v))),
            "INTEGER_DEFINED_FUNCTION" => IntegerDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntegerDefinedFunction(v))),
            "INTERPOLATED_CONFIGURATION_SEQUENCE" => InterpolatedConfigurationSequence_::parse_chunks(strs).map(|(s, v)| (s, Entity::InterpolatedConfigurationSequence(v))),
            "INTERSECTION_CURVE" => IntersectionCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntersectionCurve(v))),
            "INTERVAL_EXPRESSION" => IntervalExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::IntervalExpression(v))),
            "INVISIBILITY" => Invisibility_::parse_chunks(strs).map(|(s, v)| (s, Entity::Invisibility(v))),
            "ITEM_DEFINED_TRANSFORMATION" => ItemDefinedTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ItemDefinedTransformation(v))),
            "ITEM_IDENTIFIED_REPRESENTATION_USAGE" => ItemIdentifiedRepresentationUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::ItemIdentifiedRepresentationUsage(v))),
            "JOGGLE" => Joggle_::parse_chunks(strs).map(|(s, v)| (s, Entity::Joggle(v))),
            "JOGGLE_TERMINATION" => JoggleTermination_::parse_chunks(strs).map(|(s, v)| (s, Entity::JoggleTermination(v))),
            "KINEMATIC_ANALYSIS_CONSISTENCY" => KinematicAnalysisConsistency_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicAnalysisConsistency(v))),
            "KINEMATIC_ANALYSIS_RESULT" => KinematicAnalysisResult_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicAnalysisResult(v))),
            "KINEMATIC_CONTROL" => KinematicControl_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicControl(v))),
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION" => KinematicFrameBackgroundRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicFrameBackgroundRepresentation(v))),
            "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION" => KinematicFrameBackgroundRepresentationAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicFrameBackgroundRepresentationAssociation(v))),
            "KINEMATIC_FRAME_BASED_TRANSFORMATION" => KinematicFrameBasedTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicFrameBasedTransformation(v))),
            "KINEMATIC_GROUND_REPRESENTATION" => KinematicGroundRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicGroundRepresentation(v))),
            "KINEMATIC_JOINT" => KinematicJoint_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicJoint(v))),
            "KINEMATIC_LINK" => KinematicLink_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLink(v))),
            "KINEMATIC_LINK_REPRESENTATION" => KinematicLinkRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLinkRepresentation(v))),
            "KINEMATIC_LINK_REPRESENTATION_ASSOCIATION" => KinematicLinkRepresentationAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLinkRepresentationAssociation(v))),
            "KINEMATIC_LINK_REPRESENTATION_RELATION" => KinematicLinkRepresentationRelation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicLinkRepresentationRelation(v))),
            "KINEMATIC_PAIR" => KinematicPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPair(v))),
            "KINEMATIC_PATH" => KinematicPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPath(v))),
            "KINEMATIC_PROPERTY_DEFINITION" => KinematicPropertyDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPropertyDefinition(v))),
            "KINEMATIC_PROPERTY_REPRESENTATION_RELATION" => KinematicPropertyRepresentationRelation_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicPropertyRepresentationRelation(v))),
            "KINEMATIC_STRUCTURE" => KinematicStructure_::parse_chunks(strs).map(|(s, v)| (s, Entity::KinematicStructure(v))),
            "KNOWN_SOURCE" => KnownSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::KnownSource(v))),
            "LANGUAGE" => Language_::parse_chunks(strs).map(|(s, v)| (s, Entity::Language(v))),
            "LANGUAGE_ASSIGNMENT" => LanguageAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::LanguageAssignment(v))),
            "LEADER_CURVE" => LeaderCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderCurve(v))),
            "LEADER_DIRECTED_CALLOUT" => LeaderDirectedCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderDirectedCallout(v))),
            "LEADER_DIRECTED_DIMENSION" => LeaderDirectedDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderDirectedDimension(v))),
            "LEADER_TERMINATOR" => LeaderTerminator_::parse_chunks(strs).map(|(s, v)| (s, Entity::LeaderTerminator(v))),
            "LENGTH_FUNCTION" => LengthFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::LengthFunction(v))),
            "LENGTH_MEASURE_WITH_UNIT" => LengthMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LengthMeasureWithUnit(v))),
            "LENGTH_UNIT" => LengthUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LengthUnit(v))),
            "LIGHT_SOURCE" => LightSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSource(v))),
            "LIGHT_SOURCE_AMBIENT" => LightSourceAmbient_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourceAmbient(v))),
            "LIGHT_SOURCE_DIRECTIONAL" => LightSourceDirectional_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourceDirectional(v))),
            "LIGHT_SOURCE_POSITIONAL" => LightSourcePositional_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourcePositional(v))),
            "LIGHT_SOURCE_SPOT" => LightSourceSpot_::parse_chunks(strs).map(|(s, v)| (s, Entity::LightSourceSpot(v))),
            "LIKE_EXPRESSION" => LikeExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::LikeExpression(v))),
            "LIMITS_AND_FITS" => LimitsAndFits_::parse_chunks(strs).map(|(s, v)| (s, Entity::LimitsAndFits(v))),
            "LINE" => Line_::parse_chunks(strs).map(|(s, v)| (s, Entity::Line(v))),
            "LINE_PROFILE_TOLERANCE" => LineProfileTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::LineProfileTolerance(v))),
            "LINEAR_DIMENSION" => LinearDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::LinearDimension(v))),
            "LITERAL_NUMBER" => LiteralNumber_::parse_chunks(strs).map(|(s, v)| (s, Entity::LiteralNumber(v))),
            "LOCAL_TIME" => LocalTime_::parse_chunks(strs).map(|(s, v)| (s, Entity::LocalTime(v))),
            "LOCATION_SHAPE_REPRESENTATION" => LocationShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::LocationShapeRepresentation(v))),
            "LOCATOR" => Locator_::parse_chunks(strs).map(|(s, v)| (s, Entity::Locator(v))),
            "LOG10_FUNCTION" => Log10Function_::parse_chunks(strs).map(|(s, v)| (s, Entity::Log10Function(v))),
            "LOG2_FUNCTION" => Log2Function_::parse_chunks(strs).map(|(s, v)| (s, Entity::Log2Function(v))),
            "LOG_FUNCTION" => LogFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::LogFunction(v))),
            "LOOP" => Loop_::parse_chunks(strs).map(|(s, v)| (s, Entity::Loop(v))),
            "LOT_EFFECTIVITY" => LotEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::LotEffectivity(v))),
            "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => LuminousIntensityMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LuminousIntensityMeasureWithUnit(v))),
            "LUMINOUS_INTENSITY_UNIT" => LuminousIntensityUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::LuminousIntensityUnit(v))),
            "MAKE_FROM_USAGE_OPTION" => MakeFromUsageOption_::parse_chunks(strs).map(|(s, v)| (s, Entity::MakeFromUsageOption(v))),
            "MANIFOLD_SOLID_BREP" => ManifoldSolidBrep_::parse_chunks(strs).map(|(s, v)| (s, Entity::ManifoldSolidBrep(v))),
            "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => ManifoldSubsurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ManifoldSubsurfaceShapeRepresentation(v))),
            "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => ManifoldSurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ManifoldSurfaceShapeRepresentation(v))),
            "MAPPED_ITEM" => MappedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::MappedItem(v))),
            "MASS_MEASURE_WITH_UNIT" => MassMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::MassMeasureWithUnit(v))),
            "MASS_UNIT" => MassUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::MassUnit(v))),
            "MATERIAL_DESIGNATION" => MaterialDesignation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialDesignation(v))),
            "MATERIAL_DESIGNATION_CHARACTERIZATION" => MaterialDesignationCharacterization_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialDesignationCharacterization(v))),
            "MATERIAL_PROPERTY" => MaterialProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialProperty(v))),
            "MATERIAL_PROPERTY_REPRESENTATION" => MaterialPropertyRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaterialPropertyRepresentation(v))),
            "MAXIMUM_FUNCTION" => MaximumFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::MaximumFunction(v))),
            "MEASURE_QUALIFICATION" => MeasureQualification_::parse_chunks(strs).map(|(s, v)| (s, Entity::MeasureQualification(v))),
            "MEASURE_REPRESENTATION_ITEM" => MeasureRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::MeasureRepresentationItem(v))),
            "MEASURE_WITH_UNIT" => MeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::MeasureWithUnit(v))),
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => MechanicalDesignGeometricPresentationArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::MechanicalDesignGeometricPresentationArea(v))),
            "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => MechanicalDesignGeometricPresentationRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MechanicalDesignGeometricPresentationRepresentation(v))),
            "MECHANISM" => Mechanism_::parse_chunks(strs).map(|(s, v)| (s, Entity::Mechanism(v))),
            "MECHANISM_BASE_PLACEMENT" => MechanismBasePlacement_::parse_chunks(strs).map(|(s, v)| (s, Entity::MechanismBasePlacement(v))),
            "MINIMUM_FUNCTION" => MinimumFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::MinimumFunction(v))),
            "MINUS_EXPRESSION" => MinusExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MinusExpression(v))),
            "MINUS_FUNCTION" => MinusFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::MinusFunction(v))),
            "MOD_EXPRESSION" => ModExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::ModExpression(v))),
            "MODIFIED_GEOMETRIC_TOLERANCE" => ModifiedGeometricTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ModifiedGeometricTolerance(v))),
            "MODIFIED_PATTERN" => ModifiedPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::ModifiedPattern(v))),
            "MOMENTS_OF_INERTIA_REPRESENTATION" => MomentsOfInertiaRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::MomentsOfInertiaRepresentation(v))),
            "MOTION_LINK_RELATIONSHIP" => MotionLinkRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::MotionLinkRelationship(v))),
            "MULT_EXPRESSION" => MultExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultExpression(v))),
            "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => MultiLanguageAttributeAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultiLanguageAttributeAssignment(v))),
            "MULTIPLE_ARITY_BOOLEAN_EXPRESSION" => MultipleArityBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityBooleanExpression(v))),
            "MULTIPLE_ARITY_FUNCTION_CALL" => MultipleArityFunctionCall_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityFunctionCall(v))),
            "MULTIPLE_ARITY_GENERIC_EXPRESSION" => MultipleArityGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityGenericExpression(v))),
            "MULTIPLE_ARITY_NUMERIC_EXPRESSION" => MultipleArityNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::MultipleArityNumericExpression(v))),
            "NAME_ASSIGNMENT" => NameAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::NameAssignment(v))),
            "NAME_ATTRIBUTE" => NameAttribute_::parse_chunks(strs).map(|(s, v)| (s, Entity::NameAttribute(v))),
            "NAMED_UNIT" => NamedUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::NamedUnit(v))),
            "NAMED_UNIT_VARIABLE" => NamedUnitVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::NamedUnitVariable(v))),
            "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => NextAssemblyUsageOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::NextAssemblyUsageOccurrence(v))),
            "NGON_CLOSED_PROFILE" => NgonClosedProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::NgonClosedProfile(v))),
            "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => NonManifoldSurfaceShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::NonManifoldSurfaceShapeRepresentation(v))),
            "NOT_EXPRESSION" => NotExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::NotExpression(v))),
            "NUMERIC_DEFINED_FUNCTION" => NumericDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::NumericDefinedFunction(v))),
            "NUMERIC_EXPRESSION" => NumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::NumericExpression(v))),
            "NUMERIC_VARIABLE" => NumericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::NumericVariable(v))),
            "OBJECT_ROLE" => ObjectRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ObjectRole(v))),
            "ODD_FUNCTION" => OddFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::OddFunction(v))),
            "OFFSET_CURVE_2D" => OffsetCurve2d_::parse_chunks(strs).map(|(s, v)| (s, Entity::OffsetCurve2d(v))),
            "OFFSET_CURVE_3D" => OffsetCurve3d_::parse_chunks(strs).map(|(s, v)| (s, Entity::OffsetCurve3d(v))),
            "OFFSET_SURFACE" => OffsetSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::OffsetSurface(v))),
            "ONE_DIRECTION_REPEAT_FACTOR" => OneDirectionRepeatFactor_::parse_chunks(strs).map(|(s, v)| (s, Entity::OneDirectionRepeatFactor(v))),
            "OPEN_PATH_PROFILE" => OpenPathProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::OpenPathProfile(v))),
            "OPEN_SHELL" => OpenShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::OpenShell(v))),
            "OR_EXPRESSION" => OrExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrExpression(v))),
            "ORDINATE_DIMENSION" => OrdinateDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrdinateDimension(v))),
            "ORGANIZATION" => Organization_::parse_chunks(strs).map(|(s, v)| (s, Entity::Organization(v))),
            "ORGANIZATION_ASSIGNMENT" => OrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationAssignment(v))),
            "ORGANIZATION_RELATIONSHIP" => OrganizationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationRelationship(v))),
            "ORGANIZATION_ROLE" => OrganizationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationRole(v))),
            "ORGANIZATIONAL_ADDRESS" => OrganizationalAddress_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalAddress(v))),
            "ORGANIZATIONAL_PROJECT" => OrganizationalProject_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProject(v))),
            "ORGANIZATIONAL_PROJECT_ASSIGNMENT" => OrganizationalProjectAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProjectAssignment(v))),
            "ORGANIZATIONAL_PROJECT_RELATIONSHIP" => OrganizationalProjectRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProjectRelationship(v))),
            "ORGANIZATIONAL_PROJECT_ROLE" => OrganizationalProjectRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrganizationalProjectRole(v))),
            "ORIENTED_CLOSED_SHELL" => OrientedClosedShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedClosedShell(v))),
            "ORIENTED_EDGE" => OrientedEdge_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedEdge(v))),
            "ORIENTED_FACE" => OrientedFace_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedFace(v))),
            "ORIENTED_OPEN_SHELL" => OrientedOpenShell_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedOpenShell(v))),
            "ORIENTED_PATH" => OrientedPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedPath(v))),
            "ORIENTED_SURFACE" => OrientedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::OrientedSurface(v))),
            "OUTER_BOUNDARY_CURVE" => OuterBoundaryCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::OuterBoundaryCurve(v))),
            "OVER_RIDING_STYLED_ITEM" => OverRidingStyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::OverRidingStyledItem(v))),
            "PACKAGE_PRODUCT_CONCEPT_FEATURE" => PackageProductConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::PackageProductConceptFeature(v))),
            "PAIR_ACTUATOR" => PairActuator_::parse_chunks(strs).map(|(s, v)| (s, Entity::PairActuator(v))),
            "PAIR_VALUE" => PairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PairValue(v))),
            "PARABOLA" => Parabola_::parse_chunks(strs).map(|(s, v)| (s, Entity::Parabola(v))),
            "PARALLEL_OFFSET" => ParallelOffset_::parse_chunks(strs).map(|(s, v)| (s, Entity::ParallelOffset(v))),
            "PARALLELISM_TOLERANCE" => ParallelismTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::ParallelismTolerance(v))),
            "PARAMETRIC_REPRESENTATION_CONTEXT" => ParametricRepresentationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ParametricRepresentationContext(v))),
            "PARTIAL_CIRCULAR_PROFILE" => PartialCircularProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::PartialCircularProfile(v))),
            "PATH" => Path_::parse_chunks(strs).map(|(s, v)| (s, Entity::Path(v))),
            "PATH_FEATURE_COMPONENT" => PathFeatureComponent_::parse_chunks(strs).map(|(s, v)| (s, Entity::PathFeatureComponent(v))),
            "PATH_SHAPE_REPRESENTATION" => PathShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PathShapeRepresentation(v))),
            "PATTERN_OFFSET_MEMBERSHIP" => PatternOffsetMembership_::parse_chunks(strs).map(|(s, v)| (s, Entity::PatternOffsetMembership(v))),
            "PATTERN_OMIT_MEMBERSHIP" => PatternOmitMembership_::parse_chunks(strs).map(|(s, v)| (s, Entity::PatternOmitMembership(v))),
            "PCURVE" => Pcurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::Pcurve(v))),
            "PERPENDICULAR_TO" => PerpendicularTo_::parse_chunks(strs).map(|(s, v)| (s, Entity::PerpendicularTo(v))),
            "PERPENDICULARITY_TOLERANCE" => PerpendicularityTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::PerpendicularityTolerance(v))),
            "PERSON" => Person_::parse_chunks(strs).map(|(s, v)| (s, Entity::Person(v))),
            "PERSON_AND_ORGANIZATION" => PersonAndOrganization_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganization(v))),
            "PERSON_AND_ORGANIZATION_ADDRESS" => PersonAndOrganizationAddress_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganizationAddress(v))),
            "PERSON_AND_ORGANIZATION_ASSIGNMENT" => PersonAndOrganizationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganizationAssignment(v))),
            "PERSON_AND_ORGANIZATION_ROLE" => PersonAndOrganizationRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonAndOrganizationRole(v))),
            "PERSONAL_ADDRESS" => PersonalAddress_::parse_chunks(strs).map(|(s, v)| (s, Entity::PersonalAddress(v))),
            "PHYSICALLY_MODELLED_PRODUCT_DEFINITION" => PhysicallyModelledProductDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::PhysicallyModelledProductDefinition(v))),
            "PLACED_DATUM_TARGET_FEATURE" => PlacedDatumTargetFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlacedDatumTargetFeature(v))),
            "PLACED_FEATURE" => PlacedFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlacedFeature(v))),
            "PLACEMENT" => Placement_::parse_chunks(strs).map(|(s, v)| (s, Entity::Placement(v))),
            "PLANAR_BOX" => PlanarBox_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarBox(v))),
            "PLANAR_CURVE_PAIR" => PlanarCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarCurvePair(v))),
            "PLANAR_CURVE_PAIR_RANGE" => PlanarCurvePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarCurvePairRange(v))),
            "PLANAR_EXTENT" => PlanarExtent_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarExtent(v))),
            "PLANAR_PAIR" => PlanarPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarPair(v))),
            "PLANAR_PAIR_RANGE" => PlanarPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarPairRange(v))),
            "PLANAR_PAIR_VALUE" => PlanarPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarPairValue(v))),
            "PLANAR_SHAPE_REPRESENTATION" => PlanarShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlanarShapeRepresentation(v))),
            "PLANE" => Plane_::parse_chunks(strs).map(|(s, v)| (s, Entity::Plane(v))),
            "PLANE_ANGLE_MEASURE_WITH_UNIT" => PlaneAngleMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlaneAngleMeasureWithUnit(v))),
            "PLANE_ANGLE_UNIT" => PlaneAngleUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlaneAngleUnit(v))),
            "PLUS_EXPRESSION" => PlusExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlusExpression(v))),
            "PLUS_MINUS_TOLERANCE" => PlusMinusTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::PlusMinusTolerance(v))),
            "POCKET" => Pocket_::parse_chunks(strs).map(|(s, v)| (s, Entity::Pocket(v))),
            "POCKET_BOTTOM" => PocketBottom_::parse_chunks(strs).map(|(s, v)| (s, Entity::PocketBottom(v))),
            "POINT" => Point_::parse_chunks(strs).map(|(s, v)| (s, Entity::Point(v))),
            "POINT_ON_CURVE" => PointOnCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnCurve(v))),
            "POINT_ON_PLANAR_CURVE_PAIR" => PointOnPlanarCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnPlanarCurvePair(v))),
            "POINT_ON_PLANAR_CURVE_PAIR_RANGE" => PointOnPlanarCurvePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnPlanarCurvePairRange(v))),
            "POINT_ON_PLANAR_CURVE_PAIR_VALUE" => PointOnPlanarCurvePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnPlanarCurvePairValue(v))),
            "POINT_ON_SURFACE" => PointOnSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurface(v))),
            "POINT_ON_SURFACE_PAIR" => PointOnSurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurfacePair(v))),
            "POINT_ON_SURFACE_PAIR_RANGE" => PointOnSurfacePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurfacePairRange(v))),
            "POINT_ON_SURFACE_PAIR_VALUE" => PointOnSurfacePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointOnSurfacePairValue(v))),
            "POINT_PLACEMENT_SHAPE_REPRESENTATION" => PointPlacementShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointPlacementShapeRepresentation(v))),
            "POINT_REPLICA" => PointReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointReplica(v))),
            "POINT_STYLE" => PointStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::PointStyle(v))),
            "POLY_LOOP" => PolyLoop_::parse_chunks(strs).map(|(s, v)| (s, Entity::PolyLoop(v))),
            "POLYLINE" => Polyline_::parse_chunks(strs).map(|(s, v)| (s, Entity::Polyline(v))),
            "POSITION_TOLERANCE" => PositionTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::PositionTolerance(v))),
            "POWER_EXPRESSION" => PowerExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::PowerExpression(v))),
            "PRE_DEFINED_COLOUR" => PreDefinedColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedColour(v))),
            "PRE_DEFINED_CURVE_FONT" => PreDefinedCurveFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedCurveFont(v))),
            "PRE_DEFINED_DIMENSION_SYMBOL" => PreDefinedDimensionSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedDimensionSymbol(v))),
            "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => PreDefinedGeometricalToleranceSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedGeometricalToleranceSymbol(v))),
            "PRE_DEFINED_ITEM" => PreDefinedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedItem(v))),
            "PRE_DEFINED_MARKER" => PreDefinedMarker_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedMarker(v))),
            "PRE_DEFINED_POINT_MARKER_SYMBOL" => PreDefinedPointMarkerSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedPointMarkerSymbol(v))),
            "PRE_DEFINED_PRESENTATION_STYLE" => PreDefinedPresentationStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedPresentationStyle(v))),
            "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => PreDefinedSurfaceConditionSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedSurfaceConditionSymbol(v))),
            "PRE_DEFINED_SYMBOL" => PreDefinedSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedSymbol(v))),
            "PRE_DEFINED_TERMINATOR_SYMBOL" => PreDefinedTerminatorSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedTerminatorSymbol(v))),
            "PRE_DEFINED_TEXT_FONT" => PreDefinedTextFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::PreDefinedTextFont(v))),
            "PRECISION_QUALIFIER" => PrecisionQualifier_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrecisionQualifier(v))),
            "PRESENTATION_AREA" => PresentationArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationArea(v))),
            "PRESENTATION_LAYER_ASSIGNMENT" => PresentationLayerAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationLayerAssignment(v))),
            "PRESENTATION_REPRESENTATION" => PresentationRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationRepresentation(v))),
            "PRESENTATION_SET" => PresentationSet_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationSet(v))),
            "PRESENTATION_SIZE" => PresentationSize_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationSize(v))),
            "PRESENTATION_STYLE_ASSIGNMENT" => PresentationStyleAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationStyleAssignment(v))),
            "PRESENTATION_STYLE_BY_CONTEXT" => PresentationStyleByContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationStyleByContext(v))),
            "PRESENTATION_VIEW" => PresentationView_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentationView(v))),
            "PRESENTED_ITEM" => PresentedItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentedItem(v))),
            "PRESENTED_ITEM_REPRESENTATION" => PresentedItemRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PresentedItemRepresentation(v))),
            "PRISMATIC_PAIR" => PrismaticPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrismaticPair(v))),
            "PRISMATIC_PAIR_RANGE" => PrismaticPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrismaticPairRange(v))),
            "PRISMATIC_PAIR_VALUE" => PrismaticPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::PrismaticPairValue(v))),
            "PROCESS_OPERATION" => ProcessOperation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessOperation(v))),
            "PROCESS_PLAN" => ProcessPlan_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessPlan(v))),
            "PROCESS_PRODUCT_ASSOCIATION" => ProcessProductAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessProductAssociation(v))),
            "PROCESS_PROPERTY_ASSOCIATION" => ProcessPropertyAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProcessPropertyAssociation(v))),
            "PRODUCT" => Product_::parse_chunks(strs).map(|(s, v)| (s, Entity::Product(v))),
            "PRODUCT_CATEGORY" => ProductCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductCategory(v))),
            "PRODUCT_CATEGORY_RELATIONSHIP" => ProductCategoryRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductCategoryRelationship(v))),
            "PRODUCT_CLASS" => ProductClass_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductClass(v))),
            "PRODUCT_CONCEPT" => ProductConcept_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConcept(v))),
            "PRODUCT_CONCEPT_CONTEXT" => ProductConceptContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptContext(v))),
            "PRODUCT_CONCEPT_FEATURE" => ProductConceptFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeature(v))),
            "PRODUCT_CONCEPT_FEATURE_ASSOCIATION" => ProductConceptFeatureAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeatureAssociation(v))),
            "PRODUCT_CONCEPT_FEATURE_CATEGORY" => ProductConceptFeatureCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeatureCategory(v))),
            "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => ProductConceptFeatureCategoryUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptFeatureCategoryUsage(v))),
            "PRODUCT_CONCEPT_RELATIONSHIP" => ProductConceptRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductConceptRelationship(v))),
            "PRODUCT_CONTEXT" => ProductContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductContext(v))),
            "PRODUCT_DEFINITION" => ProductDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinition(v))),
            "PRODUCT_DEFINITION_CONTEXT" => ProductDefinitionContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionContext(v))),
            "PRODUCT_DEFINITION_CONTEXT_ASSOCIATION" => ProductDefinitionContextAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionContextAssociation(v))),
            "PRODUCT_DEFINITION_CONTEXT_ROLE" => ProductDefinitionContextRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionContextRole(v))),
            "PRODUCT_DEFINITION_EFFECTIVITY" => ProductDefinitionEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionEffectivity(v))),
            "PRODUCT_DEFINITION_FORMATION" => ProductDefinitionFormation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionFormation(v))),
            "PRODUCT_DEFINITION_FORMATION_RELATIONSHIP" => ProductDefinitionFormationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionFormationRelationship(v))),
            "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => ProductDefinitionFormationWithSpecifiedSource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionFormationWithSpecifiedSource(v))),
            "PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP" => ProductDefinitionOccurrenceRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionOccurrenceRelationship(v))),
            "PRODUCT_DEFINITION_PROCESS" => ProductDefinitionProcess_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionProcess(v))),
            "PRODUCT_DEFINITION_RELATIONSHIP" => ProductDefinitionRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionRelationship(v))),
            "PRODUCT_DEFINITION_RESOURCE" => ProductDefinitionResource_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionResource(v))),
            "PRODUCT_DEFINITION_SHAPE" => ProductDefinitionShape_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionShape(v))),
            "PRODUCT_DEFINITION_SUBSTITUTE" => ProductDefinitionSubstitute_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionSubstitute(v))),
            "PRODUCT_DEFINITION_USAGE" => ProductDefinitionUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionUsage(v))),
            "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => ProductDefinitionWithAssociatedDocuments_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductDefinitionWithAssociatedDocuments(v))),
            "PRODUCT_IDENTIFICATION" => ProductIdentification_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductIdentification(v))),
            "PRODUCT_PROCESS_PLAN" => ProductProcessPlan_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductProcessPlan(v))),
            "PRODUCT_RELATED_PRODUCT_CATEGORY" => ProductRelatedProductCategory_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductRelatedProductCategory(v))),
            "PRODUCT_SPECIFICATION" => ProductSpecification_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProductSpecification(v))),
            "PROJECTED_ZONE_DEFINITION" => ProjectedZoneDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProjectedZoneDefinition(v))),
            "PROJECTION_CURVE" => ProjectionCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProjectionCurve(v))),
            "PROJECTION_DIRECTED_CALLOUT" => ProjectionDirectedCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::ProjectionDirectedCallout(v))),
            "PROMISSORY_USAGE_OCCURRENCE" => PromissoryUsageOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::PromissoryUsageOccurrence(v))),
            "PROPERTY_DEFINITION" => PropertyDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyDefinition(v))),
            "PROPERTY_DEFINITION_RELATIONSHIP" => PropertyDefinitionRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyDefinitionRelationship(v))),
            "PROPERTY_DEFINITION_REPRESENTATION" => PropertyDefinitionRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyDefinitionRepresentation(v))),
            "PROPERTY_PROCESS" => PropertyProcess_::parse_chunks(strs).map(|(s, v)| (s, Entity::PropertyProcess(v))),
            "QUALIFIED_REPRESENTATION_ITEM" => QualifiedRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::QualifiedRepresentationItem(v))),
            "QUALITATIVE_UNCERTAINTY" => QualitativeUncertainty_::parse_chunks(strs).map(|(s, v)| (s, Entity::QualitativeUncertainty(v))),
            "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => QuantifiedAssemblyComponentUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::QuantifiedAssemblyComponentUsage(v))),
            "QUASI_UNIFORM_CURVE" => QuasiUniformCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::QuasiUniformCurve(v))),
            "QUASI_UNIFORM_SURFACE" => QuasiUniformSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::QuasiUniformSurface(v))),
            "RACK_AND_PINION_PAIR" => RackAndPinionPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RackAndPinionPair(v))),
            "RACK_AND_PINION_PAIR_RANGE" => RackAndPinionPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::RackAndPinionPairRange(v))),
            "RACK_AND_PINION_PAIR_VALUE" => RackAndPinionPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RackAndPinionPairValue(v))),
            "RADIUS_DIMENSION" => RadiusDimension_::parse_chunks(strs).map(|(s, v)| (s, Entity::RadiusDimension(v))),
            "RATIO_MEASURE_WITH_UNIT" => RatioMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::RatioMeasureWithUnit(v))),
            "RATIO_UNIT" => RatioUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::RatioUnit(v))),
            "RATIONAL_B_SPLINE_CURVE" => RationalBSplineCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::RationalBSplineCurve(v))),
            "RATIONAL_B_SPLINE_SURFACE" => RationalBSplineSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::RationalBSplineSurface(v))),
            "REAL_DEFINED_FUNCTION" => RealDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::RealDefinedFunction(v))),
            "REAL_LITERAL" => RealLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::RealLiteral(v))),
            "REAL_NUMERIC_VARIABLE" => RealNumericVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::RealNumericVariable(v))),
            "RECTANGULAR_CLOSED_PROFILE" => RectangularClosedProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularClosedProfile(v))),
            "RECTANGULAR_COMPOSITE_SURFACE" => RectangularCompositeSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularCompositeSurface(v))),
            "RECTANGULAR_PATTERN" => RectangularPattern_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularPattern(v))),
            "RECTANGULAR_TRIMMED_SURFACE" => RectangularTrimmedSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::RectangularTrimmedSurface(v))),
            "REFERENCED_MODIFIED_DATUM" => ReferencedModifiedDatum_::parse_chunks(strs).map(|(s, v)| (s, Entity::ReferencedModifiedDatum(v))),
            "RELATIVE_EVENT_OCCURRENCE" => RelativeEventOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::RelativeEventOccurrence(v))),
            "REP_ITEM_GROUP" => RepItemGroup_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepItemGroup(v))),
            "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => ReparametrisedCompositeCurveSegment_::parse_chunks(strs).map(|(s, v)| (s, Entity::ReparametrisedCompositeCurveSegment(v))),
            "REPLICATE_FEATURE" => ReplicateFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::ReplicateFeature(v))),
            "REPRESENTATION" => Representation_::parse_chunks(strs).map(|(s, v)| (s, Entity::Representation(v))),
            "REPRESENTATION_CONTEXT" => RepresentationContext_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationContext(v))),
            "REPRESENTATION_ITEM" => RepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationItem(v))),
            "REPRESENTATION_MAP" => RepresentationMap_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationMap(v))),
            "REPRESENTATION_RELATIONSHIP" => RepresentationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationRelationship(v))),
            "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => RepresentationRelationshipWithTransformation_::parse_chunks(strs).map(|(s, v)| (s, Entity::RepresentationRelationshipWithTransformation(v))),
            "REQUIREMENT_FOR_ACTION_RESOURCE" => RequirementForActionResource_::parse_chunks(strs).map(|(s, v)| (s, Entity::RequirementForActionResource(v))),
            "RESOURCE_PROPERTY" => ResourceProperty_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResourceProperty(v))),
            "RESOURCE_PROPERTY_REPRESENTATION" => ResourcePropertyRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResourcePropertyRepresentation(v))),
            "RESOURCE_REQUIREMENT_TYPE" => ResourceRequirementType_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResourceRequirementType(v))),
            "RESULTING_PATH" => ResultingPath_::parse_chunks(strs).map(|(s, v)| (s, Entity::ResultingPath(v))),
            "RETENTION" => Retention_::parse_chunks(strs).map(|(s, v)| (s, Entity::Retention(v))),
            "REVOLUTE_PAIR" => RevolutePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolutePair(v))),
            "REVOLUTE_PAIR_RANGE" => RevolutePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolutePairRange(v))),
            "REVOLUTE_PAIR_VALUE" => RevolutePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolutePairValue(v))),
            "REVOLVED_AREA_SOLID" => RevolvedAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolvedAreaSolid(v))),
            "REVOLVED_FACE_SOLID" => RevolvedFaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::RevolvedFaceSolid(v))),
            "RIB" => Rib_::parse_chunks(strs).map(|(s, v)| (s, Entity::Rib(v))),
            "RIGHT_ANGULAR_WEDGE" => RightAngularWedge_::parse_chunks(strs).map(|(s, v)| (s, Entity::RightAngularWedge(v))),
            "RIGHT_CIRCULAR_CONE" => RightCircularCone_::parse_chunks(strs).map(|(s, v)| (s, Entity::RightCircularCone(v))),
            "RIGHT_CIRCULAR_CYLINDER" => RightCircularCylinder_::parse_chunks(strs).map(|(s, v)| (s, Entity::RightCircularCylinder(v))),
            "ROLE_ASSOCIATION" => RoleAssociation_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoleAssociation(v))),
            "ROLLING_CURVE_PAIR" => RollingCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingCurvePair(v))),
            "ROLLING_CURVE_PAIR_VALUE" => RollingCurvePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingCurvePairValue(v))),
            "ROLLING_SURFACE_PAIR" => RollingSurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingSurfacePair(v))),
            "ROLLING_SURFACE_PAIR_VALUE" => RollingSurfacePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::RollingSurfacePairValue(v))),
            "ROTATION_ABOUT_DIRECTION" => RotationAboutDirection_::parse_chunks(strs).map(|(s, v)| (s, Entity::RotationAboutDirection(v))),
            "ROUND_HOLE" => RoundHole_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoundHole(v))),
            "ROUNDED_U_PROFILE" => RoundedUProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoundedUProfile(v))),
            "ROUNDNESS_TOLERANCE" => RoundnessTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::RoundnessTolerance(v))),
            "RULED_SURFACE_SWEPT_AREA_SOLID" => RuledSurfaceSweptAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::RuledSurfaceSweptAreaSolid(v))),
            "RUNOUT_ZONE_DEFINITION" => RunoutZoneDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::RunoutZoneDefinition(v))),
            "RUNOUT_ZONE_ORIENTATION" => RunoutZoneOrientation_::parse_chunks(strs).map(|(s, v)| (s, Entity::RunoutZoneOrientation(v))),
            "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => RunoutZoneOrientationReferenceDirection_::parse_chunks(strs).map(|(s, v)| (s, Entity::RunoutZoneOrientationReferenceDirection(v))),
            "SCREW_PAIR" => ScrewPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::ScrewPair(v))),
            "SCREW_PAIR_RANGE" => ScrewPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::ScrewPairRange(v))),
            "SCREW_PAIR_VALUE" => ScrewPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::ScrewPairValue(v))),
            "SEAM_CURVE" => SeamCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::SeamCurve(v))),
            "SEAM_EDGE" => SeamEdge_::parse_chunks(strs).map(|(s, v)| (s, Entity::SeamEdge(v))),
            "SECURITY_CLASSIFICATION" => SecurityClassification_::parse_chunks(strs).map(|(s, v)| (s, Entity::SecurityClassification(v))),
            "SECURITY_CLASSIFICATION_ASSIGNMENT" => SecurityClassificationAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::SecurityClassificationAssignment(v))),
            "SECURITY_CLASSIFICATION_LEVEL" => SecurityClassificationLevel_::parse_chunks(strs).map(|(s, v)| (s, Entity::SecurityClassificationLevel(v))),
            "SERIAL_NUMBERED_EFFECTIVITY" => SerialNumberedEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::SerialNumberedEffectivity(v))),
            "SHAPE_ASPECT" => ShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspect(v))),
            "SHAPE_ASPECT_ASSOCIATIVITY" => ShapeAspectAssociativity_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectAssociativity(v))),
            "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => ShapeAspectDerivingRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectDerivingRelationship(v))),
            "SHAPE_ASPECT_RELATIONSHIP" => ShapeAspectRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectRelationship(v))),
            "SHAPE_ASPECT_TRANSITION" => ShapeAspectTransition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeAspectTransition(v))),
            "SHAPE_DEFINING_RELATIONSHIP" => ShapeDefiningRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeDefiningRelationship(v))),
            "SHAPE_DEFINITION_REPRESENTATION" => ShapeDefinitionRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeDefinitionRepresentation(v))),
            "SHAPE_DIMENSION_REPRESENTATION" => ShapeDimensionRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeDimensionRepresentation(v))),
            "SHAPE_REPRESENTATION" => ShapeRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeRepresentation(v))),
            "SHAPE_REPRESENTATION_RELATIONSHIP" => ShapeRepresentationRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeRepresentationRelationship(v))),
            "SHAPE_REPRESENTATION_WITH_PARAMETERS" => ShapeRepresentationWithParameters_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShapeRepresentationWithParameters(v))),
            "SHELL_BASED_SURFACE_MODEL" => ShellBasedSurfaceModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::ShellBasedSurfaceModel(v))),
            "SI_UNIT" => SiUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::SiUnit(v))),
            "SIMPLE_BOOLEAN_EXPRESSION" => SimpleBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleBooleanExpression(v))),
            "SIMPLE_GENERIC_EXPRESSION" => SimpleGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleGenericExpression(v))),
            "SIMPLE_NUMERIC_EXPRESSION" => SimpleNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleNumericExpression(v))),
            "SIMPLE_PAIR_RANGE" => SimplePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimplePairRange(v))),
            "SIMPLE_STRING_EXPRESSION" => SimpleStringExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SimpleStringExpression(v))),
            "SIN_FUNCTION" => SinFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::SinFunction(v))),
            "SLASH_EXPRESSION" => SlashExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlashExpression(v))),
            "SLIDING_CURVE_PAIR" => SlidingCurvePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingCurvePair(v))),
            "SLIDING_CURVE_PAIR_VALUE" => SlidingCurvePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingCurvePairValue(v))),
            "SLIDING_SURFACE_PAIR" => SlidingSurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingSurfacePair(v))),
            "SLIDING_SURFACE_PAIR_VALUE" => SlidingSurfacePairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlidingSurfacePairValue(v))),
            "SLOT" => Slot_::parse_chunks(strs).map(|(s, v)| (s, Entity::Slot(v))),
            "SLOT_END" => SlotEnd_::parse_chunks(strs).map(|(s, v)| (s, Entity::SlotEnd(v))),
            "SOLID_ANGLE_MEASURE_WITH_UNIT" => SolidAngleMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidAngleMeasureWithUnit(v))),
            "SOLID_ANGLE_UNIT" => SolidAngleUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidAngleUnit(v))),
            "SOLID_MODEL" => SolidModel_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidModel(v))),
            "SOLID_REPLICA" => SolidReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::SolidReplica(v))),
            "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => SpecifiedHigherUsageOccurrence_::parse_chunks(strs).map(|(s, v)| (s, Entity::SpecifiedHigherUsageOccurrence(v))),
            "SPHERE" => Sphere_::parse_chunks(strs).map(|(s, v)| (s, Entity::Sphere(v))),
            "SPHERICAL_PAIR" => SphericalPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalPair(v))),
            "SPHERICAL_PAIR_RANGE" => SphericalPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalPairRange(v))),
            "SPHERICAL_PAIR_VALUE" => SphericalPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalPairValue(v))),
            "SPHERICAL_SURFACE" => SphericalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::SphericalSurface(v))),
            "SQL_MAPPABLE_DEFINED_FUNCTION" => SqlMappableDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::SqlMappableDefinedFunction(v))),
            "SQUARE_ROOT_FUNCTION" => SquareRootFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::SquareRootFunction(v))),
            "SQUARE_U_PROFILE" => SquareUProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::SquareUProfile(v))),
            "STANDARD_UNCERTAINTY" => StandardUncertainty_::parse_chunks(strs).map(|(s, v)| (s, Entity::StandardUncertainty(v))),
            "STRAIGHTNESS_TOLERANCE" => StraightnessTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::StraightnessTolerance(v))),
            "STRING_DEFINED_FUNCTION" => StringDefinedFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringDefinedFunction(v))),
            "STRING_EXPRESSION" => StringExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringExpression(v))),
            "STRING_LITERAL" => StringLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringLiteral(v))),
            "STRING_VARIABLE" => StringVariable_::parse_chunks(strs).map(|(s, v)| (s, Entity::StringVariable(v))),
            "STRUCTURED_DIMENSION_CALLOUT" => StructuredDimensionCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::StructuredDimensionCallout(v))),
            "STYLED_ITEM" => StyledItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::StyledItem(v))),
            "SUBEDGE" => Subedge_::parse_chunks(strs).map(|(s, v)| (s, Entity::Subedge(v))),
            "SUBFACE" => Subface_::parse_chunks(strs).map(|(s, v)| (s, Entity::Subface(v))),
            "SUBSTRING_EXPRESSION" => SubstringExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::SubstringExpression(v))),
            "SURFACE" => Surface_::parse_chunks(strs).map(|(s, v)| (s, Entity::Surface(v))),
            "SURFACE_CONDITION_CALLOUT" => SurfaceConditionCallout_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceConditionCallout(v))),
            "SURFACE_CURVE" => SurfaceCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceCurve(v))),
            "SURFACE_CURVE_SWEPT_AREA_SOLID" => SurfaceCurveSweptAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceCurveSweptAreaSolid(v))),
            "SURFACE_OF_LINEAR_EXTRUSION" => SurfaceOfLinearExtrusion_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceOfLinearExtrusion(v))),
            "SURFACE_OF_REVOLUTION" => SurfaceOfRevolution_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceOfRevolution(v))),
            "SURFACE_PAIR" => SurfacePair_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfacePair(v))),
            "SURFACE_PAIR_RANGE" => SurfacePairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfacePairRange(v))),
            "SURFACE_PATCH" => SurfacePatch_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfacePatch(v))),
            "SURFACE_PROFILE_TOLERANCE" => SurfaceProfileTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceProfileTolerance(v))),
            "SURFACE_RENDERING_PROPERTIES" => SurfaceRenderingProperties_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceRenderingProperties(v))),
            "SURFACE_REPLICA" => SurfaceReplica_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceReplica(v))),
            "SURFACE_SIDE_STYLE" => SurfaceSideStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceSideStyle(v))),
            "SURFACE_STYLE_BOUNDARY" => SurfaceStyleBoundary_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleBoundary(v))),
            "SURFACE_STYLE_CONTROL_GRID" => SurfaceStyleControlGrid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleControlGrid(v))),
            "SURFACE_STYLE_FILL_AREA" => SurfaceStyleFillArea_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleFillArea(v))),
            "SURFACE_STYLE_PARAMETER_LINE" => SurfaceStyleParameterLine_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleParameterLine(v))),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT" => SurfaceStyleReflectanceAmbient_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleReflectanceAmbient(v))),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => SurfaceStyleReflectanceAmbientDiffuse_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleReflectanceAmbientDiffuse(v))),
            "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => SurfaceStyleReflectanceAmbientDiffuseSpecular_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleReflectanceAmbientDiffuseSpecular(v))),
            "SURFACE_STYLE_RENDERING" => SurfaceStyleRendering_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleRendering(v))),
            "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => SurfaceStyleRenderingWithProperties_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleRenderingWithProperties(v))),
            "SURFACE_STYLE_SEGMENTATION_CURVE" => SurfaceStyleSegmentationCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleSegmentationCurve(v))),
            "SURFACE_STYLE_SILHOUETTE" => SurfaceStyleSilhouette_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleSilhouette(v))),
            "SURFACE_STYLE_TRANSPARENT" => SurfaceStyleTransparent_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleTransparent(v))),
            "SURFACE_STYLE_USAGE" => SurfaceStyleUsage_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceStyleUsage(v))),
            "SURFACE_TEXTURE_REPRESENTATION" => SurfaceTextureRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::SurfaceTextureRepresentation(v))),
            "SWEPT_AREA_SOLID" => SweptAreaSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptAreaSolid(v))),
            "SWEPT_DISK_SOLID" => SweptDiskSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptDiskSolid(v))),
            "SWEPT_FACE_SOLID" => SweptFaceSolid_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptFaceSolid(v))),
            "SWEPT_SURFACE" => SweptSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::SweptSurface(v))),
            "SYMBOL_COLOUR" => SymbolColour_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolColour(v))),
            "SYMBOL_REPRESENTATION" => SymbolRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolRepresentation(v))),
            "SYMBOL_REPRESENTATION_MAP" => SymbolRepresentationMap_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolRepresentationMap(v))),
            "SYMBOL_STYLE" => SymbolStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolStyle(v))),
            "SYMBOL_TARGET" => SymbolTarget_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymbolTarget(v))),
            "SYMMETRIC_SHAPE_ASPECT" => SymmetricShapeAspect_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymmetricShapeAspect(v))),
            "SYMMETRY_TOLERANCE" => SymmetryTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::SymmetryTolerance(v))),
            "TACTILE_APPEARANCE_REPRESENTATION" => TactileAppearanceRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::TactileAppearanceRepresentation(v))),
            "TAN_FUNCTION" => TanFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::TanFunction(v))),
            "TANGENT" => Tangent_::parse_chunks(strs).map(|(s, v)| (s, Entity::Tangent(v))),
            "TAPER" => Taper_::parse_chunks(strs).map(|(s, v)| (s, Entity::Taper(v))),
            "TEE_PROFILE" => TeeProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::TeeProfile(v))),
            "TERMINATOR_SYMBOL" => TerminatorSymbol_::parse_chunks(strs).map(|(s, v)| (s, Entity::TerminatorSymbol(v))),
            "TEXT_LITERAL" => TextLiteral_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteral(v))),
            "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => TextLiteralWithAssociatedCurves_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithAssociatedCurves(v))),
            "TEXT_LITERAL_WITH_BLANKING_BOX" => TextLiteralWithBlankingBox_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithBlankingBox(v))),
            "TEXT_LITERAL_WITH_DELINEATION" => TextLiteralWithDelineation_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithDelineation(v))),
            "TEXT_LITERAL_WITH_EXTENT" => TextLiteralWithExtent_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextLiteralWithExtent(v))),
            "TEXT_STRING_REPRESENTATION" => TextStringRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStringRepresentation(v))),
            "TEXT_STYLE" => TextStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyle(v))),
            "TEXT_STYLE_FOR_DEFINED_FONT" => TextStyleForDefinedFont_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleForDefinedFont(v))),
            "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => TextStyleWithBoxCharacteristics_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleWithBoxCharacteristics(v))),
            "TEXT_STYLE_WITH_MIRROR" => TextStyleWithMirror_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleWithMirror(v))),
            "TEXT_STYLE_WITH_SPACING" => TextStyleWithSpacing_::parse_chunks(strs).map(|(s, v)| (s, Entity::TextStyleWithSpacing(v))),
            "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => ThermodynamicTemperatureMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ThermodynamicTemperatureMeasureWithUnit(v))),
            "THERMODYNAMIC_TEMPERATURE_UNIT" => ThermodynamicTemperatureUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::ThermodynamicTemperatureUnit(v))),
            "THREAD" => Thread_::parse_chunks(strs).map(|(s, v)| (s, Entity::Thread(v))),
            "TIME_INTERVAL" => TimeInterval_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeInterval(v))),
            "TIME_INTERVAL_ASSIGNMENT" => TimeIntervalAssignment_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalAssignment(v))),
            "TIME_INTERVAL_BASED_EFFECTIVITY" => TimeIntervalBasedEffectivity_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalBasedEffectivity(v))),
            "TIME_INTERVAL_ROLE" => TimeIntervalRole_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalRole(v))),
            "TIME_INTERVAL_WITH_BOUNDS" => TimeIntervalWithBounds_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeIntervalWithBounds(v))),
            "TIME_MEASURE_WITH_UNIT" => TimeMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeMeasureWithUnit(v))),
            "TIME_UNIT" => TimeUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::TimeUnit(v))),
            "TOLERANCE_VALUE" => ToleranceValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceValue(v))),
            "TOLERANCE_ZONE" => ToleranceZone_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceZone(v))),
            "TOLERANCE_ZONE_DEFINITION" => ToleranceZoneDefinition_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceZoneDefinition(v))),
            "TOLERANCE_ZONE_FORM" => ToleranceZoneForm_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToleranceZoneForm(v))),
            "TOPOLOGICAL_REPRESENTATION_ITEM" => TopologicalRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::TopologicalRepresentationItem(v))),
            "TOROIDAL_SURFACE" => ToroidalSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::ToroidalSurface(v))),
            "TORUS" => Torus_::parse_chunks(strs).map(|(s, v)| (s, Entity::Torus(v))),
            "TOTAL_RUNOUT_TOLERANCE" => TotalRunoutTolerance_::parse_chunks(strs).map(|(s, v)| (s, Entity::TotalRunoutTolerance(v))),
            "TRANSITION_FEATURE" => TransitionFeature_::parse_chunks(strs).map(|(s, v)| (s, Entity::TransitionFeature(v))),
            "TRIMMED_CURVE" => TrimmedCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::TrimmedCurve(v))),
            "TWO_DIRECTION_REPEAT_FACTOR" => TwoDirectionRepeatFactor_::parse_chunks(strs).map(|(s, v)| (s, Entity::TwoDirectionRepeatFactor(v))),
            "TYPE_QUALIFIER" => TypeQualifier_::parse_chunks(strs).map(|(s, v)| (s, Entity::TypeQualifier(v))),
            "UNARY_BOOLEAN_EXPRESSION" => UnaryBooleanExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryBooleanExpression(v))),
            "UNARY_FUNCTION_CALL" => UnaryFunctionCall_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryFunctionCall(v))),
            "UNARY_GENERIC_EXPRESSION" => UnaryGenericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryGenericExpression(v))),
            "UNARY_NUMERIC_EXPRESSION" => UnaryNumericExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnaryNumericExpression(v))),
            "UNCERTAINTY_ASSIGNED_REPRESENTATION" => UncertaintyAssignedRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::UncertaintyAssignedRepresentation(v))),
            "UNCERTAINTY_MEASURE_WITH_UNIT" => UncertaintyMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::UncertaintyMeasureWithUnit(v))),
            "UNCERTAINTY_QUALIFIER" => UncertaintyQualifier_::parse_chunks(strs).map(|(s, v)| (s, Entity::UncertaintyQualifier(v))),
            "UNCONSTRAINED_PAIR" => UnconstrainedPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnconstrainedPair(v))),
            "UNCONSTRAINED_PAIR_VALUE" => UnconstrainedPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::UnconstrainedPairValue(v))),
            "UNIFORM_CURVE" => UniformCurve_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniformCurve(v))),
            "UNIFORM_SURFACE" => UniformSurface_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniformSurface(v))),
            "UNIVERSAL_PAIR" => UniversalPair_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniversalPair(v))),
            "UNIVERSAL_PAIR_RANGE" => UniversalPairRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniversalPairRange(v))),
            "UNIVERSAL_PAIR_VALUE" => UniversalPairValue_::parse_chunks(strs).map(|(s, v)| (s, Entity::UniversalPairValue(v))),
            "VALUE_FUNCTION" => ValueFunction_::parse_chunks(strs).map(|(s, v)| (s, Entity::ValueFunction(v))),
            "VALUE_RANGE" => ValueRange_::parse_chunks(strs).map(|(s, v)| (s, Entity::ValueRange(v))),
            "VALUE_REPRESENTATION_ITEM" => ValueRepresentationItem_::parse_chunks(strs).map(|(s, v)| (s, Entity::ValueRepresentationItem(v))),
            "VARIABLE" => Variable_::parse_chunks(strs).map(|(s, v)| (s, Entity::Variable(v))),
            "VARIABLE_SEMANTICS" => VariableSemantics_::parse_chunks(strs).map(|(s, v)| (s, Entity::VariableSemantics(v))),
            "VECTOR" => Vector_::parse_chunks(strs).map(|(s, v)| (s, Entity::Vector(v))),
            "VECTOR_STYLE" => VectorStyle_::parse_chunks(strs).map(|(s, v)| (s, Entity::VectorStyle(v))),
            "VEE_PROFILE" => VeeProfile_::parse_chunks(strs).map(|(s, v)| (s, Entity::VeeProfile(v))),
            "VERSIONED_ACTION_REQUEST" => VersionedActionRequest_::parse_chunks(strs).map(|(s, v)| (s, Entity::VersionedActionRequest(v))),
            "VERSIONED_ACTION_REQUEST_RELATIONSHIP" => VersionedActionRequestRelationship_::parse_chunks(strs).map(|(s, v)| (s, Entity::VersionedActionRequestRelationship(v))),
            "VERTEX" => Vertex_::parse_chunks(strs).map(|(s, v)| (s, Entity::Vertex(v))),
            "VERTEX_LOOP" => VertexLoop_::parse_chunks(strs).map(|(s, v)| (s, Entity::VertexLoop(v))),
            "VERTEX_POINT" => VertexPoint_::parse_chunks(strs).map(|(s, v)| (s, Entity::VertexPoint(v))),
            "VIEW_VOLUME" => ViewVolume_::parse_chunks(strs).map(|(s, v)| (s, Entity::ViewVolume(v))),
            "VISUAL_APPEARANCE_REPRESENTATION" => VisualAppearanceRepresentation_::parse_chunks(strs).map(|(s, v)| (s, Entity::VisualAppearanceRepresentation(v))),
            "VOLUME_MEASURE_WITH_UNIT" => VolumeMeasureWithUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::VolumeMeasureWithUnit(v))),
            "VOLUME_UNIT" => VolumeUnit_::parse_chunks(strs).map(|(s, v)| (s, Entity::VolumeUnit(v))),
            "XOR_EXPRESSION" => XorExpression_::parse_chunks(strs).map(|(s, v)| (s, Entity::XorExpression(v))),
            "" => parse_complex_mapping(strs[0]),
            _ => nom_alt_err(r),
        }
    }
}

pub fn superclasses_of(s: &str) -> &[&str] {
    match s {
        "ABS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "ACOS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "ADVANCED_BREP_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "ADVANCED_FACE" => &["FACE_SURFACE"],
        "AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "AMOUNT_OF_SUBSTANCE_UNIT" => &["NAMED_UNIT"],
        "AND_EXPRESSION" => &["MULTIPLE_ARITY_BOOLEAN_EXPRESSION"],
        "ANGULAR_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "ANGULAR_LOCATION" => &["DIMENSIONAL_LOCATION"],
        "ANGULAR_SIZE" => &["DIMENSIONAL_SIZE"],
        "ANGULARITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "ANNOTATION_CURVE_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "ANNOTATION_FILL_AREA" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "ANNOTATION_FILL_AREA_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "ANNOTATION_OCCURRENCE" => &["STYLED_ITEM"],
        "ANNOTATION_OCCURRENCE_ASSOCIATIVITY" => &["ANNOTATION_OCCURRENCE_RELATIONSHIP"],
        "ANNOTATION_PLANE" => &["ANNOTATION_OCCURRENCE", "GEOMETRIC_REPRESENTATION_ITEM"],
        "ANNOTATION_SUBFIGURE_OCCURRENCE" => &["ANNOTATION_SYMBOL_OCCURRENCE"],
        "ANNOTATION_SYMBOL" => &["MAPPED_ITEM"],
        "ANNOTATION_SYMBOL_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "ANNOTATION_TEXT" => &["MAPPED_ITEM"],
        "ANNOTATION_TEXT_CHARACTER" => &["MAPPED_ITEM"],
        "ANNOTATION_TEXT_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "APEX" => &["DERIVED_SHAPE_ASPECT"],
        "APPLIED_ACTION_ASSIGNMENT" => &["ACTION_ASSIGNMENT"],
        "APPLIED_ACTION_REQUEST_ASSIGNMENT" => &["ACTION_REQUEST_ASSIGNMENT"],
        "APPLIED_APPROVAL_ASSIGNMENT" => &["APPROVAL_ASSIGNMENT"],
        "APPLIED_AREA" => &["SHAPE_ASPECT"],
        "APPLIED_CERTIFICATION_ASSIGNMENT" => &["CERTIFICATION_ASSIGNMENT"],
        "APPLIED_CLASSIFICATION_ASSIGNMENT" => &["CLASSIFICATION_ASSIGNMENT"],
        "APPLIED_CONTRACT_ASSIGNMENT" => &["CONTRACT_ASSIGNMENT"],
        "APPLIED_DATE_AND_TIME_ASSIGNMENT" => &["DATE_AND_TIME_ASSIGNMENT"],
        "APPLIED_DATE_ASSIGNMENT" => &["DATE_ASSIGNMENT"],
        "APPLIED_DOCUMENT_REFERENCE" => &["DOCUMENT_REFERENCE"],
        "APPLIED_DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT" => &["DOCUMENT_USAGE_CONSTRAINT_ASSIGNMENT"],
        "APPLIED_EFFECTIVITY_ASSIGNMENT" => &["EFFECTIVITY_ASSIGNMENT"],
        "APPLIED_EVENT_OCCURRENCE_ASSIGNMENT" => &["EVENT_OCCURRENCE_ASSIGNMENT"],
        "APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT" => &["EXTERNAL_IDENTIFICATION_ASSIGNMENT"],
        "APPLIED_GROUP_ASSIGNMENT" => &["GROUP_ASSIGNMENT"],
        "APPLIED_IDENTIFICATION_ASSIGNMENT" => &["IDENTIFICATION_ASSIGNMENT"],
        "APPLIED_INEFFECTIVITY_ASSIGNMENT" => &["EFFECTIVITY_ASSIGNMENT"],
        "APPLIED_NAME_ASSIGNMENT" => &["NAME_ASSIGNMENT"],
        "APPLIED_ORGANIZATION_ASSIGNMENT" => &["ORGANIZATION_ASSIGNMENT"],
        "APPLIED_ORGANIZATIONAL_PROJECT_ASSIGNMENT" => &["ORGANIZATIONAL_PROJECT_ASSIGNMENT"],
        "APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT" => &["PERSON_AND_ORGANIZATION_ASSIGNMENT"],
        "APPLIED_PRESENTED_ITEM" => &["PRESENTED_ITEM"],
        "APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT" => &["SECURITY_CLASSIFICATION_ASSIGNMENT"],
        "APPLIED_TIME_INTERVAL_ASSIGNMENT" => &["TIME_INTERVAL_ASSIGNMENT"],
        "APPROXIMATION_TOLERANCE" => &["FOUNDED_ITEM"],
        "APPROXIMATION_TOLERANCE_DEVIATION" => &["FOUNDED_ITEM"],
        "APPROXIMATION_TOLERANCE_PARAMETER" => &["FOUNDED_ITEM"],
        "AREA_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "AREA_UNIT" => &["DERIVED_UNIT"],
        "ASIN_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "ASSEMBLY_COMPONENT_USAGE" => &["PRODUCT_DEFINITION_USAGE"],
        "ATAN_FUNCTION" => &["BINARY_FUNCTION_CALL"],
        "ATTRIBUTE_LANGUAGE_ASSIGNMENT" => &["ATTRIBUTE_CLASSIFICATION_ASSIGNMENT"],
        "AXIS1_PLACEMENT" => &["PLACEMENT"],
        "AXIS2_PLACEMENT_2D" => &["PLACEMENT"],
        "AXIS2_PLACEMENT_3D" => &["PLACEMENT"],
        "B_SPLINE_CURVE" => &["BOUNDED_CURVE"],
        "B_SPLINE_CURVE_WITH_KNOTS" => &["B_SPLINE_CURVE"],
        "B_SPLINE_SURFACE" => &["BOUNDED_SURFACE"],
        "B_SPLINE_SURFACE_WITH_KNOTS" => &["B_SPLINE_SURFACE"],
        "BACKGROUND_COLOUR" => &["COLOUR"],
        "BARRING_HOLE" => &["FEATURE_DEFINITION"],
        "BEAD" => &["FEATURE_DEFINITION"],
        "BEAD_END" => &["SHAPE_ASPECT"],
        "BEZIER_CURVE" => &["B_SPLINE_CURVE"],
        "BEZIER_SURFACE" => &["B_SPLINE_SURFACE"],
        "BINARY_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "BINARY_FUNCTION_CALL" => &["BINARY_NUMERIC_EXPRESSION"],
        "BINARY_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "BINARY_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "BLOCK" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "BOOLEAN_DEFINED_FUNCTION" => &["DEFINED_FUNCTION", "BOOLEAN_EXPRESSION"],
        "BOOLEAN_EXPRESSION" => &["EXPRESSION"],
        "BOOLEAN_LITERAL" => &["SIMPLE_BOOLEAN_EXPRESSION", "GENERIC_LITERAL"],
        "BOOLEAN_RESULT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "BOOLEAN_VARIABLE" => &["SIMPLE_BOOLEAN_EXPRESSION", "VARIABLE"],
        "BOSS" => &["FEATURE_DEFINITION"],
        "BOSS_TOP" => &["SHAPE_ASPECT"],
        "BOUNDARY_CURVE" => &["COMPOSITE_CURVE_ON_SURFACE"],
        "BOUNDED_CURVE" => &["CURVE"],
        "BOUNDED_PCURVE" => &["PCURVE", "BOUNDED_CURVE"],
        "BOUNDED_SURFACE" => &["SURFACE"],
        "BOUNDED_SURFACE_CURVE" => &["SURFACE_CURVE", "BOUNDED_CURVE"],
        "BOX_DOMAIN" => &["FOUNDED_ITEM"],
        "BOXED_HALF_SPACE" => &["HALF_SPACE_SOLID"],
        "BREP_WITH_VOIDS" => &["MANIFOLD_SOLID_BREP"],
        "CALENDAR_DATE" => &["DATE"],
        "CAMERA_IMAGE" => &["MAPPED_ITEM"],
        "CAMERA_IMAGE_2D_WITH_SCALE" => &["CAMERA_IMAGE"],
        "CAMERA_IMAGE_3D_WITH_SCALE" => &["CAMERA_IMAGE"],
        "CAMERA_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "CAMERA_MODEL_D2" => &["CAMERA_MODEL"],
        "CAMERA_MODEL_D3" => &["CAMERA_MODEL"],
        "CAMERA_MODEL_D3_WITH_HLHSR" => &["CAMERA_MODEL_D3"],
        "CAMERA_USAGE" => &["REPRESENTATION_MAP"],
        "CARTESIAN_POINT" => &["POINT"],
        "CARTESIAN_TRANSFORMATION_OPERATOR" => &["GEOMETRIC_REPRESENTATION_ITEM", "FUNCTIONALLY_DEFINED_TRANSFORMATION"],
        "CARTESIAN_TRANSFORMATION_OPERATOR_2D" => &["CARTESIAN_TRANSFORMATION_OPERATOR"],
        "CARTESIAN_TRANSFORMATION_OPERATOR_3D" => &["CARTESIAN_TRANSFORMATION_OPERATOR"],
        "CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "CENTRE_OF_SYMMETRY" => &["DERIVED_SHAPE_ASPECT"],
        "CHAMFER" => &["TRANSITION_FEATURE"],
        "CHAMFER_OFFSET" => &["SHAPE_ASPECT"],
        "CHARACTER_GLYPH_SYMBOL" => &["GENERIC_CHARACTER_GLYPH_SYMBOL"],
        "CHARACTERIZED_CLASS" => &["CHARACTERIZED_OBJECT", "CLASS"],
        "CIRCLE" => &["CONIC"],
        "CIRCULAR_CLOSED_PROFILE" => &["SHAPE_ASPECT"],
        "CIRCULAR_PATTERN" => &["REPLICATE_FEATURE"],
        "CIRCULAR_RUNOUT_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "CLASS" => &["GROUP"],
        "CLASS_SYSTEM" => &["GROUP"],
        "CLASS_USAGE_EFFECTIVITY_CONTEXT_ASSIGNMENT" => &["EFFECTIVITY_CONTEXT_ASSIGNMENT"],
        "CLOSED_PATH_PROFILE" => &["SHAPE_ASPECT"],
        "CLOSED_SHELL" => &["CONNECTED_FACE_SET"],
        "COAXIALITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "COLOUR_RGB" => &["COLOUR_SPECIFICATION"],
        "COLOUR_SPECIFICATION" => &["COLOUR"],
        "COMMON_DATUM" => &["COMPOSITE_SHAPE_ASPECT", "DATUM"],
        "COMPARISON_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_EXPRESSION" => &["BOOLEAN_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "COMPARISON_GREATER" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_GREATER_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_LESS" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_LESS_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPARISON_NOT_EQUAL" => &["COMPARISON_EXPRESSION"],
        "COMPOSITE_CURVE" => &["BOUNDED_CURVE"],
        "COMPOSITE_CURVE_ON_SURFACE" => &["COMPOSITE_CURVE"],
        "COMPOSITE_CURVE_SEGMENT" => &["FOUNDED_ITEM"],
        "COMPOSITE_HOLE" => &["COMPOUND_FEATURE"],
        "COMPOSITE_SHAPE_ASPECT" => &["SHAPE_ASPECT"],
        "COMPOSITE_TEXT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES" => &["COMPOSITE_TEXT"],
        "COMPOSITE_TEXT_WITH_BLANKING_BOX" => &["COMPOSITE_TEXT"],
        "COMPOSITE_TEXT_WITH_EXTENT" => &["COMPOSITE_TEXT"],
        "COMPOUND_FEATURE" => &["FEATURE_DEFINITION"],
        "COMPOUND_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "COMPOUND_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "CONCAT_EXPRESSION" => &["STRING_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "CONCENTRICITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION" => &["CONCEPT_FEATURE_RELATIONSHIP"],
        "CONDITIONAL_CONCEPT_FEATURE" => &["PRODUCT_CONCEPT_FEATURE"],
        "CONFIGURABLE_ITEM" => &["CONFIGURATION_ITEM"],
        "CONFIGURATION_EFFECTIVITY" => &["PRODUCT_DEFINITION_EFFECTIVITY"],
        "CONFIGURED_EFFECTIVITY_ASSIGNMENT" => &["EFFECTIVITY_ASSIGNMENT"],
        "CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT" => &["EFFECTIVITY_CONTEXT_ASSIGNMENT"],
        "CONIC" => &["CURVE"],
        "CONICAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "CONNECTED_EDGE_SET" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "CONNECTED_FACE_SET" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "CONNECTED_FACE_SUB_SET" => &["CONNECTED_FACE_SET"],
        "CONSTRUCTIVE_GEOMETRY_REPRESENTATION" => &["REPRESENTATION"],
        "CONSTRUCTIVE_GEOMETRY_REPRESENTATION_RELATIONSHIP" => &["REPRESENTATION_RELATIONSHIP"],
        "CONTACT_RATIO_REPRESENTATION" => &["REPRESENTATION"],
        "CONTEXT_DEPENDENT_INVISIBILITY" => &["INVISIBILITY"],
        "CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM" => &["OVER_RIDING_STYLED_ITEM"],
        "CONTEXT_DEPENDENT_UNIT" => &["NAMED_UNIT"],
        "CONVERSION_BASED_UNIT" => &["NAMED_UNIT"],
        "COS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "CSG_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "CSG_SOLID" => &["SOLID_MODEL"],
        "CURVE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "CURVE_BOUNDED_SURFACE" => &["BOUNDED_SURFACE"],
        "CURVE_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "CURVE_REPLICA" => &["CURVE"],
        "CURVE_STYLE" => &["FOUNDED_ITEM"],
        "CURVE_STYLE_FONT" => &["FOUNDED_ITEM"],
        "CURVE_STYLE_FONT_PATTERN" => &["FOUNDED_ITEM"],
        "CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "CYLINDRICAL_PAIR" => &["KINEMATIC_PAIR"],
        "CYLINDRICAL_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "CYLINDRICAL_PAIR_VALUE" => &["PAIR_VALUE"],
        "CYLINDRICAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "CYLINDRICITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "DATED_EFFECTIVITY" => &["EFFECTIVITY"],
        "DATUM" => &["SHAPE_ASPECT"],
        "DATUM_FEATURE" => &["SHAPE_ASPECT"],
        "DATUM_FEATURE_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DATUM_TARGET" => &["SHAPE_ASPECT"],
        "DATUM_TARGET_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DEFAULT_TOLERANCE_TABLE" => &["REPRESENTATION"],
        "DEFAULT_TOLERANCE_TABLE_CELL" => &["COMPOUND_REPRESENTATION_ITEM"],
        "DEFINED_CHARACTER_GLYPH" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DEFINED_SYMBOL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DEFINITIONAL_REPRESENTATION" => &["REPRESENTATION"],
        "DEGENERATE_PCURVE" => &["POINT"],
        "DEGENERATE_TOROIDAL_SURFACE" => &["TOROIDAL_SURFACE"],
        "DERIVED_SHAPE_ASPECT" => &["SHAPE_ASPECT"],
        "DERIVED_UNIT_VARIABLE" => &["DERIVED_UNIT", "VARIABLE_SEMANTICS"],
        "DESCRIPTIVE_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "DIAMETER_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "DIMENSION_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP" => &["DRAUGHTING_CALLOUT_RELATIONSHIP"],
        "DIMENSION_CALLOUT_RELATIONSHIP" => &["DRAUGHTING_CALLOUT_RELATIONSHIP"],
        "DIMENSION_CURVE" => &["ANNOTATION_CURVE_OCCURRENCE"],
        "DIMENSION_CURVE_DIRECTED_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "DIMENSION_CURVE_TERMINATOR" => &["TERMINATOR_SYMBOL"],
        "DIMENSION_PAIR" => &["DRAUGHTING_CALLOUT_RELATIONSHIP"],
        "DIMENSION_TEXT_ASSOCIATIVITY" => &["TEXT_LITERAL", "MAPPED_ITEM"],
        "DIMENSIONAL_LOCATION" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "DIMENSIONAL_LOCATION_WITH_PATH" => &["DIMENSIONAL_LOCATION"],
        "DIMENSIONAL_SIZE_WITH_PATH" => &["DIMENSIONAL_SIZE"],
        "DIRECTED_ACTION" => &["EXECUTED_ACTION"],
        "DIRECTED_ANGLE" => &["SHAPE_ASPECT"],
        "DIRECTED_DIMENSIONAL_LOCATION" => &["DIMENSIONAL_LOCATION"],
        "DIRECTION" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DIRECTION_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "DIV_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "DOCUMENT_FILE" => &["DOCUMENT", "CHARACTERIZED_OBJECT"],
        "DOCUMENT_PRODUCT_EQUIVALENCE" => &["DOCUMENT_PRODUCT_ASSOCIATION"],
        "DRAUGHTING_ANNOTATION_OCCURRENCE" => &["ANNOTATION_OCCURRENCE"],
        "DRAUGHTING_CALLOUT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "DRAUGHTING_ELEMENTS" => &["DRAUGHTING_CALLOUT"],
        "DRAUGHTING_MODEL" => &["REPRESENTATION"],
        "DRAUGHTING_MODEL_ITEM_ASSOCIATION" => &["ITEM_IDENTIFIED_REPRESENTATION_USAGE"],
        "DRAUGHTING_PRE_DEFINED_COLOUR" => &["PRE_DEFINED_COLOUR"],
        "DRAUGHTING_PRE_DEFINED_CURVE_FONT" => &["PRE_DEFINED_CURVE_FONT"],
        "DRAUGHTING_PRE_DEFINED_TEXT_FONT" => &["PRE_DEFINED_TEXT_FONT"],
        "DRAUGHTING_SPECIFICATION_REFERENCE" => &["DOCUMENT_REFERENCE"],
        "DRAUGHTING_SUBFIGURE_REPRESENTATION" => &["SYMBOL_REPRESENTATION"],
        "DRAUGHTING_SYMBOL_REPRESENTATION" => &["SYMBOL_REPRESENTATION"],
        "DRAUGHTING_TEXT_LITERAL_WITH_DELINEATION" => &["TEXT_LITERAL_WITH_DELINEATION"],
        "DRAWING_REVISION" => &["PRESENTATION_SET"],
        "DRAWING_SHEET_LAYOUT" => &["DRAUGHTING_SYMBOL_REPRESENTATION"],
        "DRAWING_SHEET_REVISION" => &["PRESENTATION_AREA"],
        "DRAWING_SHEET_REVISION_USAGE" => &["AREA_IN_SET"],
        "EDGE" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "EDGE_BASED_WIREFRAME_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "EDGE_CURVE" => &["EDGE", "GEOMETRIC_REPRESENTATION_ITEM"],
        "EDGE_LOOP" => &["LOOP", "PATH"],
        "EDGE_ROUND" => &["TRANSITION_FEATURE"],
        "ELECTRIC_CURRENT_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "ELECTRIC_CURRENT_UNIT" => &["NAMED_UNIT"],
        "ELEMENT_DELIVERY" => &["ACTION"],
        "ELEMENTARY_SURFACE" => &["SURFACE"],
        "ELLIPSE" => &["CONIC"],
        "EQUALS_EXPRESSION" => &["BINARY_BOOLEAN_EXPRESSION"],
        "EVALUATED_DEGENERATE_PCURVE" => &["DEGENERATE_PCURVE"],
        "EXCLUSIVE_PRODUCT_CONCEPT_FEATURE_CATEGORY" => &["PRODUCT_CONCEPT_FEATURE_CATEGORY"],
        "EXECUTED_ACTION" => &["ACTION"],
        "EXP_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "EXPRESSION" => &["GENERIC_EXPRESSION"],
        "EXPRESSION_CONVERSION_BASED_UNIT" => &["CONTEXT_DEPENDENT_UNIT", "VARIABLE_SEMANTICS"],
        "EXTENSION" => &["DERIVED_SHAPE_ASPECT"],
        "EXTERNAL_IDENTIFICATION_ASSIGNMENT" => &["IDENTIFICATION_ASSIGNMENT"],
        "EXTERNALLY_DEFINED_CHARACTER_GLYPH" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_CLASS" => &["CLASS", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_CURVE_FONT" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_DIMENSION_DEFINITION" => &["DIMENSIONAL_SIZE", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_FEATURE_DEFINITION" => &["FEATURE_DEFINITION", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_GENERAL_PROPERTY" => &["GENERAL_PROPERTY", "EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_HATCH_STYLE" => &["EXTERNALLY_DEFINED_ITEM", "GEOMETRIC_REPRESENTATION_ITEM"],
        "EXTERNALLY_DEFINED_STYLE" => &["EXTERNALLY_DEFINED_ITEM", "FOUNDED_ITEM"],
        "EXTERNALLY_DEFINED_SYMBOL" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_TEXT_FONT" => &["EXTERNALLY_DEFINED_ITEM"],
        "EXTERNALLY_DEFINED_TILE_STYLE" => &["EXTERNALLY_DEFINED_ITEM", "GEOMETRIC_REPRESENTATION_ITEM"],
        "EXTRUDED_AREA_SOLID" => &["SWEPT_AREA_SOLID"],
        "EXTRUDED_FACE_SOLID" => &["SWEPT_FACE_SOLID"],
        "FACE" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "FACE_BASED_SURFACE_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FACE_BOUND" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "FACE_OUTER_BOUND" => &["FACE_BOUND"],
        "FACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "FACE_SURFACE" => &["FACE", "GEOMETRIC_REPRESENTATION_ITEM"],
        "FACETED_BREP" => &["MANIFOLD_SOLID_BREP"],
        "FACETED_BREP_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "FEATURE_COMPONENT_DEFINITION" => &["CHARACTERIZED_OBJECT"],
        "FEATURE_COMPONENT_RELATIONSHIP" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "FEATURE_DEFINITION" => &["CHARACTERIZED_OBJECT"],
        "FEATURE_IN_PANEL" => &["FEATURE_DEFINITION"],
        "FEATURE_PATTERN" => &["REPLICATE_FEATURE"],
        "FEATURED_SHAPE" => &["PRODUCT_DEFINITION_SHAPE"],
        "FILL_AREA_STYLE" => &["FOUNDED_ITEM"],
        "FILL_AREA_STYLE_HATCHING" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FILL_AREA_STYLE_TILE_SYMBOL_WITH_STYLE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FILL_AREA_STYLE_TILES" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "FILLET" => &["TRANSITION_FEATURE"],
        "FLATNESS_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "FORMAT_FUNCTION" => &["STRING_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "FOUNDED_KINEMATIC_PATH" => &["REPRESENTATION"],
        "FULLY_CONSTRAINED_PAIR" => &["KINEMATIC_PAIR"],
        "GEAR_PAIR" => &["KINEMATIC_PAIR"],
        "GEAR_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "GEAR_PAIR_VALUE" => &["PAIR_VALUE"],
        "GENERAL_FEATURE" => &["FEATURE_DEFINITION"],
        "GENERAL_MATERIAL_PROPERTY" => &["GENERAL_PROPERTY"],
        "GENERIC_CHARACTER_GLYPH_SYMBOL" => &["SYMBOL_REPRESENTATION"],
        "GENERIC_LITERAL" => &["SIMPLE_GENERIC_EXPRESSION"],
        "GENERIC_VARIABLE" => &["SIMPLE_GENERIC_EXPRESSION"],
        "GEOMETRIC_ALIGNMENT" => &["DERIVED_SHAPE_ASPECT"],
        "GEOMETRIC_CURVE_SET" => &["GEOMETRIC_SET"],
        "GEOMETRIC_INTERSECTION" => &["DERIVED_SHAPE_ASPECT"],
        "GEOMETRIC_ITEM_SPECIFIC_USAGE" => &["ITEM_IDENTIFIED_REPRESENTATION_USAGE"],
        "GEOMETRIC_REPRESENTATION_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "GEOMETRIC_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "GEOMETRIC_SET" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE" => &["GEOMETRIC_TOLERANCE"],
        "GEOMETRIC_TOLERANCE_WITH_DEFINED_UNIT" => &["GEOMETRIC_TOLERANCE"],
        "GEOMETRICAL_TOLERANCE_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "GLOBAL_UNIT_ASSIGNED_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "HALF_SPACE_SOLID" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "HARDNESS_REPRESENTATION" => &["REPRESENTATION"],
        "HIDDEN_ELEMENT_OVER_RIDING_STYLED_ITEM" => &["CONTEXT_DEPENDENT_OVER_RIDING_STYLED_ITEM"],
        "HOLE_BOTTOM" => &["SHAPE_ASPECT"],
        "HOLE_IN_PANEL" => &["FEATURE_DEFINITION"],
        "HOMOKINETIC_PAIR" => &["UNIVERSAL_PAIR"],
        "HYPERBOLA" => &["CONIC"],
        "INCLUSION_PRODUCT_CONCEPT_FEATURE" => &["CONDITIONAL_CONCEPT_FEATURE"],
        "INDEX_EXPRESSION" => &["STRING_EXPRESSION", "BINARY_GENERIC_EXPRESSION"],
        "INSTANCED_FEATURE" => &["SHAPE_ASPECT", "FEATURE_DEFINITION"],
        "INT_LITERAL" => &["LITERAL_NUMBER"],
        "INT_NUMERIC_VARIABLE" => &["NUMERIC_VARIABLE"],
        "INT_VALUE_FUNCTION" => &["VALUE_FUNCTION"],
        "INTEGER_DEFINED_FUNCTION" => &["NUMERIC_DEFINED_FUNCTION"],
        "INTERSECTION_CURVE" => &["SURFACE_CURVE"],
        "INTERVAL_EXPRESSION" => &["BOOLEAN_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "JOGGLE" => &["FEATURE_DEFINITION"],
        "JOGGLE_TERMINATION" => &["SHAPE_ASPECT"],
        "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION" => &["REPRESENTATION"],
        "KINEMATIC_FRAME_BACKGROUND_REPRESENTATION_ASSOCIATION" => &["REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION"],
        "KINEMATIC_FRAME_BASED_TRANSFORMATION" => &["GEOMETRIC_REPRESENTATION_ITEM", "FUNCTIONALLY_DEFINED_TRANSFORMATION"],
        "KINEMATIC_GROUND_REPRESENTATION" => &["REPRESENTATION"],
        "KINEMATIC_LINK_REPRESENTATION" => &["REPRESENTATION"],
        "KINEMATIC_LINK_REPRESENTATION_ASSOCIATION" => &["REPRESENTATION_RELATIONSHIP"],
        "KINEMATIC_PAIR" => &["ITEM_DEFINED_TRANSFORMATION"],
        "KINEMATIC_PATH" => &["REPRESENTATION_ITEM"],
        "KINEMATIC_PROPERTY_DEFINITION" => &["PROPERTY_DEFINITION"],
        "KINEMATIC_PROPERTY_REPRESENTATION_RELATION" => &["PROPERTY_DEFINITION_REPRESENTATION"],
        "KNOWN_SOURCE" => &["EXTERNAL_SOURCE", "PRE_DEFINED_ITEM"],
        "LANGUAGE" => &["GROUP"],
        "LANGUAGE_ASSIGNMENT" => &["CLASSIFICATION_ASSIGNMENT"],
        "LEADER_CURVE" => &["ANNOTATION_CURVE_OCCURRENCE"],
        "LEADER_DIRECTED_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "LEADER_DIRECTED_DIMENSION" => &["LEADER_DIRECTED_CALLOUT"],
        "LEADER_TERMINATOR" => &["TERMINATOR_SYMBOL"],
        "LENGTH_FUNCTION" => &["NUMERIC_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "LENGTH_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "LENGTH_UNIT" => &["NAMED_UNIT"],
        "LIGHT_SOURCE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "LIGHT_SOURCE_AMBIENT" => &["LIGHT_SOURCE"],
        "LIGHT_SOURCE_DIRECTIONAL" => &["LIGHT_SOURCE"],
        "LIGHT_SOURCE_POSITIONAL" => &["LIGHT_SOURCE"],
        "LIGHT_SOURCE_SPOT" => &["LIGHT_SOURCE"],
        "LIKE_EXPRESSION" => &["COMPARISON_EXPRESSION"],
        "LINE" => &["CURVE"],
        "LINE_PROFILE_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "LINEAR_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "LITERAL_NUMBER" => &["SIMPLE_NUMERIC_EXPRESSION", "GENERIC_LITERAL"],
        "LOCATION_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "LOCATOR" => &["FEATURE_DEFINITION"],
        "LOG10_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "LOG2_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "LOG_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "LOOP" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "LOT_EFFECTIVITY" => &["EFFECTIVITY"],
        "LUMINOUS_INTENSITY_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "LUMINOUS_INTENSITY_UNIT" => &["NAMED_UNIT"],
        "MAKE_FROM_USAGE_OPTION" => &["PRODUCT_DEFINITION_USAGE"],
        "MANIFOLD_SOLID_BREP" => &["SOLID_MODEL"],
        "MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "MAPPED_ITEM" => &["REPRESENTATION_ITEM"],
        "MASS_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "MASS_UNIT" => &["NAMED_UNIT"],
        "MATERIAL_PROPERTY" => &["PROPERTY_DEFINITION"],
        "MATERIAL_PROPERTY_REPRESENTATION" => &["PROPERTY_DEFINITION_REPRESENTATION"],
        "MAXIMUM_FUNCTION" => &["MULTIPLE_ARITY_FUNCTION_CALL"],
        "MEASURE_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM", "MEASURE_WITH_UNIT"],
        "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_AREA" => &["PRESENTATION_AREA"],
        "MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION" => &["REPRESENTATION"],
        "MECHANISM_BASE_PLACEMENT" => &["REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION"],
        "MINIMUM_FUNCTION" => &["MULTIPLE_ARITY_FUNCTION_CALL"],
        "MINUS_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "MINUS_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "MOD_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "MODIFIED_GEOMETRIC_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "MODIFIED_PATTERN" => &["REPLICATE_FEATURE"],
        "MOMENTS_OF_INERTIA_REPRESENTATION" => &["REPRESENTATION"],
        "MOTION_LINK_RELATIONSHIP" => &["REPRESENTATION_RELATIONSHIP"],
        "MULT_EXPRESSION" => &["MULTIPLE_ARITY_NUMERIC_EXPRESSION"],
        "MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT" => &["ATTRIBUTE_VALUE_ASSIGNMENT"],
        "MULTIPLE_ARITY_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "MULTIPLE_ARITY_FUNCTION_CALL" => &["MULTIPLE_ARITY_NUMERIC_EXPRESSION"],
        "MULTIPLE_ARITY_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "MULTIPLE_ARITY_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "NAMED_UNIT_VARIABLE" => &["NAMED_UNIT", "VARIABLE_SEMANTICS"],
        "NEXT_ASSEMBLY_USAGE_OCCURRENCE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "NGON_CLOSED_PROFILE" => &["SHAPE_ASPECT"],
        "NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "NOT_EXPRESSION" => &["UNARY_BOOLEAN_EXPRESSION"],
        "NUMERIC_DEFINED_FUNCTION" => &["NUMERIC_EXPRESSION", "DEFINED_FUNCTION"],
        "NUMERIC_EXPRESSION" => &["EXPRESSION"],
        "NUMERIC_VARIABLE" => &["SIMPLE_NUMERIC_EXPRESSION", "VARIABLE"],
        "ODD_FUNCTION" => &["UNARY_BOOLEAN_EXPRESSION"],
        "OFFSET_CURVE_2D" => &["CURVE"],
        "OFFSET_CURVE_3D" => &["CURVE"],
        "OFFSET_SURFACE" => &["SURFACE"],
        "ONE_DIRECTION_REPEAT_FACTOR" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "OPEN_PATH_PROFILE" => &["SHAPE_ASPECT"],
        "OPEN_SHELL" => &["CONNECTED_FACE_SET"],
        "OR_EXPRESSION" => &["MULTIPLE_ARITY_BOOLEAN_EXPRESSION"],
        "ORDINATE_DIMENSION" => &["PROJECTION_DIRECTED_CALLOUT"],
        "ORGANIZATIONAL_ADDRESS" => &["ADDRESS"],
        "ORIENTED_CLOSED_SHELL" => &["CLOSED_SHELL"],
        "ORIENTED_EDGE" => &["EDGE"],
        "ORIENTED_FACE" => &["FACE"],
        "ORIENTED_OPEN_SHELL" => &["OPEN_SHELL"],
        "ORIENTED_PATH" => &["PATH"],
        "ORIENTED_SURFACE" => &["SURFACE"],
        "OUTER_BOUNDARY_CURVE" => &["BOUNDARY_CURVE"],
        "OVER_RIDING_STYLED_ITEM" => &["STYLED_ITEM"],
        "PACKAGE_PRODUCT_CONCEPT_FEATURE" => &["PRODUCT_CONCEPT_FEATURE"],
        "PARABOLA" => &["CONIC"],
        "PARALLEL_OFFSET" => &["DERIVED_SHAPE_ASPECT"],
        "PARALLELISM_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "PARAMETRIC_REPRESENTATION_CONTEXT" => &["REPRESENTATION_CONTEXT"],
        "PARTIAL_CIRCULAR_PROFILE" => &["SHAPE_ASPECT"],
        "PATH" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "PATH_FEATURE_COMPONENT" => &["SHAPE_ASPECT"],
        "PATH_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "PATTERN_OFFSET_MEMBERSHIP" => &["FEATURE_COMPONENT_RELATIONSHIP"],
        "PATTERN_OMIT_MEMBERSHIP" => &["FEATURE_COMPONENT_RELATIONSHIP"],
        "PCURVE" => &["CURVE"],
        "PERPENDICULAR_TO" => &["DERIVED_SHAPE_ASPECT"],
        "PERPENDICULARITY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "PERSON_AND_ORGANIZATION_ADDRESS" => &["ORGANIZATIONAL_ADDRESS", "PERSONAL_ADDRESS"],
        "PERSONAL_ADDRESS" => &["ADDRESS"],
        "PHYSICALLY_MODELLED_PRODUCT_DEFINITION" => &["PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS"],
        "PLACED_DATUM_TARGET_FEATURE" => &["DATUM_TARGET"],
        "PLACED_FEATURE" => &["SHAPE_ASPECT"],
        "PLACEMENT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "PLANAR_BOX" => &["PLANAR_EXTENT"],
        "PLANAR_CURVE_PAIR" => &["KINEMATIC_PAIR"],
        "PLANAR_CURVE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "PLANAR_EXTENT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "PLANAR_PAIR" => &["KINEMATIC_PAIR"],
        "PLANAR_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "PLANAR_PAIR_VALUE" => &["PAIR_VALUE"],
        "PLANAR_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "PLANE" => &["ELEMENTARY_SURFACE"],
        "PLANE_ANGLE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "PLANE_ANGLE_UNIT" => &["NAMED_UNIT"],
        "PLUS_EXPRESSION" => &["MULTIPLE_ARITY_NUMERIC_EXPRESSION"],
        "POCKET" => &["FEATURE_DEFINITION"],
        "POCKET_BOTTOM" => &["SHAPE_ASPECT"],
        "POINT" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "POINT_ON_CURVE" => &["POINT"],
        "POINT_ON_PLANAR_CURVE_PAIR" => &["KINEMATIC_PAIR"],
        "POINT_ON_PLANAR_CURVE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "POINT_ON_PLANAR_CURVE_PAIR_VALUE" => &["PAIR_VALUE"],
        "POINT_ON_SURFACE" => &["POINT"],
        "POINT_ON_SURFACE_PAIR" => &["KINEMATIC_PAIR"],
        "POINT_ON_SURFACE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "POINT_ON_SURFACE_PAIR_VALUE" => &["PAIR_VALUE"],
        "POINT_PLACEMENT_SHAPE_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "POINT_REPLICA" => &["POINT"],
        "POINT_STYLE" => &["FOUNDED_ITEM"],
        "POLY_LOOP" => &["LOOP", "GEOMETRIC_REPRESENTATION_ITEM"],
        "POLYLINE" => &["BOUNDED_CURVE"],
        "POSITION_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "POWER_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "PRE_DEFINED_COLOUR" => &["PRE_DEFINED_ITEM", "COLOUR"],
        "PRE_DEFINED_CURVE_FONT" => &["PRE_DEFINED_ITEM"],
        "PRE_DEFINED_DIMENSION_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_GEOMETRICAL_TOLERANCE_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_MARKER" => &["PRE_DEFINED_ITEM"],
        "PRE_DEFINED_POINT_MARKER_SYMBOL" => &["PRE_DEFINED_MARKER", "PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_PRESENTATION_STYLE" => &["FOUNDED_ITEM", "PRE_DEFINED_ITEM"],
        "PRE_DEFINED_SURFACE_CONDITION_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_SYMBOL" => &["PRE_DEFINED_ITEM"],
        "PRE_DEFINED_TERMINATOR_SYMBOL" => &["PRE_DEFINED_SYMBOL"],
        "PRE_DEFINED_TEXT_FONT" => &["PRE_DEFINED_ITEM"],
        "PRESENTATION_AREA" => &["PRESENTATION_REPRESENTATION"],
        "PRESENTATION_REPRESENTATION" => &["REPRESENTATION"],
        "PRESENTATION_STYLE_ASSIGNMENT" => &["FOUNDED_ITEM"],
        "PRESENTATION_STYLE_BY_CONTEXT" => &["PRESENTATION_STYLE_ASSIGNMENT"],
        "PRESENTATION_VIEW" => &["PRESENTATION_REPRESENTATION"],
        "PRISMATIC_PAIR" => &["KINEMATIC_PAIR"],
        "PRISMATIC_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "PRISMATIC_PAIR_VALUE" => &["PAIR_VALUE"],
        "PROCESS_OPERATION" => &["ACTION_METHOD"],
        "PROCESS_PLAN" => &["ACTION"],
        "PRODUCT_CLASS" => &["PRODUCT_CONCEPT", "CHARACTERIZED_OBJECT"],
        "PRODUCT_CONCEPT_CONTEXT" => &["APPLICATION_CONTEXT_ELEMENT"],
        "PRODUCT_CONCEPT_FEATURE_CATEGORY" => &["GROUP"],
        "PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE" => &["GROUP_ASSIGNMENT"],
        "PRODUCT_CONTEXT" => &["APPLICATION_CONTEXT_ELEMENT"],
        "PRODUCT_DEFINITION_CONTEXT" => &["APPLICATION_CONTEXT_ELEMENT"],
        "PRODUCT_DEFINITION_EFFECTIVITY" => &["EFFECTIVITY"],
        "PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE" => &["PRODUCT_DEFINITION_FORMATION"],
        "PRODUCT_DEFINITION_PROCESS" => &["ACTION"],
        "PRODUCT_DEFINITION_RESOURCE" => &["ACTION_RESOURCE", "PRODUCT_DEFINITION"],
        "PRODUCT_DEFINITION_SHAPE" => &["PROPERTY_DEFINITION"],
        "PRODUCT_DEFINITION_USAGE" => &["PRODUCT_DEFINITION_RELATIONSHIP"],
        "PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS" => &["PRODUCT_DEFINITION"],
        "PRODUCT_IDENTIFICATION" => &["CONFIGURATION_ITEM", "CHARACTERIZED_OBJECT"],
        "PRODUCT_PROCESS_PLAN" => &["PRODUCT_DEFINITION_PROCESS"],
        "PRODUCT_RELATED_PRODUCT_CATEGORY" => &["PRODUCT_CATEGORY"],
        "PRODUCT_SPECIFICATION" => &["PRODUCT_IDENTIFICATION", "CONFIGURABLE_ITEM"],
        "PROJECTED_ZONE_DEFINITION" => &["TOLERANCE_ZONE_DEFINITION"],
        "PROJECTION_CURVE" => &["ANNOTATION_CURVE_OCCURRENCE"],
        "PROJECTION_DIRECTED_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "PROMISSORY_USAGE_OCCURRENCE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "PROPERTY_PROCESS" => &["ACTION"],
        "QUALIFIED_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "QUALITATIVE_UNCERTAINTY" => &["UNCERTAINTY_QUALIFIER"],
        "QUANTIFIED_ASSEMBLY_COMPONENT_USAGE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "QUASI_UNIFORM_CURVE" => &["B_SPLINE_CURVE"],
        "QUASI_UNIFORM_SURFACE" => &["B_SPLINE_SURFACE"],
        "RACK_AND_PINION_PAIR" => &["KINEMATIC_PAIR"],
        "RACK_AND_PINION_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "RACK_AND_PINION_PAIR_VALUE" => &["PAIR_VALUE"],
        "RADIUS_DIMENSION" => &["DIMENSION_CURVE_DIRECTED_CALLOUT"],
        "RATIO_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "RATIO_UNIT" => &["NAMED_UNIT"],
        "RATIONAL_B_SPLINE_CURVE" => &["B_SPLINE_CURVE"],
        "RATIONAL_B_SPLINE_SURFACE" => &["B_SPLINE_SURFACE"],
        "REAL_DEFINED_FUNCTION" => &["NUMERIC_DEFINED_FUNCTION"],
        "REAL_LITERAL" => &["LITERAL_NUMBER"],
        "REAL_NUMERIC_VARIABLE" => &["NUMERIC_VARIABLE"],
        "RECTANGULAR_CLOSED_PROFILE" => &["SHAPE_ASPECT"],
        "RECTANGULAR_COMPOSITE_SURFACE" => &["BOUNDED_SURFACE"],
        "RECTANGULAR_PATTERN" => &["REPLICATE_FEATURE"],
        "RECTANGULAR_TRIMMED_SURFACE" => &["BOUNDED_SURFACE"],
        "REFERENCED_MODIFIED_DATUM" => &["DATUM_REFERENCE"],
        "RELATIVE_EVENT_OCCURRENCE" => &["EVENT_OCCURRENCE"],
        "REP_ITEM_GROUP" => &["GROUP", "REPRESENTATION_ITEM"],
        "REPARAMETRISED_COMPOSITE_CURVE_SEGMENT" => &["COMPOSITE_CURVE_SEGMENT"],
        "REPLICATE_FEATURE" => &["FEATURE_DEFINITION"],
        "REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION" => &["REPRESENTATION_RELATIONSHIP"],
        "REQUIREMENT_FOR_ACTION_RESOURCE" => &["ACTION_RESOURCE_REQUIREMENT"],
        "RESULTING_PATH" => &["MOTION_LINK_RELATIONSHIP"],
        "RETENTION" => &["ACTION"],
        "REVOLUTE_PAIR" => &["KINEMATIC_PAIR"],
        "REVOLUTE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "REVOLUTE_PAIR_VALUE" => &["PAIR_VALUE"],
        "REVOLVED_AREA_SOLID" => &["SWEPT_AREA_SOLID"],
        "REVOLVED_FACE_SOLID" => &["SWEPT_FACE_SOLID"],
        "RIB" => &["FEATURE_DEFINITION"],
        "RIGHT_ANGULAR_WEDGE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "RIGHT_CIRCULAR_CONE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "RIGHT_CIRCULAR_CYLINDER" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "ROLLING_CURVE_PAIR" => &["PLANAR_CURVE_PAIR"],
        "ROLLING_CURVE_PAIR_VALUE" => &["PAIR_VALUE"],
        "ROLLING_SURFACE_PAIR" => &["SURFACE_PAIR"],
        "ROLLING_SURFACE_PAIR_VALUE" => &["PAIR_VALUE"],
        "ROUND_HOLE" => &["FEATURE_DEFINITION"],
        "ROUNDED_U_PROFILE" => &["SHAPE_ASPECT"],
        "ROUNDNESS_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "RULED_SURFACE_SWEPT_AREA_SOLID" => &["SURFACE_CURVE_SWEPT_AREA_SOLID"],
        "RUNOUT_ZONE_DEFINITION" => &["TOLERANCE_ZONE_DEFINITION"],
        "RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION" => &["RUNOUT_ZONE_ORIENTATION"],
        "SCREW_PAIR" => &["KINEMATIC_PAIR"],
        "SCREW_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "SCREW_PAIR_VALUE" => &["PAIR_VALUE"],
        "SEAM_CURVE" => &["SURFACE_CURVE"],
        "SEAM_EDGE" => &["ORIENTED_EDGE"],
        "SERIAL_NUMBERED_EFFECTIVITY" => &["EFFECTIVITY"],
        "SHAPE_ASPECT_ASSOCIATIVITY" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_ASPECT_DERIVING_RELATIONSHIP" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_ASPECT_TRANSITION" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_DEFINING_RELATIONSHIP" => &["SHAPE_ASPECT_RELATIONSHIP"],
        "SHAPE_DEFINITION_REPRESENTATION" => &["PROPERTY_DEFINITION_REPRESENTATION"],
        "SHAPE_DIMENSION_REPRESENTATION" => &["SHAPE_REPRESENTATION"],
        "SHAPE_REPRESENTATION" => &["REPRESENTATION"],
        "SHAPE_REPRESENTATION_RELATIONSHIP" => &["REPRESENTATION_RELATIONSHIP"],
        "SHAPE_REPRESENTATION_WITH_PARAMETERS" => &["SHAPE_REPRESENTATION"],
        "SHELL_BASED_SURFACE_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SI_UNIT" => &["NAMED_UNIT"],
        "SIMPLE_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "SIMPLE_GENERIC_EXPRESSION"],
        "SIMPLE_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "SIMPLE_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "SIMPLE_GENERIC_EXPRESSION"],
        "SIMPLE_STRING_EXPRESSION" => &["STRING_EXPRESSION", "SIMPLE_GENERIC_EXPRESSION"],
        "SIN_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "SLASH_EXPRESSION" => &["BINARY_NUMERIC_EXPRESSION"],
        "SLIDING_CURVE_PAIR" => &["PLANAR_CURVE_PAIR"],
        "SLIDING_CURVE_PAIR_VALUE" => &["PAIR_VALUE"],
        "SLIDING_SURFACE_PAIR" => &["SURFACE_PAIR"],
        "SLIDING_SURFACE_PAIR_VALUE" => &["PAIR_VALUE"],
        "SLOT" => &["FEATURE_DEFINITION"],
        "SLOT_END" => &["SHAPE_ASPECT"],
        "SOLID_ANGLE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "SOLID_ANGLE_UNIT" => &["NAMED_UNIT"],
        "SOLID_MODEL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SOLID_REPLICA" => &["SOLID_MODEL"],
        "SPECIFIED_HIGHER_USAGE_OCCURRENCE" => &["ASSEMBLY_COMPONENT_USAGE"],
        "SPHERE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SPHERICAL_PAIR" => &["KINEMATIC_PAIR"],
        "SPHERICAL_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "SPHERICAL_PAIR_VALUE" => &["PAIR_VALUE"],
        "SPHERICAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "SQL_MAPPABLE_DEFINED_FUNCTION" => &["DEFINED_FUNCTION"],
        "SQUARE_ROOT_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "SQUARE_U_PROFILE" => &["SHAPE_ASPECT"],
        "STANDARD_UNCERTAINTY" => &["UNCERTAINTY_QUALIFIER"],
        "STRAIGHTNESS_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "STRING_DEFINED_FUNCTION" => &["DEFINED_FUNCTION", "STRING_EXPRESSION"],
        "STRING_EXPRESSION" => &["EXPRESSION"],
        "STRING_LITERAL" => &["SIMPLE_STRING_EXPRESSION", "GENERIC_LITERAL"],
        "STRING_VARIABLE" => &["SIMPLE_STRING_EXPRESSION", "VARIABLE"],
        "STRUCTURED_DIMENSION_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "STYLED_ITEM" => &["REPRESENTATION_ITEM"],
        "SUBEDGE" => &["EDGE"],
        "SUBFACE" => &["FACE"],
        "SUBSTRING_EXPRESSION" => &["STRING_EXPRESSION", "MULTIPLE_ARITY_GENERIC_EXPRESSION"],
        "SURFACE" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SURFACE_CONDITION_CALLOUT" => &["DRAUGHTING_CALLOUT"],
        "SURFACE_CURVE" => &["CURVE"],
        "SURFACE_CURVE_SWEPT_AREA_SOLID" => &["SWEPT_AREA_SOLID"],
        "SURFACE_OF_LINEAR_EXTRUSION" => &["SWEPT_SURFACE"],
        "SURFACE_OF_REVOLUTION" => &["SWEPT_SURFACE"],
        "SURFACE_PAIR" => &["KINEMATIC_PAIR"],
        "SURFACE_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "SURFACE_PATCH" => &["FOUNDED_ITEM"],
        "SURFACE_PROFILE_TOLERANCE" => &["GEOMETRIC_TOLERANCE"],
        "SURFACE_REPLICA" => &["SURFACE"],
        "SURFACE_SIDE_STYLE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_BOUNDARY" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_CONTROL_GRID" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_FILL_AREA" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_PARAMETER_LINE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE" => &["SURFACE_STYLE_REFLECTANCE_AMBIENT"],
        "SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE_SPECULAR" => &["SURFACE_STYLE_REFLECTANCE_AMBIENT_DIFFUSE"],
        "SURFACE_STYLE_RENDERING_WITH_PROPERTIES" => &["SURFACE_STYLE_RENDERING"],
        "SURFACE_STYLE_SEGMENTATION_CURVE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_SILHOUETTE" => &["FOUNDED_ITEM"],
        "SURFACE_STYLE_USAGE" => &["FOUNDED_ITEM"],
        "SURFACE_TEXTURE_REPRESENTATION" => &["REPRESENTATION"],
        "SWEPT_AREA_SOLID" => &["SOLID_MODEL"],
        "SWEPT_DISK_SOLID" => &["SOLID_MODEL"],
        "SWEPT_FACE_SOLID" => &["SOLID_MODEL"],
        "SWEPT_SURFACE" => &["SURFACE"],
        "SYMBOL_REPRESENTATION" => &["REPRESENTATION"],
        "SYMBOL_REPRESENTATION_MAP" => &["REPRESENTATION_MAP"],
        "SYMBOL_STYLE" => &["FOUNDED_ITEM"],
        "SYMBOL_TARGET" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "SYMMETRIC_SHAPE_ASPECT" => &["SHAPE_ASPECT"],
        "SYMMETRY_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "TACTILE_APPEARANCE_REPRESENTATION" => &["REPRESENTATION"],
        "TAN_FUNCTION" => &["UNARY_FUNCTION_CALL"],
        "TANGENT" => &["DERIVED_SHAPE_ASPECT"],
        "TAPER" => &["SHAPE_ASPECT"],
        "TEE_PROFILE" => &["SHAPE_ASPECT"],
        "TERMINATOR_SYMBOL" => &["ANNOTATION_SYMBOL_OCCURRENCE"],
        "TEXT_LITERAL" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "TEXT_LITERAL_WITH_ASSOCIATED_CURVES" => &["TEXT_LITERAL"],
        "TEXT_LITERAL_WITH_BLANKING_BOX" => &["TEXT_LITERAL"],
        "TEXT_LITERAL_WITH_DELINEATION" => &["TEXT_LITERAL"],
        "TEXT_LITERAL_WITH_EXTENT" => &["TEXT_LITERAL"],
        "TEXT_STRING_REPRESENTATION" => &["REPRESENTATION"],
        "TEXT_STYLE" => &["FOUNDED_ITEM"],
        "TEXT_STYLE_WITH_BOX_CHARACTERISTICS" => &["TEXT_STYLE"],
        "TEXT_STYLE_WITH_MIRROR" => &["TEXT_STYLE"],
        "TEXT_STYLE_WITH_SPACING" => &["TEXT_STYLE"],
        "THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "THERMODYNAMIC_TEMPERATURE_UNIT" => &["NAMED_UNIT"],
        "THREAD" => &["FEATURE_DEFINITION"],
        "TIME_INTERVAL_BASED_EFFECTIVITY" => &["EFFECTIVITY"],
        "TIME_INTERVAL_WITH_BOUNDS" => &["TIME_INTERVAL"],
        "TIME_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "TIME_UNIT" => &["NAMED_UNIT"],
        "TOLERANCE_ZONE" => &["SHAPE_ASPECT"],
        "TOPOLOGICAL_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "TOROIDAL_SURFACE" => &["ELEMENTARY_SURFACE"],
        "TORUS" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "TOTAL_RUNOUT_TOLERANCE" => &["GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE"],
        "TRANSITION_FEATURE" => &["SHAPE_ASPECT"],
        "TRIMMED_CURVE" => &["BOUNDED_CURVE"],
        "TWO_DIRECTION_REPEAT_FACTOR" => &["ONE_DIRECTION_REPEAT_FACTOR"],
        "UNARY_BOOLEAN_EXPRESSION" => &["BOOLEAN_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "UNARY_FUNCTION_CALL" => &["UNARY_NUMERIC_EXPRESSION"],
        "UNARY_GENERIC_EXPRESSION" => &["GENERIC_EXPRESSION"],
        "UNARY_NUMERIC_EXPRESSION" => &["NUMERIC_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "UNCERTAINTY_ASSIGNED_REPRESENTATION" => &["REPRESENTATION"],
        "UNCERTAINTY_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "UNCONSTRAINED_PAIR" => &["KINEMATIC_PAIR"],
        "UNCONSTRAINED_PAIR_VALUE" => &["PAIR_VALUE"],
        "UNIFORM_CURVE" => &["B_SPLINE_CURVE"],
        "UNIFORM_SURFACE" => &["B_SPLINE_SURFACE"],
        "UNIVERSAL_PAIR" => &["KINEMATIC_PAIR"],
        "UNIVERSAL_PAIR_RANGE" => &["SIMPLE_PAIR_RANGE"],
        "UNIVERSAL_PAIR_VALUE" => &["PAIR_VALUE"],
        "VALUE_FUNCTION" => &["NUMERIC_EXPRESSION", "UNARY_GENERIC_EXPRESSION"],
        "VALUE_RANGE" => &["COMPOUND_REPRESENTATION_ITEM"],
        "VALUE_REPRESENTATION_ITEM" => &["REPRESENTATION_ITEM"],
        "VARIABLE" => &["GENERIC_VARIABLE"],
        "VECTOR" => &["GEOMETRIC_REPRESENTATION_ITEM"],
        "VECTOR_STYLE" => &["PRE_DEFINED_TERMINATOR_SYMBOL", "CURVE_STYLE"],
        "VEE_PROFILE" => &["SHAPE_ASPECT"],
        "VERTEX" => &["TOPOLOGICAL_REPRESENTATION_ITEM"],
        "VERTEX_LOOP" => &["LOOP"],
        "VERTEX_POINT" => &["VERTEX", "GEOMETRIC_REPRESENTATION_ITEM"],
        "VIEW_VOLUME" => &["FOUNDED_ITEM"],
        "VISUAL_APPEARANCE_REPRESENTATION" => &["REPRESENTATION"],
        "VOLUME_MEASURE_WITH_UNIT" => &["MEASURE_WITH_UNIT"],
        "VOLUME_UNIT" => &["DERIVED_UNIT"],
        "XOR_EXPRESSION" => &["BINARY_BOOLEAN_EXPRESSION"],
        _ => &[],
    }
}
impl<'a> Entity<'a> {
    pub fn upstream(&self) -> Vec<usize> {
        let mut out = Vec::new();
        match self {

            Entity::AbsFunction(c) => c.append_ids(&mut out),
            Entity::AcosFunction(c) => c.append_ids(&mut out),
            Entity::Action(c) => c.append_ids(&mut out),
            Entity::ActionAssignment(c) => c.append_ids(&mut out),
            Entity::ActionDirective(c) => c.append_ids(&mut out),
            Entity::ActionMethod(c) => c.append_ids(&mut out),
            Entity::ActionMethodRelationship(c) => c.append_ids(&mut out),
            Entity::ActionProperty(c) => c.append_ids(&mut out),
            Entity::ActionPropertyRepresentation(c) => c.append_ids(&mut out),
            Entity::ActionRelationship(c) => c.append_ids(&mut out),
            Entity::ActionRequestAssignment(c) => c.append_ids(&mut out),
            Entity::ActionRequestSolution(c) => c.append_ids(&mut out),
            Entity::ActionRequestStatus(c) => c.append_ids(&mut out),
            Entity::ActionResource(c) => c.append_ids(&mut out),
            Entity::ActionResourceRequirement(c) => c.append_ids(&mut out),
            Entity::ActionResourceType(c) => c.append_ids(&mut out),
            Entity::ActionStatus(c) => c.append_ids(&mut out),
            Entity::Address(c) => c.append_ids(&mut out),
            Entity::AdvancedBrepShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::AdvancedFace(c) => c.append_ids(&mut out),
            Entity::AlternateProductRelationship(c) => c.append_ids(&mut out),
            Entity::AmountOfSubstanceMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::AmountOfSubstanceUnit(c) => c.append_ids(&mut out),
            Entity::AndExpression(c) => c.append_ids(&mut out),
            Entity::AngularDimension(c) => c.append_ids(&mut out),
            Entity::AngularLocation(c) => c.append_ids(&mut out),
            Entity::AngularSize(c) => c.append_ids(&mut out),
            Entity::AngularityTolerance(c) => c.append_ids(&mut out),
            Entity::AnnotationCurveOccurrence(c) => c.append_ids(&mut out),
            Entity::AnnotationFillArea(c) => c.append_ids(&mut out),
            Entity::AnnotationFillAreaOccurrence(c) => c.append_ids(&mut out),
            Entity::AnnotationOccurrence(c) => c.append_ids(&mut out),
            Entity::AnnotationOccurrenceAssociativity(c) => c.append_ids(&mut out),
            Entity::AnnotationOccurrenceRelationship(c) => c.append_ids(&mut out),
            Entity::AnnotationPlane(c) => c.append_ids(&mut out),
            Entity::AnnotationSubfigureOccurrence(c) => c.append_ids(&mut out),
            Entity::AnnotationSymbol(c) => c.append_ids(&mut out),
            Entity::AnnotationSymbolOccurrence(c) => c.append_ids(&mut out),
            Entity::AnnotationText(c) => c.append_ids(&mut out),
            Entity::AnnotationTextCharacter(c) => c.append_ids(&mut out),
            Entity::AnnotationTextOccurrence(c) => c.append_ids(&mut out),
            Entity::Apex(c) => c.append_ids(&mut out),
            Entity::ApplicationContext(c) => c.append_ids(&mut out),
            Entity::ApplicationContextElement(c) => c.append_ids(&mut out),
            Entity::ApplicationContextRelationship(c) => c.append_ids(&mut out),
            Entity::ApplicationProtocolDefinition(c) => c.append_ids(&mut out),
            Entity::AppliedActionAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedActionRequestAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedApprovalAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedArea(c) => c.append_ids(&mut out),
            Entity::AppliedCertificationAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedClassificationAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedContractAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedDateAndTimeAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedDateAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedDocumentReference(c) => c.append_ids(&mut out),
            Entity::AppliedDocumentUsageConstraintAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedEffectivityAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedEventOccurrenceAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedExternalIdentificationAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedGroupAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedIdentificationAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedIneffectivityAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedNameAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedOrganizationAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedOrganizationalProjectAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedPersonAndOrganizationAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedPresentedItem(c) => c.append_ids(&mut out),
            Entity::AppliedSecurityClassificationAssignment(c) => c.append_ids(&mut out),
            Entity::AppliedTimeIntervalAssignment(c) => c.append_ids(&mut out),
            Entity::Approval(c) => c.append_ids(&mut out),
            Entity::ApprovalAssignment(c) => c.append_ids(&mut out),
            Entity::ApprovalDateTime(c) => c.append_ids(&mut out),
            Entity::ApprovalPersonOrganization(c) => c.append_ids(&mut out),
            Entity::ApprovalRelationship(c) => c.append_ids(&mut out),
            Entity::ApprovalRole(c) => c.append_ids(&mut out),
            Entity::ApprovalStatus(c) => c.append_ids(&mut out),
            Entity::ApproximationTolerance(c) => c.append_ids(&mut out),
            Entity::ApproximationToleranceDeviation(c) => c.append_ids(&mut out),
            Entity::ApproximationToleranceParameter(c) => c.append_ids(&mut out),
            Entity::AreaInSet(c) => c.append_ids(&mut out),
            Entity::AreaMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::AreaUnit(c) => c.append_ids(&mut out),
            Entity::AsinFunction(c) => c.append_ids(&mut out),
            Entity::AssemblyComponentUsage(c) => c.append_ids(&mut out),
            Entity::AssemblyComponentUsageSubstitute(c) => c.append_ids(&mut out),
            Entity::AtanFunction(c) => c.append_ids(&mut out),
            Entity::AttributeClassificationAssignment(c) => c.append_ids(&mut out),
            Entity::AttributeLanguageAssignment(c) => c.append_ids(&mut out),
            Entity::AttributeValueAssignment(c) => c.append_ids(&mut out),
            Entity::AttributeValueRole(c) => c.append_ids(&mut out),
            Entity::Axis1Placement(c) => c.append_ids(&mut out),
            Entity::Axis2Placement2d(c) => c.append_ids(&mut out),
            Entity::Axis2Placement3d(c) => c.append_ids(&mut out),
            Entity::BSplineCurve(c) => c.append_ids(&mut out),
            Entity::BSplineCurveWithKnots(c) => c.append_ids(&mut out),
            Entity::BSplineSurface(c) => c.append_ids(&mut out),
            Entity::BSplineSurfaceWithKnots(c) => c.append_ids(&mut out),
            Entity::BackgroundColour(c) => c.append_ids(&mut out),
            Entity::BarringHole(c) => c.append_ids(&mut out),
            Entity::Bead(c) => c.append_ids(&mut out),
            Entity::BeadEnd(c) => c.append_ids(&mut out),
            Entity::BezierCurve(c) => c.append_ids(&mut out),
            Entity::BezierSurface(c) => c.append_ids(&mut out),
            Entity::BinaryBooleanExpression(c) => c.append_ids(&mut out),
            Entity::BinaryFunctionCall(c) => c.append_ids(&mut out),
            Entity::BinaryGenericExpression(c) => c.append_ids(&mut out),
            Entity::BinaryNumericExpression(c) => c.append_ids(&mut out),
            Entity::Block(c) => c.append_ids(&mut out),
            Entity::BooleanDefinedFunction(c) => c.append_ids(&mut out),
            Entity::BooleanExpression(c) => c.append_ids(&mut out),
            Entity::BooleanLiteral(c) => c.append_ids(&mut out),
            Entity::BooleanResult(c) => c.append_ids(&mut out),
            Entity::BooleanVariable(c) => c.append_ids(&mut out),
            Entity::Boss(c) => c.append_ids(&mut out),
            Entity::BossTop(c) => c.append_ids(&mut out),
            Entity::BoundaryCurve(c) => c.append_ids(&mut out),
            Entity::BoundedCurve(c) => c.append_ids(&mut out),
            Entity::BoundedPcurve(c) => c.append_ids(&mut out),
            Entity::BoundedSurface(c) => c.append_ids(&mut out),
            Entity::BoundedSurfaceCurve(c) => c.append_ids(&mut out),
            Entity::BoxDomain(c) => c.append_ids(&mut out),
            Entity::BoxedHalfSpace(c) => c.append_ids(&mut out),
            Entity::BrepWithVoids(c) => c.append_ids(&mut out),
            Entity::CalendarDate(c) => c.append_ids(&mut out),
            Entity::CameraImage(c) => c.append_ids(&mut out),
            Entity::CameraImage2dWithScale(c) => c.append_ids(&mut out),
            Entity::CameraImage3dWithScale(c) => c.append_ids(&mut out),
            Entity::CameraModel(c) => c.append_ids(&mut out),
            Entity::CameraModelD2(c) => c.append_ids(&mut out),
            Entity::CameraModelD3(c) => c.append_ids(&mut out),
            Entity::CameraModelD3WithHlhsr(c) => c.append_ids(&mut out),
            Entity::CameraUsage(c) => c.append_ids(&mut out),
            Entity::CartesianPoint(c) => c.append_ids(&mut out),
            Entity::CartesianTransformationOperator(c) => c.append_ids(&mut out),
            Entity::CartesianTransformationOperator2d(c) => c.append_ids(&mut out),
            Entity::CartesianTransformationOperator3d(c) => c.append_ids(&mut out),
            Entity::CelsiusTemperatureMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::CentreOfSymmetry(c) => c.append_ids(&mut out),
            Entity::Certification(c) => c.append_ids(&mut out),
            Entity::CertificationAssignment(c) => c.append_ids(&mut out),
            Entity::CertificationType(c) => c.append_ids(&mut out),
            Entity::Chamfer(c) => c.append_ids(&mut out),
            Entity::ChamferOffset(c) => c.append_ids(&mut out),
            Entity::CharacterGlyphSymbol(c) => c.append_ids(&mut out),
            Entity::CharacterizedClass(c) => c.append_ids(&mut out),
            Entity::CharacterizedObject(c) => c.append_ids(&mut out),
            Entity::Circle(c) => c.append_ids(&mut out),
            Entity::CircularClosedProfile(c) => c.append_ids(&mut out),
            Entity::CircularPattern(c) => c.append_ids(&mut out),
            Entity::CircularRunoutTolerance(c) => c.append_ids(&mut out),
            Entity::Class(c) => c.append_ids(&mut out),
            Entity::ClassSystem(c) => c.append_ids(&mut out),
            Entity::ClassUsageEffectivityContextAssignment(c) => c.append_ids(&mut out),
            Entity::ClassificationAssignment(c) => c.append_ids(&mut out),
            Entity::ClassificationRole(c) => c.append_ids(&mut out),
            Entity::ClosedPathProfile(c) => c.append_ids(&mut out),
            Entity::ClosedShell(c) => c.append_ids(&mut out),
            Entity::CoaxialityTolerance(c) => c.append_ids(&mut out),
            Entity::Colour(c) => c.append_ids(&mut out),
            Entity::ColourRgb(c) => c.append_ids(&mut out),
            Entity::ColourSpecification(c) => c.append_ids(&mut out),
            Entity::CommonDatum(c) => c.append_ids(&mut out),
            Entity::ComparisonEqual(c) => c.append_ids(&mut out),
            Entity::ComparisonExpression(c) => c.append_ids(&mut out),
            Entity::ComparisonGreater(c) => c.append_ids(&mut out),
            Entity::ComparisonGreaterEqual(c) => c.append_ids(&mut out),
            Entity::ComparisonLess(c) => c.append_ids(&mut out),
            Entity::ComparisonLessEqual(c) => c.append_ids(&mut out),
            Entity::ComparisonNotEqual(c) => c.append_ids(&mut out),
            Entity::CompositeCurve(c) => c.append_ids(&mut out),
            Entity::CompositeCurveOnSurface(c) => c.append_ids(&mut out),
            Entity::CompositeCurveSegment(c) => c.append_ids(&mut out),
            Entity::CompositeHole(c) => c.append_ids(&mut out),
            Entity::CompositeShapeAspect(c) => c.append_ids(&mut out),
            Entity::CompositeText(c) => c.append_ids(&mut out),
            Entity::CompositeTextWithAssociatedCurves(c) => c.append_ids(&mut out),
            Entity::CompositeTextWithBlankingBox(c) => c.append_ids(&mut out),
            Entity::CompositeTextWithExtent(c) => c.append_ids(&mut out),
            Entity::CompoundFeature(c) => c.append_ids(&mut out),
            Entity::CompoundRepresentationItem(c) => c.append_ids(&mut out),
            Entity::CompoundShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::ConcatExpression(c) => c.append_ids(&mut out),
            Entity::ConcentricityTolerance(c) => c.append_ids(&mut out),
            Entity::ConceptFeatureOperator(c) => c.append_ids(&mut out),
            Entity::ConceptFeatureRelationship(c) => c.append_ids(&mut out),
            Entity::ConceptFeatureRelationshipWithCondition(c) => c.append_ids(&mut out),
            Entity::ConditionalConceptFeature(c) => c.append_ids(&mut out),
            Entity::ConfigurableItem(c) => c.append_ids(&mut out),
            Entity::ConfigurationDefinition(c) => c.append_ids(&mut out),
            Entity::ConfigurationDesign(c) => c.append_ids(&mut out),
            Entity::ConfigurationEffectivity(c) => c.append_ids(&mut out),
            Entity::ConfigurationInterpolation(c) => c.append_ids(&mut out),
            Entity::ConfigurationItem(c) => c.append_ids(&mut out),
            Entity::ConfiguredEffectivityAssignment(c) => c.append_ids(&mut out),
            Entity::ConfiguredEffectivityContextAssignment(c) => c.append_ids(&mut out),
            Entity::Conic(c) => c.append_ids(&mut out),
            Entity::ConicalSurface(c) => c.append_ids(&mut out),
            Entity::ConnectedEdgeSet(c) => c.append_ids(&mut out),
            Entity::ConnectedFaceSet(c) => c.append_ids(&mut out),
            Entity::ConnectedFaceSubSet(c) => c.append_ids(&mut out),
            Entity::ConstructiveGeometryRepresentation(c) => c.append_ids(&mut out),
            Entity::ConstructiveGeometryRepresentationRelationship(c) => c.append_ids(&mut out),
            Entity::ContactRatioRepresentation(c) => c.append_ids(&mut out),
            Entity::ContextDependentInvisibility(c) => c.append_ids(&mut out),
            Entity::ContextDependentOverRidingStyledItem(c) => c.append_ids(&mut out),
            Entity::ContextDependentShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::ContextDependentUnit(c) => c.append_ids(&mut out),
            Entity::Contract(c) => c.append_ids(&mut out),
            Entity::ContractAssignment(c) => c.append_ids(&mut out),
            Entity::ContractType(c) => c.append_ids(&mut out),
            Entity::ConversionBasedUnit(c) => c.append_ids(&mut out),
            Entity::CoordinatedUniversalTimeOffset(c) => c.append_ids(&mut out),
            Entity::CosFunction(c) => c.append_ids(&mut out),
            Entity::CsgShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::CsgSolid(c) => c.append_ids(&mut out),
            Entity::Curve(c) => c.append_ids(&mut out),
            Entity::CurveBoundedSurface(c) => c.append_ids(&mut out),
            Entity::CurveDimension(c) => c.append_ids(&mut out),
            Entity::CurveReplica(c) => c.append_ids(&mut out),
            Entity::CurveStyle(c) => c.append_ids(&mut out),
            Entity::CurveStyleFont(c) => c.append_ids(&mut out),
            Entity::CurveStyleFontPattern(c) => c.append_ids(&mut out),
            Entity::CurveStyleRendering(c) => c.append_ids(&mut out),
            Entity::CurveSweptSolidShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::CylindricalPair(c) => c.append_ids(&mut out),
            Entity::CylindricalPairRange(c) => c.append_ids(&mut out),
            Entity::CylindricalPairValue(c) => c.append_ids(&mut out),
            Entity::CylindricalSurface(c) => c.append_ids(&mut out),
            Entity::CylindricityTolerance(c) => c.append_ids(&mut out),
            Entity::DataEnvironment(c) => c.append_ids(&mut out),
            Entity::Date(c) => c.append_ids(&mut out),
            Entity::DateAndTime(c) => c.append_ids(&mut out),
            Entity::DateAndTimeAssignment(c) => c.append_ids(&mut out),
            Entity::DateAssignment(c) => c.append_ids(&mut out),
            Entity::DateRole(c) => c.append_ids(&mut out),
            Entity::DateTimeRole(c) => c.append_ids(&mut out),
            Entity::DatedEffectivity(c) => c.append_ids(&mut out),
            Entity::Datum(c) => c.append_ids(&mut out),
            Entity::DatumFeature(c) => c.append_ids(&mut out),
            Entity::DatumFeatureCallout(c) => c.append_ids(&mut out),
            Entity::DatumReference(c) => c.append_ids(&mut out),
            Entity::DatumTarget(c) => c.append_ids(&mut out),
            Entity::DatumTargetCallout(c) => c.append_ids(&mut out),
            Entity::DefaultToleranceTable(c) => c.append_ids(&mut out),
            Entity::DefaultToleranceTableCell(c) => c.append_ids(&mut out),
            Entity::DefinedCharacterGlyph(c) => c.append_ids(&mut out),
            Entity::DefinedFunction(c) => c.append_ids(&mut out),
            Entity::DefinedSymbol(c) => c.append_ids(&mut out),
            Entity::DefinitionalRepresentation(c) => c.append_ids(&mut out),
            Entity::DegeneratePcurve(c) => c.append_ids(&mut out),
            Entity::DegenerateToroidalSurface(c) => c.append_ids(&mut out),
            Entity::DerivedShapeAspect(c) => c.append_ids(&mut out),
            Entity::DerivedUnit(c) => c.append_ids(&mut out),
            Entity::DerivedUnitElement(c) => c.append_ids(&mut out),
            Entity::DerivedUnitVariable(c) => c.append_ids(&mut out),
            Entity::DescriptionAttribute(c) => c.append_ids(&mut out),
            Entity::DescriptiveRepresentationItem(c) => c.append_ids(&mut out),
            Entity::DiameterDimension(c) => c.append_ids(&mut out),
            Entity::DimensionCallout(c) => c.append_ids(&mut out),
            Entity::DimensionCalloutComponentRelationship(c) => c.append_ids(&mut out),
            Entity::DimensionCalloutRelationship(c) => c.append_ids(&mut out),
            Entity::DimensionCurve(c) => c.append_ids(&mut out),
            Entity::DimensionCurveDirectedCallout(c) => c.append_ids(&mut out),
            Entity::DimensionCurveTerminator(c) => c.append_ids(&mut out),
            Entity::DimensionPair(c) => c.append_ids(&mut out),
            Entity::DimensionRelatedToleranceZoneElement(c) => c.append_ids(&mut out),
            Entity::DimensionTextAssociativity(c) => c.append_ids(&mut out),
            Entity::DimensionalCharacteristicRepresentation(c) => c.append_ids(&mut out),
            Entity::DimensionalExponents(c) => c.append_ids(&mut out),
            Entity::DimensionalLocation(c) => c.append_ids(&mut out),
            Entity::DimensionalLocationWithPath(c) => c.append_ids(&mut out),
            Entity::DimensionalSize(c) => c.append_ids(&mut out),
            Entity::DimensionalSizeWithPath(c) => c.append_ids(&mut out),
            Entity::DirectedAction(c) => c.append_ids(&mut out),
            Entity::DirectedAngle(c) => c.append_ids(&mut out),
            Entity::DirectedDimensionalLocation(c) => c.append_ids(&mut out),
            Entity::Direction(c) => c.append_ids(&mut out),
            Entity::DirectionShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::DivExpression(c) => c.append_ids(&mut out),
            Entity::Document(c) => c.append_ids(&mut out),
            Entity::DocumentFile(c) => c.append_ids(&mut out),
            Entity::DocumentProductAssociation(c) => c.append_ids(&mut out),
            Entity::DocumentProductEquivalence(c) => c.append_ids(&mut out),
            Entity::DocumentReference(c) => c.append_ids(&mut out),
            Entity::DocumentRelationship(c) => c.append_ids(&mut out),
            Entity::DocumentRepresentationType(c) => c.append_ids(&mut out),
            Entity::DocumentType(c) => c.append_ids(&mut out),
            Entity::DocumentUsageConstraint(c) => c.append_ids(&mut out),
            Entity::DocumentUsageConstraintAssignment(c) => c.append_ids(&mut out),
            Entity::DocumentUsageRole(c) => c.append_ids(&mut out),
            Entity::DraughtingAnnotationOccurrence(c) => c.append_ids(&mut out),
            Entity::DraughtingCallout(c) => c.append_ids(&mut out),
            Entity::DraughtingCalloutRelationship(c) => c.append_ids(&mut out),
            Entity::DraughtingElements(c) => c.append_ids(&mut out),
            Entity::DraughtingModel(c) => c.append_ids(&mut out),
            Entity::DraughtingModelItemAssociation(c) => c.append_ids(&mut out),
            Entity::DraughtingPreDefinedColour(c) => c.append_ids(&mut out),
            Entity::DraughtingPreDefinedCurveFont(c) => c.append_ids(&mut out),
            Entity::DraughtingPreDefinedTextFont(c) => c.append_ids(&mut out),
            Entity::DraughtingSpecificationReference(c) => c.append_ids(&mut out),
            Entity::DraughtingSubfigureRepresentation(c) => c.append_ids(&mut out),
            Entity::DraughtingSymbolRepresentation(c) => c.append_ids(&mut out),
            Entity::DraughtingTextLiteralWithDelineation(c) => c.append_ids(&mut out),
            Entity::DraughtingTitle(c) => c.append_ids(&mut out),
            Entity::DrawingDefinition(c) => c.append_ids(&mut out),
            Entity::DrawingRevision(c) => c.append_ids(&mut out),
            Entity::DrawingRevisionSequence(c) => c.append_ids(&mut out),
            Entity::DrawingSheetLayout(c) => c.append_ids(&mut out),
            Entity::DrawingSheetRevision(c) => c.append_ids(&mut out),
            Entity::DrawingSheetRevisionUsage(c) => c.append_ids(&mut out),
            Entity::Edge(c) => c.append_ids(&mut out),
            Entity::EdgeBasedWireframeModel(c) => c.append_ids(&mut out),
            Entity::EdgeBasedWireframeShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::EdgeCurve(c) => c.append_ids(&mut out),
            Entity::EdgeLoop(c) => c.append_ids(&mut out),
            Entity::EdgeRound(c) => c.append_ids(&mut out),
            Entity::Effectivity(c) => c.append_ids(&mut out),
            Entity::EffectivityAssignment(c) => c.append_ids(&mut out),
            Entity::EffectivityContextAssignment(c) => c.append_ids(&mut out),
            Entity::EffectivityContextRole(c) => c.append_ids(&mut out),
            Entity::EffectivityRelationship(c) => c.append_ids(&mut out),
            Entity::ElectricCurrentMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::ElectricCurrentUnit(c) => c.append_ids(&mut out),
            Entity::ElementDelivery(c) => c.append_ids(&mut out),
            Entity::ElementarySurface(c) => c.append_ids(&mut out),
            Entity::Ellipse(c) => c.append_ids(&mut out),
            Entity::Environment(c) => c.append_ids(&mut out),
            Entity::EqualsExpression(c) => c.append_ids(&mut out),
            Entity::EvaluatedDegeneratePcurve(c) => c.append_ids(&mut out),
            Entity::EventOccurrence(c) => c.append_ids(&mut out),
            Entity::EventOccurrenceAssignment(c) => c.append_ids(&mut out),
            Entity::EventOccurrenceContextAssignment(c) => c.append_ids(&mut out),
            Entity::EventOccurrenceContextRole(c) => c.append_ids(&mut out),
            Entity::EventOccurrenceRole(c) => c.append_ids(&mut out),
            Entity::ExclusiveProductConceptFeatureCategory(c) => c.append_ids(&mut out),
            Entity::ExecutedAction(c) => c.append_ids(&mut out),
            Entity::ExpFunction(c) => c.append_ids(&mut out),
            Entity::Expression(c) => c.append_ids(&mut out),
            Entity::ExpressionConversionBasedUnit(c) => c.append_ids(&mut out),
            Entity::Extension(c) => c.append_ids(&mut out),
            Entity::ExternalIdentificationAssignment(c) => c.append_ids(&mut out),
            Entity::ExternalSource(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedCharacterGlyph(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedClass(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedCurveFont(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedDimensionDefinition(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedFeatureDefinition(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedGeneralProperty(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedHatchStyle(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedItem(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedItemRelationship(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedStyle(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedSymbol(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedTextFont(c) => c.append_ids(&mut out),
            Entity::ExternallyDefinedTileStyle(c) => c.append_ids(&mut out),
            Entity::ExtrudedAreaSolid(c) => c.append_ids(&mut out),
            Entity::ExtrudedFaceSolid(c) => c.append_ids(&mut out),
            Entity::Face(c) => c.append_ids(&mut out),
            Entity::FaceBasedSurfaceModel(c) => c.append_ids(&mut out),
            Entity::FaceBound(c) => c.append_ids(&mut out),
            Entity::FaceOuterBound(c) => c.append_ids(&mut out),
            Entity::FaceShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::FaceSurface(c) => c.append_ids(&mut out),
            Entity::FacetedBrep(c) => c.append_ids(&mut out),
            Entity::FacetedBrepShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::FeatureComponentDefinition(c) => c.append_ids(&mut out),
            Entity::FeatureComponentRelationship(c) => c.append_ids(&mut out),
            Entity::FeatureDefinition(c) => c.append_ids(&mut out),
            Entity::FeatureInPanel(c) => c.append_ids(&mut out),
            Entity::FeaturePattern(c) => c.append_ids(&mut out),
            Entity::FeaturedShape(c) => c.append_ids(&mut out),
            Entity::FillAreaStyle(c) => c.append_ids(&mut out),
            Entity::FillAreaStyleColour(c) => c.append_ids(&mut out),
            Entity::FillAreaStyleHatching(c) => c.append_ids(&mut out),
            Entity::FillAreaStyleTileSymbolWithStyle(c) => c.append_ids(&mut out),
            Entity::FillAreaStyleTiles(c) => c.append_ids(&mut out),
            Entity::Fillet(c) => c.append_ids(&mut out),
            Entity::FlatnessTolerance(c) => c.append_ids(&mut out),
            Entity::FormatFunction(c) => c.append_ids(&mut out),
            Entity::FoundedItem(c) => c.append_ids(&mut out),
            Entity::FoundedKinematicPath(c) => c.append_ids(&mut out),
            Entity::FullyConstrainedPair(c) => c.append_ids(&mut out),
            Entity::FunctionallyDefinedTransformation(c) => c.append_ids(&mut out),
            Entity::GearPair(c) => c.append_ids(&mut out),
            Entity::GearPairRange(c) => c.append_ids(&mut out),
            Entity::GearPairValue(c) => c.append_ids(&mut out),
            Entity::GeneralFeature(c) => c.append_ids(&mut out),
            Entity::GeneralMaterialProperty(c) => c.append_ids(&mut out),
            Entity::GeneralProperty(c) => c.append_ids(&mut out),
            Entity::GeneralPropertyAssociation(c) => c.append_ids(&mut out),
            Entity::GeneralPropertyRelationship(c) => c.append_ids(&mut out),
            Entity::GenericCharacterGlyphSymbol(c) => c.append_ids(&mut out),
            Entity::GenericExpression(c) => c.append_ids(&mut out),
            Entity::GenericLiteral(c) => c.append_ids(&mut out),
            Entity::GenericVariable(c) => c.append_ids(&mut out),
            Entity::GeometricAlignment(c) => c.append_ids(&mut out),
            Entity::GeometricCurveSet(c) => c.append_ids(&mut out),
            Entity::GeometricIntersection(c) => c.append_ids(&mut out),
            Entity::GeometricItemSpecificUsage(c) => c.append_ids(&mut out),
            Entity::GeometricRepresentationContext(c) => c.append_ids(&mut out),
            Entity::GeometricRepresentationItem(c) => c.append_ids(&mut out),
            Entity::GeometricSet(c) => c.append_ids(&mut out),
            Entity::GeometricTolerance(c) => c.append_ids(&mut out),
            Entity::GeometricToleranceRelationship(c) => c.append_ids(&mut out),
            Entity::GeometricToleranceWithDatumReference(c) => c.append_ids(&mut out),
            Entity::GeometricToleranceWithDefinedUnit(c) => c.append_ids(&mut out),
            Entity::GeometricalToleranceCallout(c) => c.append_ids(&mut out),
            Entity::GeometricallyBounded2dWireframeRepresentation(c) => c.append_ids(&mut out),
            Entity::GeometricallyBoundedSurfaceShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::GeometricallyBoundedWireframeShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::GlobalUncertaintyAssignedContext(c) => c.append_ids(&mut out),
            Entity::GlobalUnitAssignedContext(c) => c.append_ids(&mut out),
            Entity::Group(c) => c.append_ids(&mut out),
            Entity::GroupAssignment(c) => c.append_ids(&mut out),
            Entity::GroupRelationship(c) => c.append_ids(&mut out),
            Entity::HalfSpaceSolid(c) => c.append_ids(&mut out),
            Entity::HardnessRepresentation(c) => c.append_ids(&mut out),
            Entity::HiddenElementOverRidingStyledItem(c) => c.append_ids(&mut out),
            Entity::HoleBottom(c) => c.append_ids(&mut out),
            Entity::HoleInPanel(c) => c.append_ids(&mut out),
            Entity::HomokineticPair(c) => c.append_ids(&mut out),
            Entity::Hyperbola(c) => c.append_ids(&mut out),
            Entity::IdAttribute(c) => c.append_ids(&mut out),
            Entity::IdentificationAssignment(c) => c.append_ids(&mut out),
            Entity::IdentificationRole(c) => c.append_ids(&mut out),
            Entity::InclusionProductConceptFeature(c) => c.append_ids(&mut out),
            Entity::IndexExpression(c) => c.append_ids(&mut out),
            Entity::InitialState(c) => c.append_ids(&mut out),
            Entity::InstancedFeature(c) => c.append_ids(&mut out),
            Entity::IntLiteral(c) => c.append_ids(&mut out),
            Entity::IntNumericVariable(c) => c.append_ids(&mut out),
            Entity::IntValueFunction(c) => c.append_ids(&mut out),
            Entity::IntegerDefinedFunction(c) => c.append_ids(&mut out),
            Entity::InterpolatedConfigurationSequence(c) => c.append_ids(&mut out),
            Entity::IntersectionCurve(c) => c.append_ids(&mut out),
            Entity::IntervalExpression(c) => c.append_ids(&mut out),
            Entity::Invisibility(c) => c.append_ids(&mut out),
            Entity::ItemDefinedTransformation(c) => c.append_ids(&mut out),
            Entity::ItemIdentifiedRepresentationUsage(c) => c.append_ids(&mut out),
            Entity::Joggle(c) => c.append_ids(&mut out),
            Entity::JoggleTermination(c) => c.append_ids(&mut out),
            Entity::KinematicAnalysisConsistency(c) => c.append_ids(&mut out),
            Entity::KinematicAnalysisResult(c) => c.append_ids(&mut out),
            Entity::KinematicControl(c) => c.append_ids(&mut out),
            Entity::KinematicFrameBackgroundRepresentation(c) => c.append_ids(&mut out),
            Entity::KinematicFrameBackgroundRepresentationAssociation(c) => c.append_ids(&mut out),
            Entity::KinematicFrameBasedTransformation(c) => c.append_ids(&mut out),
            Entity::KinematicGroundRepresentation(c) => c.append_ids(&mut out),
            Entity::KinematicJoint(c) => c.append_ids(&mut out),
            Entity::KinematicLink(c) => c.append_ids(&mut out),
            Entity::KinematicLinkRepresentation(c) => c.append_ids(&mut out),
            Entity::KinematicLinkRepresentationAssociation(c) => c.append_ids(&mut out),
            Entity::KinematicLinkRepresentationRelation(c) => c.append_ids(&mut out),
            Entity::KinematicPair(c) => c.append_ids(&mut out),
            Entity::KinematicPath(c) => c.append_ids(&mut out),
            Entity::KinematicPropertyDefinition(c) => c.append_ids(&mut out),
            Entity::KinematicPropertyRepresentationRelation(c) => c.append_ids(&mut out),
            Entity::KinematicStructure(c) => c.append_ids(&mut out),
            Entity::KnownSource(c) => c.append_ids(&mut out),
            Entity::Language(c) => c.append_ids(&mut out),
            Entity::LanguageAssignment(c) => c.append_ids(&mut out),
            Entity::LeaderCurve(c) => c.append_ids(&mut out),
            Entity::LeaderDirectedCallout(c) => c.append_ids(&mut out),
            Entity::LeaderDirectedDimension(c) => c.append_ids(&mut out),
            Entity::LeaderTerminator(c) => c.append_ids(&mut out),
            Entity::LengthFunction(c) => c.append_ids(&mut out),
            Entity::LengthMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::LengthUnit(c) => c.append_ids(&mut out),
            Entity::LightSource(c) => c.append_ids(&mut out),
            Entity::LightSourceAmbient(c) => c.append_ids(&mut out),
            Entity::LightSourceDirectional(c) => c.append_ids(&mut out),
            Entity::LightSourcePositional(c) => c.append_ids(&mut out),
            Entity::LightSourceSpot(c) => c.append_ids(&mut out),
            Entity::LikeExpression(c) => c.append_ids(&mut out),
            Entity::LimitsAndFits(c) => c.append_ids(&mut out),
            Entity::Line(c) => c.append_ids(&mut out),
            Entity::LineProfileTolerance(c) => c.append_ids(&mut out),
            Entity::LinearDimension(c) => c.append_ids(&mut out),
            Entity::LiteralNumber(c) => c.append_ids(&mut out),
            Entity::LocalTime(c) => c.append_ids(&mut out),
            Entity::LocationShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::Locator(c) => c.append_ids(&mut out),
            Entity::Log10Function(c) => c.append_ids(&mut out),
            Entity::Log2Function(c) => c.append_ids(&mut out),
            Entity::LogFunction(c) => c.append_ids(&mut out),
            Entity::Loop(c) => c.append_ids(&mut out),
            Entity::LotEffectivity(c) => c.append_ids(&mut out),
            Entity::LuminousIntensityMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::LuminousIntensityUnit(c) => c.append_ids(&mut out),
            Entity::MakeFromUsageOption(c) => c.append_ids(&mut out),
            Entity::ManifoldSolidBrep(c) => c.append_ids(&mut out),
            Entity::ManifoldSubsurfaceShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::ManifoldSurfaceShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::MappedItem(c) => c.append_ids(&mut out),
            Entity::MassMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::MassUnit(c) => c.append_ids(&mut out),
            Entity::MaterialDesignation(c) => c.append_ids(&mut out),
            Entity::MaterialDesignationCharacterization(c) => c.append_ids(&mut out),
            Entity::MaterialProperty(c) => c.append_ids(&mut out),
            Entity::MaterialPropertyRepresentation(c) => c.append_ids(&mut out),
            Entity::MaximumFunction(c) => c.append_ids(&mut out),
            Entity::MeasureQualification(c) => c.append_ids(&mut out),
            Entity::MeasureRepresentationItem(c) => c.append_ids(&mut out),
            Entity::MeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::MechanicalDesignGeometricPresentationArea(c) => c.append_ids(&mut out),
            Entity::MechanicalDesignGeometricPresentationRepresentation(c) => c.append_ids(&mut out),
            Entity::Mechanism(c) => c.append_ids(&mut out),
            Entity::MechanismBasePlacement(c) => c.append_ids(&mut out),
            Entity::MinimumFunction(c) => c.append_ids(&mut out),
            Entity::MinusExpression(c) => c.append_ids(&mut out),
            Entity::MinusFunction(c) => c.append_ids(&mut out),
            Entity::ModExpression(c) => c.append_ids(&mut out),
            Entity::ModifiedGeometricTolerance(c) => c.append_ids(&mut out),
            Entity::ModifiedPattern(c) => c.append_ids(&mut out),
            Entity::MomentsOfInertiaRepresentation(c) => c.append_ids(&mut out),
            Entity::MotionLinkRelationship(c) => c.append_ids(&mut out),
            Entity::MultExpression(c) => c.append_ids(&mut out),
            Entity::MultiLanguageAttributeAssignment(c) => c.append_ids(&mut out),
            Entity::MultipleArityBooleanExpression(c) => c.append_ids(&mut out),
            Entity::MultipleArityFunctionCall(c) => c.append_ids(&mut out),
            Entity::MultipleArityGenericExpression(c) => c.append_ids(&mut out),
            Entity::MultipleArityNumericExpression(c) => c.append_ids(&mut out),
            Entity::NameAssignment(c) => c.append_ids(&mut out),
            Entity::NameAttribute(c) => c.append_ids(&mut out),
            Entity::NamedUnit(c) => c.append_ids(&mut out),
            Entity::NamedUnitVariable(c) => c.append_ids(&mut out),
            Entity::NextAssemblyUsageOccurrence(c) => c.append_ids(&mut out),
            Entity::NgonClosedProfile(c) => c.append_ids(&mut out),
            Entity::NonManifoldSurfaceShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::NotExpression(c) => c.append_ids(&mut out),
            Entity::NumericDefinedFunction(c) => c.append_ids(&mut out),
            Entity::NumericExpression(c) => c.append_ids(&mut out),
            Entity::NumericVariable(c) => c.append_ids(&mut out),
            Entity::ObjectRole(c) => c.append_ids(&mut out),
            Entity::OddFunction(c) => c.append_ids(&mut out),
            Entity::OffsetCurve2d(c) => c.append_ids(&mut out),
            Entity::OffsetCurve3d(c) => c.append_ids(&mut out),
            Entity::OffsetSurface(c) => c.append_ids(&mut out),
            Entity::OneDirectionRepeatFactor(c) => c.append_ids(&mut out),
            Entity::OpenPathProfile(c) => c.append_ids(&mut out),
            Entity::OpenShell(c) => c.append_ids(&mut out),
            Entity::OrExpression(c) => c.append_ids(&mut out),
            Entity::OrdinateDimension(c) => c.append_ids(&mut out),
            Entity::Organization(c) => c.append_ids(&mut out),
            Entity::OrganizationAssignment(c) => c.append_ids(&mut out),
            Entity::OrganizationRelationship(c) => c.append_ids(&mut out),
            Entity::OrganizationRole(c) => c.append_ids(&mut out),
            Entity::OrganizationalAddress(c) => c.append_ids(&mut out),
            Entity::OrganizationalProject(c) => c.append_ids(&mut out),
            Entity::OrganizationalProjectAssignment(c) => c.append_ids(&mut out),
            Entity::OrganizationalProjectRelationship(c) => c.append_ids(&mut out),
            Entity::OrganizationalProjectRole(c) => c.append_ids(&mut out),
            Entity::OrientedClosedShell(c) => c.append_ids(&mut out),
            Entity::OrientedEdge(c) => c.append_ids(&mut out),
            Entity::OrientedFace(c) => c.append_ids(&mut out),
            Entity::OrientedOpenShell(c) => c.append_ids(&mut out),
            Entity::OrientedPath(c) => c.append_ids(&mut out),
            Entity::OrientedSurface(c) => c.append_ids(&mut out),
            Entity::OuterBoundaryCurve(c) => c.append_ids(&mut out),
            Entity::OverRidingStyledItem(c) => c.append_ids(&mut out),
            Entity::PackageProductConceptFeature(c) => c.append_ids(&mut out),
            Entity::PairActuator(c) => c.append_ids(&mut out),
            Entity::PairValue(c) => c.append_ids(&mut out),
            Entity::Parabola(c) => c.append_ids(&mut out),
            Entity::ParallelOffset(c) => c.append_ids(&mut out),
            Entity::ParallelismTolerance(c) => c.append_ids(&mut out),
            Entity::ParametricRepresentationContext(c) => c.append_ids(&mut out),
            Entity::PartialCircularProfile(c) => c.append_ids(&mut out),
            Entity::Path(c) => c.append_ids(&mut out),
            Entity::PathFeatureComponent(c) => c.append_ids(&mut out),
            Entity::PathShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::PatternOffsetMembership(c) => c.append_ids(&mut out),
            Entity::PatternOmitMembership(c) => c.append_ids(&mut out),
            Entity::Pcurve(c) => c.append_ids(&mut out),
            Entity::PerpendicularTo(c) => c.append_ids(&mut out),
            Entity::PerpendicularityTolerance(c) => c.append_ids(&mut out),
            Entity::Person(c) => c.append_ids(&mut out),
            Entity::PersonAndOrganization(c) => c.append_ids(&mut out),
            Entity::PersonAndOrganizationAddress(c) => c.append_ids(&mut out),
            Entity::PersonAndOrganizationAssignment(c) => c.append_ids(&mut out),
            Entity::PersonAndOrganizationRole(c) => c.append_ids(&mut out),
            Entity::PersonalAddress(c) => c.append_ids(&mut out),
            Entity::PhysicallyModelledProductDefinition(c) => c.append_ids(&mut out),
            Entity::PlacedDatumTargetFeature(c) => c.append_ids(&mut out),
            Entity::PlacedFeature(c) => c.append_ids(&mut out),
            Entity::Placement(c) => c.append_ids(&mut out),
            Entity::PlanarBox(c) => c.append_ids(&mut out),
            Entity::PlanarCurvePair(c) => c.append_ids(&mut out),
            Entity::PlanarCurvePairRange(c) => c.append_ids(&mut out),
            Entity::PlanarExtent(c) => c.append_ids(&mut out),
            Entity::PlanarPair(c) => c.append_ids(&mut out),
            Entity::PlanarPairRange(c) => c.append_ids(&mut out),
            Entity::PlanarPairValue(c) => c.append_ids(&mut out),
            Entity::PlanarShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::Plane(c) => c.append_ids(&mut out),
            Entity::PlaneAngleMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::PlaneAngleUnit(c) => c.append_ids(&mut out),
            Entity::PlusExpression(c) => c.append_ids(&mut out),
            Entity::PlusMinusTolerance(c) => c.append_ids(&mut out),
            Entity::Pocket(c) => c.append_ids(&mut out),
            Entity::PocketBottom(c) => c.append_ids(&mut out),
            Entity::Point(c) => c.append_ids(&mut out),
            Entity::PointOnCurve(c) => c.append_ids(&mut out),
            Entity::PointOnPlanarCurvePair(c) => c.append_ids(&mut out),
            Entity::PointOnPlanarCurvePairRange(c) => c.append_ids(&mut out),
            Entity::PointOnPlanarCurvePairValue(c) => c.append_ids(&mut out),
            Entity::PointOnSurface(c) => c.append_ids(&mut out),
            Entity::PointOnSurfacePair(c) => c.append_ids(&mut out),
            Entity::PointOnSurfacePairRange(c) => c.append_ids(&mut out),
            Entity::PointOnSurfacePairValue(c) => c.append_ids(&mut out),
            Entity::PointPlacementShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::PointReplica(c) => c.append_ids(&mut out),
            Entity::PointStyle(c) => c.append_ids(&mut out),
            Entity::PolyLoop(c) => c.append_ids(&mut out),
            Entity::Polyline(c) => c.append_ids(&mut out),
            Entity::PositionTolerance(c) => c.append_ids(&mut out),
            Entity::PowerExpression(c) => c.append_ids(&mut out),
            Entity::PreDefinedColour(c) => c.append_ids(&mut out),
            Entity::PreDefinedCurveFont(c) => c.append_ids(&mut out),
            Entity::PreDefinedDimensionSymbol(c) => c.append_ids(&mut out),
            Entity::PreDefinedGeometricalToleranceSymbol(c) => c.append_ids(&mut out),
            Entity::PreDefinedItem(c) => c.append_ids(&mut out),
            Entity::PreDefinedMarker(c) => c.append_ids(&mut out),
            Entity::PreDefinedPointMarkerSymbol(c) => c.append_ids(&mut out),
            Entity::PreDefinedPresentationStyle(c) => c.append_ids(&mut out),
            Entity::PreDefinedSurfaceConditionSymbol(c) => c.append_ids(&mut out),
            Entity::PreDefinedSymbol(c) => c.append_ids(&mut out),
            Entity::PreDefinedTerminatorSymbol(c) => c.append_ids(&mut out),
            Entity::PreDefinedTextFont(c) => c.append_ids(&mut out),
            Entity::PrecisionQualifier(c) => c.append_ids(&mut out),
            Entity::PresentationArea(c) => c.append_ids(&mut out),
            Entity::PresentationLayerAssignment(c) => c.append_ids(&mut out),
            Entity::PresentationRepresentation(c) => c.append_ids(&mut out),
            Entity::PresentationSet(c) => c.append_ids(&mut out),
            Entity::PresentationSize(c) => c.append_ids(&mut out),
            Entity::PresentationStyleAssignment(c) => c.append_ids(&mut out),
            Entity::PresentationStyleByContext(c) => c.append_ids(&mut out),
            Entity::PresentationView(c) => c.append_ids(&mut out),
            Entity::PresentedItem(c) => c.append_ids(&mut out),
            Entity::PresentedItemRepresentation(c) => c.append_ids(&mut out),
            Entity::PrismaticPair(c) => c.append_ids(&mut out),
            Entity::PrismaticPairRange(c) => c.append_ids(&mut out),
            Entity::PrismaticPairValue(c) => c.append_ids(&mut out),
            Entity::ProcessOperation(c) => c.append_ids(&mut out),
            Entity::ProcessPlan(c) => c.append_ids(&mut out),
            Entity::ProcessProductAssociation(c) => c.append_ids(&mut out),
            Entity::ProcessPropertyAssociation(c) => c.append_ids(&mut out),
            Entity::Product(c) => c.append_ids(&mut out),
            Entity::ProductCategory(c) => c.append_ids(&mut out),
            Entity::ProductCategoryRelationship(c) => c.append_ids(&mut out),
            Entity::ProductClass(c) => c.append_ids(&mut out),
            Entity::ProductConcept(c) => c.append_ids(&mut out),
            Entity::ProductConceptContext(c) => c.append_ids(&mut out),
            Entity::ProductConceptFeature(c) => c.append_ids(&mut out),
            Entity::ProductConceptFeatureAssociation(c) => c.append_ids(&mut out),
            Entity::ProductConceptFeatureCategory(c) => c.append_ids(&mut out),
            Entity::ProductConceptFeatureCategoryUsage(c) => c.append_ids(&mut out),
            Entity::ProductConceptRelationship(c) => c.append_ids(&mut out),
            Entity::ProductContext(c) => c.append_ids(&mut out),
            Entity::ProductDefinition(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionContext(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionContextAssociation(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionContextRole(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionEffectivity(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionFormation(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionFormationRelationship(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionFormationWithSpecifiedSource(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionOccurrenceRelationship(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionProcess(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionRelationship(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionResource(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionShape(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionSubstitute(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionUsage(c) => c.append_ids(&mut out),
            Entity::ProductDefinitionWithAssociatedDocuments(c) => c.append_ids(&mut out),
            Entity::ProductIdentification(c) => c.append_ids(&mut out),
            Entity::ProductProcessPlan(c) => c.append_ids(&mut out),
            Entity::ProductRelatedProductCategory(c) => c.append_ids(&mut out),
            Entity::ProductSpecification(c) => c.append_ids(&mut out),
            Entity::ProjectedZoneDefinition(c) => c.append_ids(&mut out),
            Entity::ProjectionCurve(c) => c.append_ids(&mut out),
            Entity::ProjectionDirectedCallout(c) => c.append_ids(&mut out),
            Entity::PromissoryUsageOccurrence(c) => c.append_ids(&mut out),
            Entity::PropertyDefinition(c) => c.append_ids(&mut out),
            Entity::PropertyDefinitionRelationship(c) => c.append_ids(&mut out),
            Entity::PropertyDefinitionRepresentation(c) => c.append_ids(&mut out),
            Entity::PropertyProcess(c) => c.append_ids(&mut out),
            Entity::QualifiedRepresentationItem(c) => c.append_ids(&mut out),
            Entity::QualitativeUncertainty(c) => c.append_ids(&mut out),
            Entity::QuantifiedAssemblyComponentUsage(c) => c.append_ids(&mut out),
            Entity::QuasiUniformCurve(c) => c.append_ids(&mut out),
            Entity::QuasiUniformSurface(c) => c.append_ids(&mut out),
            Entity::RackAndPinionPair(c) => c.append_ids(&mut out),
            Entity::RackAndPinionPairRange(c) => c.append_ids(&mut out),
            Entity::RackAndPinionPairValue(c) => c.append_ids(&mut out),
            Entity::RadiusDimension(c) => c.append_ids(&mut out),
            Entity::RatioMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::RatioUnit(c) => c.append_ids(&mut out),
            Entity::RationalBSplineCurve(c) => c.append_ids(&mut out),
            Entity::RationalBSplineSurface(c) => c.append_ids(&mut out),
            Entity::RealDefinedFunction(c) => c.append_ids(&mut out),
            Entity::RealLiteral(c) => c.append_ids(&mut out),
            Entity::RealNumericVariable(c) => c.append_ids(&mut out),
            Entity::RectangularClosedProfile(c) => c.append_ids(&mut out),
            Entity::RectangularCompositeSurface(c) => c.append_ids(&mut out),
            Entity::RectangularPattern(c) => c.append_ids(&mut out),
            Entity::RectangularTrimmedSurface(c) => c.append_ids(&mut out),
            Entity::ReferencedModifiedDatum(c) => c.append_ids(&mut out),
            Entity::RelativeEventOccurrence(c) => c.append_ids(&mut out),
            Entity::RepItemGroup(c) => c.append_ids(&mut out),
            Entity::ReparametrisedCompositeCurveSegment(c) => c.append_ids(&mut out),
            Entity::ReplicateFeature(c) => c.append_ids(&mut out),
            Entity::Representation(c) => c.append_ids(&mut out),
            Entity::RepresentationContext(c) => c.append_ids(&mut out),
            Entity::RepresentationItem(c) => c.append_ids(&mut out),
            Entity::RepresentationMap(c) => c.append_ids(&mut out),
            Entity::RepresentationRelationship(c) => c.append_ids(&mut out),
            Entity::RepresentationRelationshipWithTransformation(c) => c.append_ids(&mut out),
            Entity::RequirementForActionResource(c) => c.append_ids(&mut out),
            Entity::ResourceProperty(c) => c.append_ids(&mut out),
            Entity::ResourcePropertyRepresentation(c) => c.append_ids(&mut out),
            Entity::ResourceRequirementType(c) => c.append_ids(&mut out),
            Entity::ResultingPath(c) => c.append_ids(&mut out),
            Entity::Retention(c) => c.append_ids(&mut out),
            Entity::RevolutePair(c) => c.append_ids(&mut out),
            Entity::RevolutePairRange(c) => c.append_ids(&mut out),
            Entity::RevolutePairValue(c) => c.append_ids(&mut out),
            Entity::RevolvedAreaSolid(c) => c.append_ids(&mut out),
            Entity::RevolvedFaceSolid(c) => c.append_ids(&mut out),
            Entity::Rib(c) => c.append_ids(&mut out),
            Entity::RightAngularWedge(c) => c.append_ids(&mut out),
            Entity::RightCircularCone(c) => c.append_ids(&mut out),
            Entity::RightCircularCylinder(c) => c.append_ids(&mut out),
            Entity::RoleAssociation(c) => c.append_ids(&mut out),
            Entity::RollingCurvePair(c) => c.append_ids(&mut out),
            Entity::RollingCurvePairValue(c) => c.append_ids(&mut out),
            Entity::RollingSurfacePair(c) => c.append_ids(&mut out),
            Entity::RollingSurfacePairValue(c) => c.append_ids(&mut out),
            Entity::RotationAboutDirection(c) => c.append_ids(&mut out),
            Entity::RoundHole(c) => c.append_ids(&mut out),
            Entity::RoundedUProfile(c) => c.append_ids(&mut out),
            Entity::RoundnessTolerance(c) => c.append_ids(&mut out),
            Entity::RuledSurfaceSweptAreaSolid(c) => c.append_ids(&mut out),
            Entity::RunoutZoneDefinition(c) => c.append_ids(&mut out),
            Entity::RunoutZoneOrientation(c) => c.append_ids(&mut out),
            Entity::RunoutZoneOrientationReferenceDirection(c) => c.append_ids(&mut out),
            Entity::ScrewPair(c) => c.append_ids(&mut out),
            Entity::ScrewPairRange(c) => c.append_ids(&mut out),
            Entity::ScrewPairValue(c) => c.append_ids(&mut out),
            Entity::SeamCurve(c) => c.append_ids(&mut out),
            Entity::SeamEdge(c) => c.append_ids(&mut out),
            Entity::SecurityClassification(c) => c.append_ids(&mut out),
            Entity::SecurityClassificationAssignment(c) => c.append_ids(&mut out),
            Entity::SecurityClassificationLevel(c) => c.append_ids(&mut out),
            Entity::SerialNumberedEffectivity(c) => c.append_ids(&mut out),
            Entity::ShapeAspect(c) => c.append_ids(&mut out),
            Entity::ShapeAspectAssociativity(c) => c.append_ids(&mut out),
            Entity::ShapeAspectDerivingRelationship(c) => c.append_ids(&mut out),
            Entity::ShapeAspectRelationship(c) => c.append_ids(&mut out),
            Entity::ShapeAspectTransition(c) => c.append_ids(&mut out),
            Entity::ShapeDefiningRelationship(c) => c.append_ids(&mut out),
            Entity::ShapeDefinitionRepresentation(c) => c.append_ids(&mut out),
            Entity::ShapeDimensionRepresentation(c) => c.append_ids(&mut out),
            Entity::ShapeRepresentation(c) => c.append_ids(&mut out),
            Entity::ShapeRepresentationRelationship(c) => c.append_ids(&mut out),
            Entity::ShapeRepresentationWithParameters(c) => c.append_ids(&mut out),
            Entity::ShellBasedSurfaceModel(c) => c.append_ids(&mut out),
            Entity::SiUnit(c) => c.append_ids(&mut out),
            Entity::SimpleBooleanExpression(c) => c.append_ids(&mut out),
            Entity::SimpleGenericExpression(c) => c.append_ids(&mut out),
            Entity::SimpleNumericExpression(c) => c.append_ids(&mut out),
            Entity::SimplePairRange(c) => c.append_ids(&mut out),
            Entity::SimpleStringExpression(c) => c.append_ids(&mut out),
            Entity::SinFunction(c) => c.append_ids(&mut out),
            Entity::SlashExpression(c) => c.append_ids(&mut out),
            Entity::SlidingCurvePair(c) => c.append_ids(&mut out),
            Entity::SlidingCurvePairValue(c) => c.append_ids(&mut out),
            Entity::SlidingSurfacePair(c) => c.append_ids(&mut out),
            Entity::SlidingSurfacePairValue(c) => c.append_ids(&mut out),
            Entity::Slot(c) => c.append_ids(&mut out),
            Entity::SlotEnd(c) => c.append_ids(&mut out),
            Entity::SolidAngleMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::SolidAngleUnit(c) => c.append_ids(&mut out),
            Entity::SolidModel(c) => c.append_ids(&mut out),
            Entity::SolidReplica(c) => c.append_ids(&mut out),
            Entity::SpecifiedHigherUsageOccurrence(c) => c.append_ids(&mut out),
            Entity::Sphere(c) => c.append_ids(&mut out),
            Entity::SphericalPair(c) => c.append_ids(&mut out),
            Entity::SphericalPairRange(c) => c.append_ids(&mut out),
            Entity::SphericalPairValue(c) => c.append_ids(&mut out),
            Entity::SphericalSurface(c) => c.append_ids(&mut out),
            Entity::SqlMappableDefinedFunction(c) => c.append_ids(&mut out),
            Entity::SquareRootFunction(c) => c.append_ids(&mut out),
            Entity::SquareUProfile(c) => c.append_ids(&mut out),
            Entity::StandardUncertainty(c) => c.append_ids(&mut out),
            Entity::StraightnessTolerance(c) => c.append_ids(&mut out),
            Entity::StringDefinedFunction(c) => c.append_ids(&mut out),
            Entity::StringExpression(c) => c.append_ids(&mut out),
            Entity::StringLiteral(c) => c.append_ids(&mut out),
            Entity::StringVariable(c) => c.append_ids(&mut out),
            Entity::StructuredDimensionCallout(c) => c.append_ids(&mut out),
            Entity::StyledItem(c) => c.append_ids(&mut out),
            Entity::Subedge(c) => c.append_ids(&mut out),
            Entity::Subface(c) => c.append_ids(&mut out),
            Entity::SubstringExpression(c) => c.append_ids(&mut out),
            Entity::Surface(c) => c.append_ids(&mut out),
            Entity::SurfaceConditionCallout(c) => c.append_ids(&mut out),
            Entity::SurfaceCurve(c) => c.append_ids(&mut out),
            Entity::SurfaceCurveSweptAreaSolid(c) => c.append_ids(&mut out),
            Entity::SurfaceOfLinearExtrusion(c) => c.append_ids(&mut out),
            Entity::SurfaceOfRevolution(c) => c.append_ids(&mut out),
            Entity::SurfacePair(c) => c.append_ids(&mut out),
            Entity::SurfacePairRange(c) => c.append_ids(&mut out),
            Entity::SurfacePatch(c) => c.append_ids(&mut out),
            Entity::SurfaceProfileTolerance(c) => c.append_ids(&mut out),
            Entity::SurfaceRenderingProperties(c) => c.append_ids(&mut out),
            Entity::SurfaceReplica(c) => c.append_ids(&mut out),
            Entity::SurfaceSideStyle(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleBoundary(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleControlGrid(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleFillArea(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleParameterLine(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleReflectanceAmbient(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleReflectanceAmbientDiffuse(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleReflectanceAmbientDiffuseSpecular(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleRendering(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleRenderingWithProperties(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleSegmentationCurve(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleSilhouette(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleTransparent(c) => c.append_ids(&mut out),
            Entity::SurfaceStyleUsage(c) => c.append_ids(&mut out),
            Entity::SurfaceTextureRepresentation(c) => c.append_ids(&mut out),
            Entity::SweptAreaSolid(c) => c.append_ids(&mut out),
            Entity::SweptDiskSolid(c) => c.append_ids(&mut out),
            Entity::SweptFaceSolid(c) => c.append_ids(&mut out),
            Entity::SweptSurface(c) => c.append_ids(&mut out),
            Entity::SymbolColour(c) => c.append_ids(&mut out),
            Entity::SymbolRepresentation(c) => c.append_ids(&mut out),
            Entity::SymbolRepresentationMap(c) => c.append_ids(&mut out),
            Entity::SymbolStyle(c) => c.append_ids(&mut out),
            Entity::SymbolTarget(c) => c.append_ids(&mut out),
            Entity::SymmetricShapeAspect(c) => c.append_ids(&mut out),
            Entity::SymmetryTolerance(c) => c.append_ids(&mut out),
            Entity::TactileAppearanceRepresentation(c) => c.append_ids(&mut out),
            Entity::TanFunction(c) => c.append_ids(&mut out),
            Entity::Tangent(c) => c.append_ids(&mut out),
            Entity::Taper(c) => c.append_ids(&mut out),
            Entity::TeeProfile(c) => c.append_ids(&mut out),
            Entity::TerminatorSymbol(c) => c.append_ids(&mut out),
            Entity::TextLiteral(c) => c.append_ids(&mut out),
            Entity::TextLiteralWithAssociatedCurves(c) => c.append_ids(&mut out),
            Entity::TextLiteralWithBlankingBox(c) => c.append_ids(&mut out),
            Entity::TextLiteralWithDelineation(c) => c.append_ids(&mut out),
            Entity::TextLiteralWithExtent(c) => c.append_ids(&mut out),
            Entity::TextStringRepresentation(c) => c.append_ids(&mut out),
            Entity::TextStyle(c) => c.append_ids(&mut out),
            Entity::TextStyleForDefinedFont(c) => c.append_ids(&mut out),
            Entity::TextStyleWithBoxCharacteristics(c) => c.append_ids(&mut out),
            Entity::TextStyleWithMirror(c) => c.append_ids(&mut out),
            Entity::TextStyleWithSpacing(c) => c.append_ids(&mut out),
            Entity::ThermodynamicTemperatureMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::ThermodynamicTemperatureUnit(c) => c.append_ids(&mut out),
            Entity::Thread(c) => c.append_ids(&mut out),
            Entity::TimeInterval(c) => c.append_ids(&mut out),
            Entity::TimeIntervalAssignment(c) => c.append_ids(&mut out),
            Entity::TimeIntervalBasedEffectivity(c) => c.append_ids(&mut out),
            Entity::TimeIntervalRole(c) => c.append_ids(&mut out),
            Entity::TimeIntervalWithBounds(c) => c.append_ids(&mut out),
            Entity::TimeMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::TimeUnit(c) => c.append_ids(&mut out),
            Entity::ToleranceValue(c) => c.append_ids(&mut out),
            Entity::ToleranceZone(c) => c.append_ids(&mut out),
            Entity::ToleranceZoneDefinition(c) => c.append_ids(&mut out),
            Entity::ToleranceZoneForm(c) => c.append_ids(&mut out),
            Entity::TopologicalRepresentationItem(c) => c.append_ids(&mut out),
            Entity::ToroidalSurface(c) => c.append_ids(&mut out),
            Entity::Torus(c) => c.append_ids(&mut out),
            Entity::TotalRunoutTolerance(c) => c.append_ids(&mut out),
            Entity::TransitionFeature(c) => c.append_ids(&mut out),
            Entity::TrimmedCurve(c) => c.append_ids(&mut out),
            Entity::TwoDirectionRepeatFactor(c) => c.append_ids(&mut out),
            Entity::TypeQualifier(c) => c.append_ids(&mut out),
            Entity::UnaryBooleanExpression(c) => c.append_ids(&mut out),
            Entity::UnaryFunctionCall(c) => c.append_ids(&mut out),
            Entity::UnaryGenericExpression(c) => c.append_ids(&mut out),
            Entity::UnaryNumericExpression(c) => c.append_ids(&mut out),
            Entity::UncertaintyAssignedRepresentation(c) => c.append_ids(&mut out),
            Entity::UncertaintyMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::UncertaintyQualifier(c) => c.append_ids(&mut out),
            Entity::UnconstrainedPair(c) => c.append_ids(&mut out),
            Entity::UnconstrainedPairValue(c) => c.append_ids(&mut out),
            Entity::UniformCurve(c) => c.append_ids(&mut out),
            Entity::UniformSurface(c) => c.append_ids(&mut out),
            Entity::UniversalPair(c) => c.append_ids(&mut out),
            Entity::UniversalPairRange(c) => c.append_ids(&mut out),
            Entity::UniversalPairValue(c) => c.append_ids(&mut out),
            Entity::ValueFunction(c) => c.append_ids(&mut out),
            Entity::ValueRange(c) => c.append_ids(&mut out),
            Entity::ValueRepresentationItem(c) => c.append_ids(&mut out),
            Entity::Variable(c) => c.append_ids(&mut out),
            Entity::VariableSemantics(c) => c.append_ids(&mut out),
            Entity::Vector(c) => c.append_ids(&mut out),
            Entity::VectorStyle(c) => c.append_ids(&mut out),
            Entity::VeeProfile(c) => c.append_ids(&mut out),
            Entity::VersionedActionRequest(c) => c.append_ids(&mut out),
            Entity::VersionedActionRequestRelationship(c) => c.append_ids(&mut out),
            Entity::Vertex(c) => c.append_ids(&mut out),
            Entity::VertexLoop(c) => c.append_ids(&mut out),
            Entity::VertexPoint(c) => c.append_ids(&mut out),
            Entity::ViewVolume(c) => c.append_ids(&mut out),
            Entity::VisualAppearanceRepresentation(c) => c.append_ids(&mut out),
            Entity::VolumeMeasureWithUnit(c) => c.append_ids(&mut out),
            Entity::VolumeUnit(c) => c.append_ids(&mut out),
            Entity::XorExpression(c) => c.append_ids(&mut out),
            Entity::ComplexEntity(v) => {
                for e in v {
                    out.extend(e.upstream().into_iter());
                }
            },
            _ => (),
        };
        out
    }
}
